/**
 * AmbientRFID
 * Kevin Pinte
 * 
 */

// imports
import /.at.lang.futures exclude minutes, seconds, millisec;
import /.at.support.timer;
import /.at.support.util;
enableFutures(false);

import /.at.rfid.utils.vector;
import /.at.rfid.utils.hashmap; 

import /.at.rfid.utils.extras;
import /.at.rfid.MutatorInterceptorMirror;  

import /.at.rfid.proprefs;

// globals
def POLLING_INTERVAL := millisec(500);
def OFFLINE_TIMEOUT  := 240.seconds();

// toggle debug output
DEBUG := false;
INFO := true;


// generic RFID type tags
deftype RFIDTag;
deftype GenericTag;

//jlobby.add(AT_HOME + "/at/rfid/lib/librfid.jar");


deftype NotAnIsolate <: lobby.at.types.Exception;
def XNotAnIsolate := lobby.at.exceptions.createException(NotAnIsolate);
deftype AlreadyIsolate <: lobby.at.types.Exception;
def XAlreadyIsolate := lobby.at.exceptions.createException(AlreadyIsolate);

def RFIDService := object: {
	
	// Java Reader & Tag classes
	def tagWrapper := jlobby.librfid.file.TagWrapper;
	def JavaRFIDDevice := jlobby.librfid.file.ReaderWrapper;
	
	// the RFID reader device
	def device := nil;
	
	// the facade
	def facade := nil;
	
	// the timeout after which tags are considered permanently discovered
	def offlineTimeout := OFFLINE_TIMEOUT; // unused

	// interval to poll
	def pollingInterval := POLLING_INTERVAL; 
	
	// holds disconnection objects for tags
	def discoTags := HashMap.new;     // serial -> discoObject
	
	// maintain mappings between tags, serials and proxys
	def tagToObject := HashMap.new; // serial -> obj
	def objectToTag := HashMap.new; // obj -> serial
	def serialToTag := HashMap.new; // serial -> tag
	
	// the polling loop
	def loop := nil;
	
	def exportWithSerial(someObject, tagSerial) {
		system.println("export with serial: " + someObject + " with " + tagSerial);
		(tagsOf: someObject).each: {|tt|
			export: someObject as: tt with: { def serial := tagSerial };
		};
	};
	
	// create and remove mapping between tag and object
	def updateMapping(aTag, someObject) {
		def serial := aTag.getSerial();
		info("update mapping: " + serial + " <-> " + someObject);
		tagToObject.put(serial, someObject);
		objectToTag.put(someObject, serial);
		serialToTag.put(serial, aTag);
	};
	
	def createMapping(aTag, someObject) {
		updateMapping(aTag, someObject);
	};
	
	def removeMapping(aTag, someObject) {
		def serial := aTag.getSerial();
		tagToObject.remove(serial);
		objectToTag.remove(someObject);
		serialToTag.remove(serial);
	};
	
	// intercept mutators
	def tagMutatorInterceptor := { |base, method| 
		try: {
			saveToTag(base);
		} catchUsing: {|e| 
			info("save to tag failed: " + e.message);
		};
	};
	
	def makeTagMutatorInterceptorMirror() {
		makeMutatorInterceptor(tagMutatorInterceptor);
	};
	
	
	// dump and load objects to and from a tag
	def loadFromSource(tag){
		def definition := tag.loadToString();
		if: ((definition == nil).or: {definition == ""}) then: {
			nil;
		} else: {
			try: {
				definition := definition + "mirroredBy: makeTagMutatorInterceptorMirror()";
				def obj := eval: (read: definition) in: self;
				obj;
			} catch: /.at.types.Exception using: { |e|
				info("could not read and eval: " + definition);
				info("exeption was: " + e.message);
				nil;
			};
		};
	};
	
	def loadFromIsolate(tag) {
		def isolate := tag.load();
		if: (isolate == nil) then: {
			nil;
		} else: {
			isolateToObject(isolate);
		};
	};
	
	def loadFromJava(tag) {
		tag.load();
	};
	
	def load(tag) {
		loadFromSource(tag);
	};
	
	def dumpToSource(tag, obj) {
		tag.dumpAsCode(obj);
	};
	
	def dumpToIsolate(tag, obj) {
		tag.dump(objectToIsolate(obj));
	};
	
	def dumpToJava(tag, obj) {
		tag.dump(obj);
	};
	
	def dump(tag, obj) {
		dumpToSource(tag, obj);
	};
	
	def saveToTag(someObject) {
		info("saving to tag...");
		def tag := serialToTag.get(objectToTag.get(someObject));
		dump(tag, someObject);
	};
	
	
	// copy an isolate to a "normal" object	
	def isolateToObject(someIsolate) {
		info("convert isolate to object");
		info(someIsolate);
		unless: (is: someIsolate taggedAs: /.at.types.Isolate) then: {
			raise: XNotAnIsolate.new("argument is not an isolate: " + someIsolate);
		};
		info("obj is an isolate");
		def tags := (tagsOf: someIsolate).filter: {|e| e != /.at.types.Isolate};
		info("tags: " + tags);
		def someObject := object: {} taggedAs: tags mirroredBy: makeTagMutatorInterceptorMirror();
		info("new object: " + someObject);
		def ir := reflect: someIsolate;
		def or := reflect: someObject;
		ir.listFields.each: {|f|
			if: (f.name != `super) then: {
				or.addField(f);
			};
		};
		ir.listMethods.each: {|m|
			or.addMethod(m);
		};
		someObject;
	};
	
	// copy an object to an isolate
	def objectToIsolate(someObject) {
		info("convert object to isolate: " + someObject);
		if: (is: someObject taggedAs: /.at.types.Isolate) then: {
			raise: XAlreadyIsolate.new("argument is already an isolate: " + someObject);
		};
		def tags := (tagsOf: someObject).filter: {|e| e != /.at.types.Isolate};
		def someIsolate := isolate: {} taggedAs: tags;
		def ir := reflect: someIsolate;
		def or := reflect: someObject;
		or.listFields.each: {|f|
			if: (f.name != `super) then: {
				ir.addField(f);
			};
		};
		or.listMethods.each: {|m|
			ir.addMethod(m);
		};
		someIsolate;
	};
	
	// generic "empty" tag object
	def GenericTag := object: {

		def tag := nil;
		
		def getSerial() { 
			tag.getSerial();
		};

		def initialize(someObject) {
			if: !(is: someObject taggedAs: /.at.types.Isolate) then: {
				raise: XNotAnIsolate.new("object must be isolate");
			};
			info("before convert isolate to object");
			info(someObject);
			def newObject := isolateToObject(someObject);
			updateMapping(tag, newObject);
			dump(tag, newObject);
			exportWithSerial(newObject, getSerial());
			newObject;
		};

		def init(atag) {
			tag := atag;
		};
	
	} taggedAs: [RFIDTag, GenericTag];
	
	
	// cases to handle RFID inventory
	// case 1: a tag that was already available
	//         - check if there is a disconnection object
	// !!! semantic subtlety: FIRST reconnect the object, THEN replace it
	def ackTag(serial, tag) {
		info("ack serial: " + serial);
		debug("  ack serial: " + serial);
		if: (discoTags.contains(serial)) then: {
			// if tag marked offline
			// take back online
			// update mark

			debug("  reconnect serial: " + serial);
			def disco := discoTags.get(serial);
			disco.reconnect();
			discoTags.remove(serial);
		} else: {
				debug("ignore 1");
		};
		def newObject := load(tag);
		if: (nil != newObject) then: {
			info("replacing object: " + tagToObject.get(serial) + " with: "+ newObject);
			let: newObject become: tagToObject.get(serial);
			updateMapping(tag, newObject);
		};
	};
	
	// case 2: a new tag
	//         - export its proxy or a generic object
	def exportTag(serial, tag) {
		info("new serial: " + serial);
		debug("  new serial: " + serial);
		def tagObject := load(tag);
		if: (nil == tagObject) then: {
			// empty tag
			info("empty tag");
			tagObject := GenericTag.new(tag);
			updateMapping(tag, tagObject);
			def s := serial;
			export: tagObject as: RFIDTag with: { def serial := s };
		} else: {
			info("valid tag");
			updateMapping(tag, tagObject);
			exportWithSerial(tagObject, serial);
		};
	};
	
	// case 3: tag not seen with respect to previous poll
	//         - disconnect
	def unseeTag(serial, tag) {
		if: (!(discoTags.contains(serial))) then: {
			// take all unseen tags offline
	        info("  off serial: " + serial + "object: " + tagToObject.get(serial));
	        def discoTag := disconnect: tagToObject.get(serial);
	        discoTags.put(serial, discoTag);
		} else: {
		    debug("ignore 2");
		};
	};
	
	def startLoop() {
		if: (loop == nil) then: {
			debug("RFIDActor started");
			loop := whenever: pollingInterval elapsed: {
	    
				debug("");
				debug("ROUND started");
				debug("avail tags: " + serialToTag.size());
				debug("disco tags: " + discoTags.size());
			
				def tags := Vector.new(device.readTransponders(true));
				debug("in range: " + tags.size());
				def unseen := serialToTag.clone();
	
				tags.each: { |tag|
					def serial := tag.getSerial();
					unseen.remove(serial);
					if: (serialToTag.contains(serial)) then: {
						// case 1
						// seen before
						// check for possible disconnection object
						ackTag(serial, tag);
					} else: {
						// case 2
						// new tag
						// export!
						exportTag(serial, tag);
					};
				};
				debug("  unseen tags: " + unseen.size());
				unseen.each: {|serial, tag|
					// case 3:
					// disappearing tags
					unseeTag(serial, tag);
				};
			};
		}; // if
	};
	
	def stopLoop() {
		if: (loop != nil) then: {
			loop.cancel();
			loop := nil;
		};
	};
	
	
	// create a facade with functions visible to the outside
	def createFacade() {
		if: (facade == nil) then: {
			facade := object: {
				def getAvailableTags() {
					serialToTag;
				};
		
				def getAvailableObjects() {
					tagToObject;
				};
			
				def getDiscoTags() {
					discoTags;
				};
			
				def displayEmAll() {
					tagToObject.printme();
					objectToTag.printme();
					serialToTag.printme();
				};
			
				def numTags() {
					serialToTag.size();
				};
		
				def numDiscoTags() {
					discoTags.size();
				};
			
				def numConnectedTags() {
					serialToTag.size() - discoTags.size();
				};
			
				def stop() {
					stopLoop();
				};
			
				def run() {
					startLoop();
				};
			}; // object
		};
		facade;
	};
	


	// initializer
	def init(devNum := 0) {
		device := JavaRFIDDevice.new(devNum);
		facade := createFacade();
	};
	
};

def RFIDServiceModule := object: {
	def createRFIDService(devNum := 0) {
		def service := RFIDService.new();
		service.facade;
	};
	
	def createAndRunRFIDService(devNum := 0) {
		def service := RFIDService.new();
		def facade := service.facade;
		facade.run();
		facade;
	};
};


