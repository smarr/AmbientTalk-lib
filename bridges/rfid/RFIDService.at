/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2010
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
**/

/**
 * This file contains the RFID service
 * it detects RFID tags, creates proxy objects and publishes them as services
**/

// imports
import /.at.lang.futures exclude minutes, seconds, millisec;
import /.at.support.timer;
import /.at.support.util;
enableFutures(false);

import /.at.collections.java.vector;
import /.at.collections.java.hashmap; 

import /.at.lang.mutatorInterceptorMirror;  

import /.at.lang.propertyReferences;

// globals
def POLLING_INTERVAL := millisec(500);
POLLING_INTERVAL := 20.seconds; // XXX
def OFFLINE_TIMEOUT  := 240.seconds();

// toggle debug output
def DEBUG := true;
def INFO := true;
def ERR := true;

def debug(@args) {
	if: (DEBUG) then: {
		system.println("[DEBUG] " + args);
	};
};

def info(@args) {
	if: (INFO) then: {
		system.println("[INFO] " + args);
	};
};

def err(@args) {
	if: (ERR) then: {
		system.println("[ERR][!] " + args);
	};
};

// generic RFID type tags
deftype RFIDTag;
deftype GenericTag;


deftype NotAnIsolate <: lobby.at.lang.types.Exception;
def XNotAnIsolate := lobby.at.lang.exceptions.createException(NotAnIsolate);
deftype AlreadyIsolate <: lobby.at.lang.types.Exception;
def XAlreadyIsolate := lobby.at.lang.exceptions.createException(AlreadyIsolate);

def RFIDService := object: {
	
	// Java Reader & Tag classes
	// classes to use:
	//   - ReaderFromDisk to store data locally on disk
	//   - Reader to store data in tag memory
	//def JavaRFIDDevice := jlobby.bridges.rfid.ReaderFromDisk;
	def JavaRFIDDevice := jlobby.bridges.rfid.Reader;
	
	// the RFID reader device
	def device := nil;
	
	// the facade
	def facade := nil;
	
	// the timeout after which tags are considered permanently discovered
	def offlineTimeout := OFFLINE_TIMEOUT; // unused

	// interval to poll
	def pollingInterval := POLLING_INTERVAL; 
	
	// holds disconnection objects for tags
	def discoTags := HashMap.new;     // serial -> discoObject
	
	// maintain mappings between tags, serials and proxys
	def tagToObject := HashMap.new; // serial -> obj
	def objectToTag := HashMap.new; // obj -> serial
	def serialToTag := HashMap.new; // serial -> tag
	
	// the polling loop
	def loop := false;
	
	def exportWithSerial(someObject, tagSerial) {
		system.println("export with serial: " + someObject + " with " + tagSerial);
		def tagsSS := tagsOf: someObject.super.super;
		//(tagsOf: someObject).each: {|tt|
		(tagsSS).each: {|tt| // XXX
			system.println("  " + tt);
			export: someObject as: tt with: { def serial := tagSerial };
		};
	};
	
	// create and remove mapping between tag and object
	def updateMapping(aTag, someObject) {
		def serial := aTag.getSerial().toString();
		info("update mapping: " + serial + " <-> " + someObject);
		tagToObject.put(serial, someObject);
		objectToTag.put(someObject, serial);
		serialToTag.put(serial, aTag);
	};
	
	def createMapping(aTag, someObject) {
		updateMapping(aTag, someObject);
	};
	
	def removeMapping(aTag, someObject) {
		def serial := aTag.getSerial().toString();
		tagToObject.remove(serial);
		objectToTag.remove(someObject);
		serialToTag.remove(serial);
	};
	
	// Intercept mutators
	
	def tagMutatorInterceptor := { |base, method| 
		try: {
			saveToTag(base);
		} catch: {|e| 
			info("save to tag failed: " + e.message);
		};
	};
	
	def makeTagMutatorInterceptorMirror() {
		makeMutatorInterceptor(tagMutatorInterceptor);
	};
	
	def wrapAndPlaceMirror(obj) {
		extend: obj with: {} mirroredBy: makeTagMutatorInterceptorMirror();
	};
	
	// Serialization and Deserialization
	
	// dump and load objects to and from a tag
	def loadFromCode(tag){
		def definition := tag.read();
		debug("definition: " + definition);
		if: ((definition == nil).or: {definition == ""}) then: {
			nil;
		} else: {
			try: {
				def obj := fromCode: definition in: (object:{});
				def wrappedObj := wrapAndPlaceMirror(obj);
				wrappedObj;
			} catch: /.at.lang.types.Exception using: { |e|
				info("could not reify from code: " + definition);
				info("exeption was: " + e.message);
				nil;
			};
		};
	};
	
	def loadFromJava(tag) {
		tag.load();
	};
	
	// default is to deserialize using from
	def load(tag) {
		loadFromCode(tag);
	};
	
	def dumpAsCode(tag, obj) {
		tag.write(asCode: obj.super);
	};
	
	def dumpAsJava(tag, obj) {
		tag.dump(obj);
	};
	
	// default is to serialize using asCode
	def dump(tag, obj) {
		dumpAsCode(tag, obj);
	};
	
	def saveToTag(someObject) {
		info("saving to tag...");
		def tag := serialToTag.get(objectToTag.get(someObject));
		dump(tag, someObject);
	};
	
	// Conversion from and to isolate
	
	// copy an isolate to a "normal" object	
	def isolateToObject(someIsolate) {
		info("convert isolate to object");
		info(someIsolate);
		unless: (is: someIsolate taggedAs: /.at.lang.types.Isolate) then: {
			raise: XNotAnIsolate.new("argument is not an isolate: " + someIsolate);
		};
		info("obj is an isolate");
		def tags := (tagsOf: someIsolate).filter: {|e| e != /.at.lang.types.Isolate};
		info("tags: " + tags);
		def someObject := object: {} taggedAs: tags;
		info("new object: " + someObject);
		def ir := reflect: someIsolate;
		def or := reflect: someObject;
		ir.listFields.each: {|f|
			if: (f.name != `super) then: {
				or.addField(f);
			};
		};
		ir.listMethods.each: {|m|
			or.addMethod(m);
		};
		def newObject := wrapAndPlaceMirror(someObject);
		newObject;
	};
	
	// copy an object to an isolate
	def objectToIsolate(someObject) {
		info("convert object to isolate: " + someObject);
		if: (is: someObject taggedAs: /.at.lang.types.Isolate) then: {
			raise: XAlreadyIsolate.new("argument is already an isolate: " + someObject);
		};
		def tags := (tagsOf: someObject).filter: {|e| e != /.at.lang.types.Isolate};
		def someIsolate := isolate: {} taggedAs: tags;
		def ir := reflect: someIsolate;
		def or := reflect: someObject;
		or.listFields.each: {|f|
			if: (f.name != `super) then: {
				ir.addField(f);
			};
		};
		or.listMethods.each: {|m|
			ir.addMethod(m);
		};
		someIsolate;
	};
	
	// Generic tag (empty or unrecognized)
	
	def GenericTag := object: {

		def tag := nil;
		
		def getSerial() { 
			tag.getSerial().toString();
		};

		def initialize(someObject) {
			if: !(is: someObject taggedAs: /.at.lang.types.Isolate) then: {
				raise: XNotAnIsolate.new("object must be isolate");
			};
			info("before convert isolate to object");
			info(someObject);
			def newObject := isolateToObject(someObject);
			updateMapping(tag, newObject);
			dump(tag, newObject);
			exportWithSerial(newObject, getSerial());
			newObject;
		};

		def init(atag) {
			tag := atag;
		};
	
	} taggedAs: [RFIDTag, GenericTag];
	
	
	// Different cases to handle RFID inventory
	
	// case 1: a tag that was already available
	//         - check if there is a disconnection object
	// !!! semantic subtlety: FIRST reconnect the object, THEN replace it
	def ackTag(serial, tag) {
		info("ack serial: " + serial);
		debug("  ack serial: " + serial);
		if: (discoTags.contains(serial)) then: {
			// if tag marked offline
			// take back online
			// update mark

			debug("  reconnect serial: " + serial);
			def disco := discoTags.get(serial);
			disco.reconnect();
			discoTags.remove(serial);
		} else: {
				debug("ignore 1");
		};
		def newObject := load(tag);
		if: (nil != newObject) then: {
			info("replacing object: " + tagToObject.get(serial) + " with: "+ newObject);
			//let: newObject become: tagToObject.get(serial);
			tagToObject.super := newObject; // XXX
			updateMapping(tag, newObject);
		};
	};
	
	// case 2: a new tag
	//         - export its proxy or a generic object
	def exportTag(serial, tag) {
		info("new serial: " + serial);
		debug("  new serial: " + serial);
		def tagObject := load(tag);
		if: (nil == tagObject) then: {
			// empty tag
			info("empty tag");
			tagObject := GenericTag.new(tag);
			//updateMapping(tag, tagObject);
			def wrapper := extend: tagObject with: {}; // XXX
			updateMapping(tag, wrapper); // XXX
			def s := serial;
			//export: tagObject as: RFIDTag with: { def serial := s };
			export: wrapper as: RFIDTag with: { def serial := s }; //XXX
		} else: {
			info("valid tag");
			//updateMapping(tag, tagObject);
			//exportWithSerial(tagObject, serial);
			def wrapper := extend: tagObject with: {}; // XXX
			updateMapping(tag, wrapper); // XXX
			exportWithSerial(wrapper, serial); // XXX
		};
	};
	
	// case 3: tag not seen with respect to previous poll
	//         - disconnect
	def unseeTag(serial, tag) {
		if: (!(discoTags.contains(serial))) then: {
			// take all unseen tags offline
	        info("  off serial: " + serial + " object: " + tagToObject.get(serial));
	        def discoTag := disconnect: tagToObject.get(serial);
	        discoTags.put(serial, discoTag);
		} else: {
		    debug("ignore 2");
		};
	};
	
	def inventory() {
		if: loop then: {
			debug("");
			debug("ROUND started");
			debug("avail tags: " + serialToTag.size());
			debug("disco tags: " + discoTags.size());
		
			def tags := Vector.new(device.inventory(true));
			debug("in range: " + tags.size());
			def unseen := serialToTag.clone();

			tags.each: { |tag|
				def serial := tag.getSerial().toString();
				unseen.remove(serial);
				if: (serialToTag.contains(serial)) then: {
					// case 1
					// seen before
					// check for possible disconnection object
					ackTag(serial, tag);
				} else: {
					// case 2
					// new tag
					// export!
					exportTag(serial, tag);
				};
			};
			debug("  unseen tags: " + unseen.size());
			unseen.each: {|serial, tag|
				// case 3:
				// disappearing tags
				unseeTag(serial, tag);
			};
			when: POLLING_INTERVAL elapsed: { self<-inventory() };
		};
	};
	
	def startLoop() {
		unless: loop then: {
			loop := true;
			inventory();
		};
	};
	
	def stopLoop() {
		loop := false;
	};
	
	
	// Create a facade with functions visible to the outside
	
	def createFacade() {
		if: (facade == nil) then: {
			facade := object: {
				def getAvailableTags() {
					serialToTag;
				};
		
				def getAvailableObjects() {
					tagToObject;
				};
			
				def getDiscoTags() {
					discoTags;
				};
			
				def displayEmAll() {
					tagToObject.printme();
					objectToTag.printme();
					serialToTag.printme();
				};
			
				def numTags() {
					serialToTag.size();
				};
		
				def numDiscoTags() {
					discoTags.size();
				};
			
				def numConnectedTags() {
					serialToTag.size() - discoTags.size();
				};
			
				def stop() {
					stopLoop();
				};
			
				def run() {
					startLoop();
				};
			}; // object
		};
		facade;
	};
	


	// initializer
	def init(devNum := 0) {
		device := JavaRFIDDevice.new(devNum);
		facade := createFacade();
	};
	
};

def RFIDServiceModule := object: {
	def createRFIDService(devNum := 0) {
		def service := RFIDService.new();
		service.facade;
	};
	
	def createAndRunRFIDService(devNum := 0) {
		def service := RFIDService.new();
		def facade := service.facade;
		facade.run();
		facade;
	};
};


