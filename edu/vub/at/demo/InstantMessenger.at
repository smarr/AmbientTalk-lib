/*
 * This program demonstrates an extremely simple peer-to-peer instant messenger
 * written in AmbientTalk/2. It demonstrates peer discovery and how to deal with
 * disconnections.
 *
 * @author tvcutsem
 */

import /.at.lang.leasedrefs;  

def IMListener := object: {
  def unknownBuddy(name) { system.println("Unknown buddy: " + to); };
  def printMessage(textMsg) {
    system.println(textMsg.from + ": " + textMsg.content);
  };
  def addBuddy(name) { system.println("Added buddy: " + name); };
  def buddyOffline(name) { system.println("Buddy offline: " + name); };
  def buddyOnline(name) { system.println("Buddy online: " + name); };
};

def createInstantMessenger(username := jlobby.java.lang.System.getProperty("user.name"),
                           listener := IMListener) {
  
  defstripe InstantMessenger;

  def TextMessage := isolate: {
    def from := nil;
    def content := nil;
    def init(f,c) {
      from := f;
      content := c;
    };
  };

  def buddyList := jlobby.java.util.HashMap.new();

  def localInterface := object: {
    def sendTextMessage(to, string) {
		  def buddy := buddyList.get(to);
		  if: (nil == buddy) then: {
			  listener<-unknownBuddy(to);
		  } else: {
		      def msg := TextMessage.new(username, string);
			  buddy<-receiveTextMessage(msg, 
				singleCallLease: seconds(30) for: ( object: {
				  def resolve() {
					  listener<-printMessage(msg);
				  }
			  }));
		 };
    };
  };

  def remoteInterface := object: {
    def receiveTextMessage(textMessage, future) {
      listener<-printMessage(textMessage);
      future<-resolve();
    };
    def getName(future) { future<-resolve(username) };
  };
  
  export: remoteInterface as: InstantMessenger;
  
  whenever: InstantMessenger discovered: { |messenger|
	  messenger<-getName( singleCallLease: seconds(30) for: ( object: {
		  def resolve(name) {
			  if: (nil == buddyList.get(name)) then: {
				  buddyList.put(name, messenger);
				  listener<-addBuddy(name);
				  when: messenger disconnected: {
					  listener<-buddyOffline(name);
				  };
				  when: messenger reconnected: {
					  listener<-buddyOnline(name);
				  };
			  };
		  };
	  }));
	};
	
	localInterface;
};

def InstantMessengerTest() {
 extend: /.at.unit.test.UnitTest.new("InstantMessenger test") with: {
  def test := self;
  
  def testAsyncMessageSend() {
    def [fut,res] := /.at.lang.futures.makeFuture();
    
    def A := createInstantMessenger("A", extend: IMListener with: {
      def addBuddy(name) {
        A<-sendTextMessage(name, "hello");
      };
      def printMessage(txt) {
        test.assertEquals("hello", txt.content);
        res.resolve(true); // only make test pass when message was successfully transmitted to B
      }
    });
    def Bact := actor: { def B := /.at.demo.InstantMessenger.createInstantMessenger("B") };
    
    fut;
  };
 }; 
};

self