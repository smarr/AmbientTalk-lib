/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The meta-level implementation of the ambient references language construct.
 * 
 * We distinguish between an ambient reference's 'base-level' behaviour
 * and its 'cardinality' and 'elasticity' behaviour, which are both mixed
 * into the base-level behaviour by means of trait composition.
 *
 * @author tvcutsem
 */

def FuturesModule := /.at.lang.futures;
def OneWayMessage := FuturesModule.OneWayMessage;
def Vector := /.at.collections.vector.Vector;
FuturesModule.enableFutures(false); // enable futures for explicitly tagged messages

def debug(@args) {
	system.println("[ambientrefs.at] ", @args);
};

/* The following code implements a simple sturdy unireference.
 * Sturdy unireferences can simply be implemented by combining
 * futures with the native far references: a future for a far
 * reference represents an unbound (dangling) far reference.
 * The far reference that resolves the future is a sturdy uni-
 * reference: it points to a single remote object, and does not
 * break the bond with its principal upon disconnection.
 */
def createSturdyUniRef(stripe) {
	def [arFuture, arResolver] := FuturesModule.makeFuture();
	
	when: stripe discovered: { |remoteRef|
		arResolver.resolve(remoteRef)
	};
	
	arFuture;
};


/* Architecture:
 *  An ambient reference is composed of a base behaviour and:
 *   - an elasticity trait, determining the beahviour upon disconnection
 *   - a cardinality trait, determining how many principals the reference can have
 *  The base behaviour hooks into the AmbientTalk/2 MOP to translate MOP events
 *  into more high-level, ambient reference-related events
 */

defstripe AmbientRef; // stripe of a base-level ambient reference
defstripe ARefMessage <: OneWayMessage; // stripe signifying that the message is destined for the AR itself

def makeAmbientRef(serviceType, TCardinality, TElasticity) {
	object: {
		nil // an ambient reference is an empty proxy object
	} stripedWith: [AmbientRef] mirroredBy: makeAmbientRefMirror(serviceType, TCardinality, TElasticity);
};

// create a new ambient reference mirror.
// assumes that TCardinality and TElasticity have been properly initialized already
def makeAmbientRefMirror(serviceType, TCardinality, TElasticity) {
	mirror: {
		
		// import cardinality and elasticity behaviour
	  import TCardinality;
	  import TElasticity;
		
		def inbox := Vector.new(); // to store messages sent to an unbound AR
	  def joinedbox := Vector.new(); // to store available matching objects
		
		def disconnectionObservers := Vector.new(); // to store when:disconnected: observers
	  def connectionObservers := Vector.new(); // to store when:connected: observers
		
		// register discovery observers
		whenever: serviceType discovered: { |potentialPrincipal|
			debug("Base: potential principal discovered: ", potentialPrincipal);
			joinedbox.add(potentialPrincipal);
			if: !(self.isBoundPrincipal(potentialPrincipal)) then: {
				// dispatch to cardinality mixin
				self.foundPrincipal(potentialPrincipal);
			};
			
			def sub := when: potentialPrincipal disconnected: {
				debug("Base: potential principal disconnected: ", potentialPrincipal);
				joinedbox.remove(potentialPrincipal);
				if: (self.isBoundPrincipal(potentialPrincipal)) then: {
					// dispatch to elasticity mixin
					self.disconnected(potentialPrincipal);
				};
				sub.cancel();
			};
		};
		
		/*def init(base) {
			super^init(base); // default constructor
			TCardinality^init(); // initialize state imported from cardinality trait
			TElasticity^init(); // initialize state imported from elasticity trait
			
			inbox := Vector.new();
			joinedbox := Vector.new();
			
			disconnectionObservers := Vector.new();
		  connectionObservers := Vector.new();
			
			// TODO: should have some way of initializing the state imported by traits!
			// e.g. principals for TCardinality
		};*/
	
	  // forward all messages in the inbox to the given principal
	  def flushInbox(toPrincipal) {
		  inbox.each: { |msg| toPrincipal <+ msg };
		  inbox.clear();
		  nil;
	  };
	
	  // return all untransmitted messages that were sent to principal
	  // back to the inbox
	  def retractOutbox(ofPrincipal) {
		  def out := (retract: ofPrincipal);
		  // add untransmitted messages to the front of the inbox
		  out.each: { |msg| inbox.insert(1,msg) };
		  nil;
	  };
	
	  // == observer management ==

	  def addDisconnectionObserver(obs) {
		  disconnectionObservers.add(obs);
		  // return a subscription object that can be used to remove the observer
		  object: {
			  def cancel() { disconnectionObservers.remove(obs) }
		  };
	  };
		def addConnectionObserver(obs) {
		  connectionObservers.add(obs);
		  // return a subscription object that can be used to remove the observer
		  object: {
			  def cancel() { connectionObservers.remove(obs) }
		  };
	  };
	
		def notifyObservers(observers, newPrincipal) {
			observers.each: { |o| o<-apply([newPrincipal])@OneWayMessage }
		};
	
		// == hook into the meta-object protocol ==
		
		// received messages are either processed by mirror itself or delegated to TCardinality
		def receive(msg) {
			if: (is: msg stripedWith: ARefMessage) then: {
				self <+ msg;
			} else: {
				self.acceptMessage(msg); // provided by cardinality trait
			}
		};
	
		// it is illegal to invoke methods synchronously on an ambient ref		
		def invoke(rcv, sel, arg) {
			// the only legal operation on ambient references is '=='
			if: (`(==) == sel) then: {
				super^invoke(rcv, sel, arg);
			} else: {
				raise: /.at.exceptions.XIllegalOperation.new("cannot synchronously invoke operation " + sel + " on ambient reference " + base);
			}
		};
		
		def print() {
			"<ambient "+serviceType+": "+self+">";
		};
		
		def clone() {
			makeAmbientRef(serviceType, TCardinality.new(), TElasticity.new());
		};
		
		// TODO: abstract boilerplate isolate/mirror code
		// TODO: ensure that an ambient ref has the same elasticity/cardinality at the remote end
		// does a passed AR remain bound to same principals?
		def pass() {
			object: { nil } stripedWith: [/.at.stripes.Isolate] mirroredBy: (
				extend: defaultMirror with: { |serviceType|
					def resolve() {
						// when arriving at the remote host, create a new local ambient reference
						/.at.lang.ambientrefs.ambient: serviceType
					};
				} stripedWith: [ /.at.stripes.Isolate ]);
		};
	};
};

defstripe XUnimplemented <: /.at.stripes.Exception;
def abstractMethod(name) {
	raise: /.at.exceptions.createException(XUnimplemented).new("Invoked abstract method: "+name);
};

def TAbstractCardinality := object: {
	def acceptMessage(msg) { abstractMethod(`acceptMessage) };
	def isBoundPrincipal(p) { abstractMethod(`isBoundPrincipal) };
	def foundPrincipal(p) { abstractMethod(`foundPrincipal) };
	def lostPrincipal(p) { abstractMethod(`lostPrincipal) };
};

def TAbstractElasticity := object: {
	def disconnected(p) { abstractMethod(`disconnected) };
};

def TUniRef := extend: TAbstractCardinality with: {
	// store the single far ref to which the AR can be bound
	// !! always access this variable using 'self' to access
	// the field that was 'imported' into the actual AR !!
	def self.principal := nil;
	
	// initialize this trait's state
	// note that the 'self' prefix is used to ensure that the correct imported state is modified
	def init() {
		super^init();
		self.principal := nil;
	};
	
	def acceptMessage(msg) {
		if: !(nil == self.principal) then: {
			self.principal <+ msg; // forward message to principal
		} else: {
			debug("Uniref: acceptmessage: unbound, storing ",msg.selector);
			self.inbox.add(msg);
			nil;
		};
	};
	def isBoundPrincipal(p) { self.principal == p };
	def foundPrincipal(p) {
		if: (nil == self.principal) then: {
			debug("Uniref: foundPrincipal: binding to ", p);
			self.principal := p;
			self.notifyObservers(self.connectionObservers, p);
			// flush stored messages
			self.flushInbox(p);
		} else: {
			debug("Uniref: foundPrincipal: already bound, ignoring ",p);
		};
		nil;
	};
	def lostPrincipal(p) {
		debug("Uniref: lostPrincipal: unbound due to loss of ",p);
		self.principal := nil;
		self.notifyObservers(self.disconnectionObservers, p);
		// retract all unsent messages back to the inbox
		self.retractOutbox(p);
	};
};

def TOmniRef := extend: TAbstractCardinality with: {
	// store a set of currently bound principals
	// !! always access this variable using 'self' to access
	// the field that was 'imported' into the actual AR !!
	def self.principals;
	
	// initialize this trait's state
	// note that the 'self' prefix is used to ensure that the correct imported state is modified
	def init() {
		super^init();
		self.principals := Vector.new();
	};
	
	def acceptMessage(msg) {
		// broadcast the message to all currently connected principals
		debug("Omniref: acceptMessage: broadcasting " + msg.selector + " to "+self.principals.length()+ " principals.");
		self.principals.each: { |p| p <+ msg };
		// TODO: sustained messages: place those in inbox here + register timeout
	};
	def isBoundPrincipal(p) { self.principals.contains(p) };
	def foundPrincipal(p) {
		debug("Omniref: foundPrincipal: adding ", p);
		self.principals.add(p);
		self.notifyObservers(self.connectionObservers, p);
		// TODO: add support for sustained and enduring messages
		// forward all messages in inbox to new principal here
		nil;
	};
	def lostPrincipal(p) {
		debug("Omniref: lostPrincipal: removing ",p);
		self.principals.remove(p);
		self.notifyObservers(self.disconnectionObservers, p);
		nil;
	};
};

def TBreakableRef := extend: TAbstractElasticity with: {
	def erase(principal) {
		// dispatch to cardinality trait
		self.lostPrincipal(principal);
		// try to rebind to spare candidate principals
		def idx := self.joinedbox.find: { |potentialP| !(self.isBoundPrincipal(potentialP)) };
		if: !(nil == idx) then: {
			// found a spare principal
			def newPrincipal := self.joinedbox.at(idx);
			debug("Breakableref: erase: found spare principal: ", newPrincipal);
			// dispatch to cardinality trait
			self.foundPrincipal(newPrincipal);
		};
	};
};

def TFragileRef := extend: TBreakableRef with: {
	def disconnected(principal) {
		debug("Fragileref: disconnected: signalling loss of ", principal);
		self.erase(principal);
	};
};

def TElasticRef := extend: TBreakableRef with: {
	def self.timeout;
	
	// if no timeout is given, reuse that of the clonee
	def init(t := self.timeout) {
		self.timeout := t;
	};
	
	def disconnected(principal) {
	  debug("ElasticRef: disconnected: starting timeout period for principal: ",principal);
	  def isDisconnected := true;
	  def sub := when: principal reconnected: {
		  isDisconnected := false;
		  sub.cancel();
	  };
	  when: self.timeout elapsed: { // TODO: implement when:elapsed:
		  if: isDisconnected then: {
			  debug("ElasticRef: disconnected: principal lost: ", principal);
			  self.erase(principal);
			  sub.cancel();
		  }; // if principal reconnected in time, ignore this disconnection
	  };
  };
};

def TSturdyRef := extend: TAbstractElasticity with: {
	def disconnected(principal) {
		debug("SturdyRef: disconnected: ignoring disconnection of ",principal);
		nil;
	};
};

def nativeWhen: farref disconnected: code {
	when: farref disconnected: code
};
def nativeWhen: farref reconnected: code {
	when: farref reconnected: code
};

def AmbientRefModule := object: {
	def ambient: serviceType {
		createSturdyUniRef(serviceType);
	};
	
	// cardinality traits
	def uni() { TUniRef.new() };
	def omni() { TOmniRef.new() };
	
	// elasticity traits
	def fragile() { TFragileRef.new() };
	def elastic(timeout) { TElasticRef.new(timeout) };
	def sturdy() { TSturdyRef.new() };
	
	def ambient: serviceType withCardinality: cTrait withElasticity: eTrait {
		makeAmbientRef(serviceType, cTrait, eTrait);
	};
	
	// if ambientRef is indeed an ambient reference, add an observer,
	// otherwise perform the default behaviour
	def when: ambientRef disconnected: code {
		if: (is: ambientRef stripedWith: AmbientRef) then: {
			(reflect: ambientRef).addDisconnectionObserver(code);
		} else: {
			nativeWhen: ambientRef disconnected: code
		};
	};
	
	// if ambientRef is indeed an ambient reference, add an observer,
	// otherwise perform the default behaviour
	def when: ambientRef reconnected: code {
		if: (is: ambientRef stripedWith: AmbientRef) then: {
			(reflect: ambientRef).addConnectionObserver(code);
		} else: {
			nativeWhen: ambientRef reconnected: code
		};
	};
	
	def AmbientRefsTest() {
	  extend: /.at.unit.test.UnitTest.new("AmbientRefTest") with: {
			defstripe Foo;
			def providerHost := actor: {
				defstripe Foo;
				def service := object: {
					def testMethod(x) { system.println("testMethod invoked with x = " + x); x+1 };
				};
				export: service as: Foo
			};
			
			/*def testFragileUni() {
				def a := ambient: Foo withCardinality: uni() withElasticity: fragile();
				a<-testMethod(5);
			};*/
			def testAsyncFragileOmni() {
				def a := ambient: Foo withCardinality: omni() withElasticity: fragile();
				FuturesModule.when: a<-testMethod(5)@FuturesModule.FutureMessage becomes: { |v|
					self.assertEquals(6,v);
				};
		    };
	  };
    };
};