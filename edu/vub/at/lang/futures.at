/* The meta-level implementation of the futures language construct */

// import Exception stripe, used for catching exceptions
def Exception := /.at.stripes.Exception;

// a future can be in one of these three states
def UNRESOLVED := 0;
def RESOLVED := 1;
def RUINED := 2;

// all future objects are marked with this stripe
defstripe Future;

// auxiliary function to check whether an object understands a message
def does: object understand: selector {
	(reflect: object).respondsTo(selector).base
};

// the mirror of a Future object
def FutureMirror := mirror: {
	// initialize the state of the prototype
	def state := UNRESOLVED;
	def resolvedValue := nil;
	def inbox := [];
	def subscribers := [];
	
	// constructor: used to initialize the state of the new future
	def init() {
		state := UNRESOLVED;
		resolvedValue := nil;
		inbox := [];
		subscribers := [];
	};
	
	def resolve(value) {
		// is the future resolved by another future?
		if: (is: value stripedWith: Future) then: {
			// register this future as a listener with the resolved future value
			// TODO: what if value is a far future?
			(reflect: value)<-addResolutionListener(object: {
				def notifyResolved(val) {
					// re-resolve this future with the actual value
					resolve(val);
				};
				def notifyRuined(exc) {
					// ruin this future
					ruin(exc);
				}
			});
		} else: {
			if: (state == UNRESOLVED) then: {
				state := RESOLVED;
				resolvedValue := value;
				inbox.each: { |msg| value <+ msg };
				inbox := [];
				subscribers.each: { |sub| sub<-notifyResolved(value) };
				subscribers := [];
			};	
		};
		value;
	};
	
	def ruin(exception) {
		if: (state == UNRESOLVED) then: {
			state := RUINED;
			resolvedValue := exception;
			inbox.each: { |msg|
				(does: msg understand: `future).ifTrue: {
					msg.future.ruin(exception);
				};
			};
			inbox := [];
			subscribers.each: { |sub| sub<-notifyRuined(exception) };
			subscribers := [];	
		};
		exception;
	};
	
	// adds a resolution listener to the future
	// @param sub a resolution listener
	def addResolutionListener(sub) {
		// if future has already been resolved/ruined, notify listener immediately
		if: (state == RESOLVED) then: {
			sub<-notifyResolved(resolvedValue);
		} else: {
			if: (state == RUINED) then: {
				sub<-notifyRuined(resolvedValue);
			} else: {
			  subscribers := subscribers + sub;	
			}
		};
	};
	
	// hook into the meta-object protocol by overriding meta_receive
	def receive(msg) {
		if: (state == RESOLVED) then: {
			  resolvedValue <+ msg;
		} else: {
			if: (state == RUINED) then: {
				(does: msg understand: `future).ifTrue: {
					msg.future.ruin(exception);
				};
			}	else: {
				// accumulate message in this future's inbox
				inbox := inbox + msg;
			};
		};
	};
	
	// it is illegal to invoke methods synchronously on a future
	def invoke(rcv, sel, arg) {
		// the only legal operation on futures is '=='
		if: (`(==) == sel) then: {
			super^invoke(rcv, sel, arg);
		} else: {
			// TODO: creating your own exceptions is not yet supported properly...
			raise: (object: { nil } stripedWith: [/.at.stripes.IllegalOperation]);
		}
	};
	
	def print() {
		if: (state == RESOLVED) then: {
			  "<resolved future:" + resolvedValue +">";
		} else: {
			if: (state == RUINED) then: {
				"<ruined future:" + resolvedValue +">";
			}	else: {
				"<unresolved future>";
			};
		};
	};
};

// futures are empty objects mirrored by a future mirror
def createFuture() {
	object: {
		nil
	} stripedWith: [ Future ] mirroredBy: FutureMirror.new();
};

// this object is returned when this file is loaded, hence
// it is the public interface to code defined in this file
def FuturesModule := object: {
	// support for first-class futures: returns a pair
	// [ future, resolver]. The resolver can be used to easily resolve
	// or ruin the corresponding future
	def makeFuture() {
		def fut := createFuture();
		[ fut, object: {
			def resolve(val) { (reflect: fut).resolve(val) };
			def ruin(exc) { (reflect: fut).ruin(exc) };
		}]
	};
	
	// when-catch support, version without a catch block
	def when: future becomes: resolvedBlock {
		when: future becomes: resolvedBlock catch: Exception using: { |e| nil }
	};

  // when-catch support, version with one generic catch-all block
	def when: future becomes: resolvedBlock catch: excBlock {
		when: future becomes: resolvedBlock catch: Exception using: excBlock
	};
	
	// when-catch support, version with one specific catch block
	def when: future becomes: resolvedBlock catch: excType using: excBlock {
		def [whenFuture,resolver] := makeFuture();
		def notify(block, val) {
			try: {
				resolver.resolve(block.apply([val]));
			} catch: Exception using: {|e|
				resolver.ruin(e);
			};
		};
		(reflect: future).addResolutionListener(object: {
			def notifyResolved(val) { notify(resolvedBlock, val) };
			def notifyRuined(exc) {
				if: (exc.isSubstripeOf(excType)) then: {
					notify(excBlock, exc);
				};
			};
		});
		whenFuture; // when returns a future itself
	};
	
	// install the futures protocol on the invoking actor,
	// returns the previously active protocol
	def enableFutures() {
		// the futures protocol by default extends the currently active protocol
		actor.install: (extend: actor with: {
			def createMessage(@args) {
				// perform default message creation behaviour
				def msg := super^createMessage(@args);
				
				// attach a future to the message
				def future := createFuture();
				extend: msg with: { |future|
					// cannot define the future here because 'createFuture' is no longer
					// visible, as this extension is an isolate!
					// def future := createFuture();
					
					// the process method is invoked when an async message arrives
				  def process(behaviour) {
						try: {
							// delegate to parent to actually invoke the method
							def result := super^process(behaviour);
							// if everything goes right, resolve the attached future
							(reflect: future)<-resolve(result);
							result;
						} catch: /.at.stripes.Exception using: { |e|
							// note that we needed to qualify the full path to the Exception stripe:
							// the Exception variable defined above is out of scope since this message is an isolate!
							(reflect: future)<-ruin(e); e;
						};
					};
			  };
			  // it is allowed, but not necessary to stripe the message extension, because
			  // objects are 'automatically' striped with their parent's stripes
			  //stripedWith: [ /.at.stripes.AsyncMessage ];
			};
			def send(msg) {
				super^send(msg);
				// return value now becomes the message's future rather than nil
				msg.future;
			};
		});
	};
};