/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* The meta-level implementation of the futures language construct */

// import Exception stripe, used for catching exceptions
def Exception := /.at.stripes.Exception;

// a future can be in one of these three states
def UNRESOLVED := 0;
def RESOLVED := 1;
def RUINED := 2;

// all future objects are marked with this stripe
defstripe Future;

// To register a when observer on a future, a message needs to be sent to its mirror
// This would only be possible if the mirror is accessible (i.e. for a local future)
// This restriction is avoided through the introduction of a FutureMessage stripe:
// Messages striped with it will be handled by the future's mirror rather than being
// forwarded when the result becomes available.
defstripe FutureMessage;

// auxiliary function to create an addResolutionListener message which should not be subject
// to the futures protocol itself
def addListenerMessage := let: {
	
	// create a message manually, before the futures protocol is activated.
	// actor.createMessage(sender, selector, [arguments], [stripes])
	def defaultListenerMessage := 
		actor.createMessage( nil, `addResolutionListener, [ `placeholderForActualListener ] , [ FutureMessage ] );
	
	{ | listener | 
		// create a new message
		def msg := clone: defaultListenerMessage;
		
		// replace the placeholder argument with the actual listener
		(msg.arguments)[1] := listener;
		msg;
	};
};

// auxiliary function to check whether an object understands a message
def does: object understand: selector {
	(reflect: object).respondsTo(selector)
};

// the mirror of a Future object
def FutureMirror := mirror: {
	// initialize the state of the prototype
	def state := UNRESOLVED;
	def resolvedValue := nil;
	def inbox := [];
	def subscribers := [];

	// constructor: used to initialize the state of the new future
	def init(@args) {
		super^init(@args); // initialize this future's base field
		state := UNRESOLVED;
		resolvedValue := nil;
		inbox := [];
		subscribers := [];
	};

	def resolve(value) {
		// is the future resolved by another future?
		if: (is: value stripedWith: Future) then: {
			// register this future as a listener with the resolved future value
			value <+ addListenerMessage(object: {
				def notifyResolved(val) {
					// re-resolve this future with the actual value
					resolve(val);
				};
				def notifyRuined(exc) {
					// ruin this future
					ruin(exc);
				}
			});
		} else: {
			if: (state == UNRESOLVED) then: {
				state := RESOLVED;
				resolvedValue := value;
				inbox.each: { |msg| value <+ msg };
				inbox := [];
				subscribers.each: { |sub| sub<-notifyResolved(value) };
				subscribers := [];
			};	
		};
		value;
	};

	def ruin(exception) {
		if: (state == UNRESOLVED) then: {
			state := RUINED;
			resolvedValue := exception;
			inbox.each: { |msg|
				(does: msg understand: `resolver).ifTrue: {
					msg.resolver<-ruin(exception);
				};
			};
			inbox := [];
			subscribers.each: { |sub| sub<-notifyRuined(exception) };
			subscribers := [];
		};
		exception;
	};

	// adds a resolution listener to the future
	// @param sub a resolution listener
	def addResolutionListener(sub) {
		// if future has already been resolved/ruined, notify listener immediately
		if: (state == RESOLVED) then: {
			sub<-notifyResolved(resolvedValue);
		} else: {
			if: (state == RUINED) then: {
				sub<-notifyRuined(resolvedValue);
			} else: {
			  subscribers := subscribers + [ sub ];	
			}
		};
	};

	// hook into the meta-object protocol by overriding meta_receive
	def receive(msg) {
		if: (is: msg stripedWith: FutureMessage) then: {
			self <+ msg;
		} else: {
			// msg received by a resolved future? forward the message
			if: (state == RESOLVED) then: {
				resolvedValue <+ msg;
			} else: {
				if: (state == RUINED) then: {
					(does: msg understand: `resolver).ifTrue: {
						msg.resolver<-ruin(exception);
					};
				}	else: {
					// accumulate message in this future's inbox
					inbox := inbox + [msg];
				};
			};
		};
	};

	// it is illegal to invoke methods synchronously on a future
	def invoke(rcv, sel, arg) {
		// the only legal operation on futures is '=='
		if: (`(==) == sel) then: {
			super^invoke(rcv, sel, arg);
		} else: {
			// TODO: creating your own exceptions is not yet supported properly...
			raise: (object: { nil } stripedWith: [/.at.stripes.IllegalOperation]);
		}
	};

	def print() {
		if: (state == RESOLVED) then: {
			  "<resolved future:" + resolvedValue +">";
		} else: {
			if: (state == RUINED) then: {
				"<ruined future:" + resolvedValue +">";
			}	else: {
				"<unresolved future>";
			};
		};
	};
};

// futures are empty objects mirrored by a future mirror
def createFuture() {
	object: {
		nil
		// note that the future mirror is implicitly instantiated for each new future!
	} stripedWith: [ Future ] mirroredBy: FutureMirror;
};

// this object is returned when this file is loaded, hence
// it is the public interface to code defined in this file
def FuturesModule := object: {
	// support for first-class futures: returns a pair
	// [ future, resolver]. The resolver can be used to easily resolve
	// or ruin the corresponding future
	def makeFuture() {
		def fut := createFuture();
		[ fut, object: {
			def resolve(val) { (reflect: fut).resolve(val) };
			def ruin(exc) { (reflect: fut).ruin(exc) };
			def future := fut;
		}]
	};

	// when-catch support, version without a catch block
	def when: future becomes: resolvedBlock {
		when: future becomes: resolvedBlock catch: Exception using: { |e| nil }
	};

  // when-catch support, version with one generic catch-all block
	def when: future becomes: resolvedBlock catch: excBlock {
		when: future becomes: resolvedBlock catch: Exception using: excBlock
	};

	// when-catch support, version with one specific catch block
	def when: future becomes: resolvedBlock catch: excType using: excBlock {
		def [whenFuture,resolver] := makeFuture();
		def notify(block, val) {
			try: {
				resolver.resolve(block(val));
			} catch: Exception using: {|e|
				resolver.ruin(e);
			};
		};
		future <+ (addListenerMessage(object: {
			def notifyResolved(val) { notify(resolvedBlock, val) };
			def notifyRuined(exc) {
				if: (is: exc stripedWith: excType) then: {
					notify(excBlock, exc);
				};
			};
		}));
		whenFuture; // when returns a future itself
	};

	// install the futures protocol on the invoking actor,
	// returns the previously active protocol
	def enableFutures() {
		// before installing changes to the creation of messages, create messages that will be used internally
		// to resolve or ruin the futures. If these messages are not created up front they will be subject to 
		// the futures protocol themselves, resulting in an endless cycle of messages if the receiver also has
		// futures enabled.
		def resolveMsg := <- resolve( `placeHolderForReturnValue  );
		def ruinMsg    := <- ruin( `placeHolderForRaisedException );

		// the futures protocol by default extends the currently active protocol
		actor.install: (extend: actor with: {
			def createMessage(@args) {
				// perform default message creation behaviour
				def msg := super^createMessage(@args);

				// attach the resolver for a future to the message
				def [future, resolver] := makeFuture();
				extend: msg with: { |resolver, resolveMsg, ruinMsg |

					// the process method is invoked when an async message arrives
				  def process(behaviour) {
						try: {
							// delegate to parent to actually invoke the method
							def result := super^process(behaviour);
							// if everything goes right, resolve the attached future
							// replace the placeholder symbol with the actual result
							(resolveMsg.arguments)[1] := result;

							// send the first-class message manually (possibly using the futures mixin)
							resolver <+ resolveMsg; // resolver<-resolve(result)

							result;
							
						// note that we needed to qualify the full path to the Exception stripe:
						// the Exception variable defined above is out of scope since this message is an isolate!
						} catch: /.at.stripes.Exception using: { |e|
							// note that we needed to qualify the full path to the Exception stripe:
							// the Exception variable defined above is out of scope since this message is an isolate!

							// replace the placeholder symbol with the actual exception
							(ruinMsg.arguments)[1] := e;

							// send the first-class message manually (possibly using the futures mixin)
							resolver <+ ruinMsg; // resolver<-ruin(e)
							
							// re-raise the caught exception
							raise: e;
						};
					};
			  };
			  // it is allowed, but not necessary to stripe the message extension, because
			  // objects are 'automatically' striped with their parent's stripes
			  //stripedWith: [ /.at.stripes.AsyncMessage ];
			};
			def send(msg) {
				def result := super^send(msg);
				// return value now becomes the message's future, if a resolver for it is attached to the message
				if: (does: msg understand: `resolver) then: {
					msg.resolver.future;
				} else: {
					result;
				}
			};
		});
	};
};