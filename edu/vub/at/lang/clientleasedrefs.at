def TimerModule := /.at.support.timer;
import TimerModule;
 
def maxMethod := jlobby.java.lang.Math.&max;
def Vector := /.at.collections.vector.Vector;

// TODO: Note that these definitions should have the same value as in the server leased references. 
// Either they are passed at mirror creation time or they are factored out to a config file.
// Actually renewalcall may be ommitted (if the default is the leasetime and 
// clients can not ask for a renewal without a timeout.
def RENEWALONCALL := millisec(10); // default call time renewal 
def LEASETIME := millisec(15); // default lease time
	
def createClientLeasingMirror(remoteLease, timeout) { mirror: {	

		def expired := false;
		def timerSubscription := nil;
		def expiredObservers := Vector.new();

		def init(base){
		  	super^init(base);
			expired := false;
			expiredObservers := Vector.new();			  	
			timerSubscription := when: timeout elapsed: {
				expired := true;
				notifyExpiredObservers();
		  	};
		    //add an observer to the remoteLease to be able to detect
		    //when a remote lease expires before the client one. 
			when: remoteLease takenOffline: {
				revoke();
				notifyExpiredObservers();
			}
	    };

		def revoke(){ 
			//if client wanna revoke the lease, this should be transmitted to server lease.
			timerSubscription.cancel();
			expired := true;
		};

		def renew(renewalTime := RENEWALONCALL) {
			//TODO: if client wanna explicitly renew the lease, the request should be forward to the server lease.
			//if ack hasn't come back in x minutes, renewal failed. 
			def interval := maxMethod(timerSubscription.getTimeRemaining(), renewalTime);
			timerSubscription.cancel();
			timerSubscription := when: interval elapsed: {
				expired := true;
				self.notifyExpiredObservers();
			};
		};

		def getTimeLeft() { timerSubscription.getTimeRemaining() };

		def addExpiredObserver(obs){
			expiredObservers.add(obs);
			//return a subscription object that can be used to remove the observer
			object: {
				def cancel() { expiredObservers.remove(obs) }
			};
		};

		def notifyExpiredObservers(){ expiredObservers.each: { |o| o<-apply([]) }};

		def receive(msg) {
			//all mesages received are forwarded to server lease. 
			//the base object of a leased ref is an empty object => it does not understand any async msg.
			if: !(expired) then: { 
				// clearing the receiver otherwise the client lease will be passed.
				msg.receiver := nil;
				remoteLease<-receive(msg);
			} else: { system.println("client:receive:expired")}
		};
		
		def invoke(rcv, sel, arg) {
			//the only legal operation on client leased references is '==' 
			if: (`(==) == sel) then: {
				super^invoke(rcv,sel,arg);
			} else: {
				raise: /.at.exceptions.XIllegalOperation.new("cannot synchronously invoke operation " +sel+ " on client leased reference "+ self.base);
			}
		};
		
		def print() {
			if: (expired) then: {
				"<expired client lease " + super^print()  + " on:" +remoteLease+ " >";
			} else: {
				"<client lease " + super^print() + " on: " +remoteLease+ ">";
			}
		}
}}; 

def createClientLeasingWithRenewalMirror(remoteLease, timeout, renewal) { extend: createClientLeasingMirror( remoteLease, timeout) with: {

	def receive(msg) {
		//all mesages received are forwarded to server lease. 
		//the base object of a leased ref is an empty object => it does not understand any async msg.
		if: !(self.expired) then: { 
			//ATENCIO: this renewal should not be transmitted to the server lease! 
			//Just renews the client lease to keep it in sync with the server lease.
			super^renew(renewal);
			// clearing the receiver otherwise the client lease will be passed.
			msg.receiver := nil;
			remoteLease<-receive(msg);
		} else: { system.println("client:receive:expired")}
	};
}};

def createLeasingWithSingleUseMirror(remoteLease, timeout, forSelectors) { extend: createClientLeasingMirror( remoteLease, timeout) with: {

	def receive(msg) {
		//all mesages received are forwarded to server lease. 
		//the base object of a leased ref is an empty object => it does not understand any async msg.
		if: !(self.expired) then: { 
			if: ( forSelectors.isEmpty().or: {forSelectors.contains(msg.selector)}) then: {
				super^revoke();
	  		} else: {
				//ATENCIO: this renewal should not be transmitted to the server lease! 
				//Just renews the client lease to keep it in sync with the server lease.
		 		super^renew();
			};
			// clearing the receiver otherwise the client lease will be passed.
			msg.receiver := nil;
			remoteLease<-receive(msg);
		} else: { system.println("client:receive:expired")}
	};
}};


self;