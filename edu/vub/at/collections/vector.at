/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

def DEFAULTCAPACITY := 10;
def IndexOutOfBounds := /.at.exceptions.IndexOutOfBoundsException;

object: {
	
	// the vector its current maximum capacity
	def capacity := DEFAULTCAPACITY;
	
  // the next free position in the vector
	def free := 1;
	
	// the vector its state represented as a table
	def elements[capacity] { nil };
	
	def init(@args) {
		// if argument given, change default capacity, otherwise use that of clonee
		if: (args != []) then: {
			capacity := args[1];
		};
		elements := (table: capacity fill: { |i| nil });
		free := 1
	};
	
	def grow() {
		def newelements[elements.length * 2] { nil };
		1.to: free do: { |i| newelements[i] := elements[i] };
		elements := newelements;
	};
	
	def growIfNecessary() {
		do: { grow() } if: self.atMaxCapacity();
	};
	
	def checkBounds(min, max, idx) {
		if: { idx < min }.or: { idx > max } then: {
			raise: IndexOutOfBounds.new(min, max, idx);
		}
	};
	
	// public interface
	
	def length() { free - 1 };
	def isEmpty() { free == 1 };
	def atMaxCapacity() { free > capacity };
	
	def at(idx) {
		checkBounds(1,free-1,idx);
		elements[idx];
	};
	
	def atPut(idx, val) {
		checkBounds(1,free-1,idx);
		elements[idx] := val;
	};

	def each: iterator {
		1.to: free do: { |i| iterator(elements[i]) };
		self
	};
	
	def map: fun {
		def cloned := clone: self;
		1.to: free do: { |i| cloned.atPut(i, fun(elements[i])) };
    cloned
	};
	
	def with: init collect: accum {
		def result := init;
		1.to: free do: { |i| result := accum(result, elements[i]) };
		result
	};
	
	def filter: cond {
		def newvec := self.new();
		self.each: { |v|
			do: { newvec.append(v) } if: cond(v);
		};
		newvec;
	};
	
	def contains: elt compareUsing: comparator {
		{ |return|
		  self.each: { |e| if: comparator(elt, e) then: { return(true) } };
		  false
		}.escape()
	};
	
	def contains(elt) {
		self.contains: elt compareUsing: { |e1,e2| e1 == e2 };
	};
	
	def implode() {
		elements.select(1,free).implode()
	};
	
	def join(txt) {
		elements.select(1,free).join(txt)
	};

  def select(start, stop) {
	  elements.select(start, stop)
  };

  def append(element) {
	  self.growIfNecessary();
		elements[free] := element;
		free := free + 1;
		self
  };

  def <<(element) { self.append(element) };
  
  def insert(atPos, element) {
	  checkBounds(1,free,atPos);
		self.growIfNecessary();
		free.to: atPos do: {|i|
			elements[i] := elements[i-1]
		};
		elements[atPos] := element;
		free := free+1;
		self
  };

  def push(element) { insert(1, element) };

  def delete(atPos) {
	  checkBounds(1,free-1,atPos);
		def tmp := elements[atPos];
		atPos.to: free do: { |i|
			elements[i] := elements[i+1]
		};
		free := free - 1;
		tmp
  };

  def pop(element) { delete(1, element) };
	
	def indexOf(elt) {
		def idx := 1;
		{ |return|
			while: { idx < free } do: {
			  if: (elt == elements[idx]) then: {
				  return(idx);
			  } else: {
				  idx := idx + 1;
			  };
		  };
		  0; // if not found, return 0
		}.escape()
	};
	
	def remove(elt) {
		def idx := indexOf(elt);
		if: (idx > 0) then: {
			self.delete(idx);
		}
	};
	
	def ++(otherVector) {
		def collated := clone: self;
		otherVector.each: { |elt| collated.append(elt) };
	};
	
	def union(otherVector) {
		def theUnion := clone: self;
		otherVector.each: { |elt|
			do: { theUnion.append(elt) } unless: self.contains(elt);
		};
		theUnion;
	};
	
	def +(otherVector) { self.union(otherVector) };
	
	def intersection(otherVector) {
		def theIntersection := self.new();
		self.each: { |elt|
		  do: { theIntersection.append(elt) } if: (otherVector.contains(elt));
		};
	};
	
	def *(otherVector) { self.intersection(otherVector) };
	
	def difference(otherVector) {
		def theDifference := clone: self;
		self.each: { |elt|
			do: { theDifference.remove(elt) } if: otherVector.contains(elt);
		};
	};
	
	def sortUsing: comparator {
		
		def quickSort(table, low, high) {
	    def left := low;
	    def right := high;
	    def pivot := table[(left+right) /- 2];
	    def save := nil;
	    while: { left <= right } do: {
		    while: { comparator(table[left], pivot) } do: left.inc;
		    while: { comparator(pivot, table[right]) } do: right.dec;
		    if: (left <= right) then: {
			    save := table[left];
					table[left] := table[right];
					table[right] := save;
					left.inc();
					right.dec();
		    };
	   };
	   if: (low<right) then: { quickSort(table,low,right) };
	   if: (high>left) then: { quickSort(table,left,high) };
	  };

	  quickSort(elements, 1, free - 1);
	  self;	
	};
	
	def sort() {
		self.sortUsing: { |e1,e2| e1 < e2 };
	};
	
}