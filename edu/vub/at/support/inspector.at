def awt		:= jlobby.java.awt;
def swing	:= jlobby.javax.swing;

def InspectorTemplate := object: {
	
	// This is the dialog this AmbientTalk object embodies/manipulates
	def thisDialog;
	
	// These values are modified by the methods of this object and therefore
	// are defined as instance variables rather than as private variables of
	// the init method which sets up all contained components.
	def printedForm;	// (reflect: value).print()
	def traceList;  	// a list of previously inspected values
	
	def init(customForm) {
			thisDialog 		:= swing.JDialog.new();
		
		def inspectButton	:= swing.JButton.new();
		def diveButton 		:= swing.JButton.new();
		def exitButton		:= swing.JButton.new();
		
		def inspectorTabs	:= swing.JTabbedPane.new();
		def currentPanel	:= swing.JPanel.new();
		def tracePanel		:= swing.JPanel.new();
		
		def curLabel		:= swing.JLabel.new();
			printedForm		:= swing.JTextField.new();
		
		def traceScroll		:= swing.JScrollPane.new();
			traceList		:= swing.JList.new();
		
		// Dialog Layout	
		def contentPane		:= thisDialog.getContentPane();
		def layout			:= awt.GridBagLayout.new();
		layout.columnWidths	:= [120, 120, 155, 0];
		contentPane.setLayout(layout);
		
		// Inspect Button
		inspectButton.setText("Inspect");
		contentPane.add(inspectButton, 
			awt.GridBagConstraints.new(
				0, 0, 1, 1, 0.0, 0.0, awt.GridBagConstraints.CENTER, 
				awt.GridBagConstraints.BOTH, awt.Insets.new(0, 0, 5, 5), 0, 0));
		
		// Dive Button
		diveButton.setText("Dive");
		contentPane.add(diveButton, 
			awt.GridBagConstraints.new(
				1, 0, 1, 1, 0.0, 0.0, awt.GridBagConstraints.CENTER, 
				awt.GridBagConstraints.BOTH, awt.Insets.new(0, 0, 5, 5), 0, 0));
		
		// Exit Button
		exitButton.setText("Exit");
		contentPane.add(exitButton, 
			awt.GridBagConstraints.new(
				2, 0, 1, 1, 0.0, 0.0, awt.GridBagConstraints.CENTER, 
				awt.GridBagConstraints.BOTH, awt.Insets.new(0, 0, 5, 5), 0, 0));
				
		// Current Panel
		def currentLayout 			:= awt.GridBagLayout.new();
		currentLayout.columnWidths	:= [0, 295, 0];
		currentLayout.rowHeights	:= [0, 172, 0];
		currentPanel.setLayout(currentLayout);
		
		// Current Label
		curLabel.setText("Inspecting: ");
		currentPanel.add(curLabel,
			awt.GridBagConstraints.new(
				0, 0, 1, 1, 0.0, 0.0, awt.GridBagConstraints.CENTER, 
				awt.GridBagConstraints.BOTH, awt.Insets.new(0, 0, 5, 5), 0, 0));
		
		// Printed Form of the inspected value
		printedForm.setEditable(false);
		currentPanel.add(printedForm,
			awt.GridBagConstraints.new(
				1, 0, 1, 1, 0.0, 0.0, awt.GridBagConstraints.CENTER, 
				awt.GridBagConstraints.BOTH, awt.Insets.new(0, 0, 5, 0), 0, 0));
				
		// Custom representation
		currentPanel.add(customForm,
			awt.GridBagConstraints.new(
				0, 1, 2, 1, 0.0, 0.0, awt.GridBagConstraints.CENTER, 
				awt.GridBagConstraints.BOTH, awt.Insets.new(0, 0, 0, 0), 0, 0));
				
		// Trace Panel
		def traceLayout				:= swing.BoxLayout.new(tracePanel, swing.BoxLayout.X_AXIS);
		tracePanel.setLayout(traceLayout);
		
		// Trace List
		traceList.setSelectionMode(swing.ListSelectionModel.SINGLE_SELECTION);
		traceScroll.setViewportView(traceList);
		tracePanel.add(traceScroll);
		
		// Inspector Tabs
		inspectorTabs.addTab("Current", currentPanel);
		inspectorTabs.addTab("Trace", tracePanel);
		contentPane.add(inspectorTabs,
			awt.GridBagConstraints.new(
				0, 1, 3, 2, 0.0, 0.0, awt.GridBagConstraints.CENTER, 
				awt.GridBagConstraints.BOTH, awt.Insets.new(0, 0, 0, 0), 0, 0));
		
		thisDialog.pack();		
	};
	
	def show() {
		thisDialog.setVisible(true);
	};
	
	def hide() {
		thisDialog.setVisible(false);
	};
	
	def inspect(value) {
		printedForm.setText((reflect: value).print());
	};
};

def DefaultInspector := extend: InspectorTemplate with: {
	
	def listForm;
	
	def init() {
		def scrollPane		:= swing.JScrollPane.new();
			listForm 		:= swing.JList.new();
		
		listForm.setSelectionMode(swing.ListSelectionModel.SINGLE_SELECTION);	
		scrollPane.setViewportView(listForm);
		
		super^init(scrollPane);
	};
	
	def inspect(value) {
		super^inspect(value);
		
 		try: {
			def valueMirror 	:= (reflect: value);
			def methods 		:= valueMirror.listMethods();
			def fields 			:= valueMirror.listFields();

			def listContents 	:= jlobby.java.util.Vector.new();

			fields.each: { | field | 
				// Manually wrap in a Java String to avoid the printing of double quotes
				listContents.add( jlobby.java.lang.String.new("" + field.name + " := " + field.readField()) )
			};
			methods.each: { | method | 
				// Manually wrap in a Java String to avoid the printing of double quotes
				listContents.add( jlobby.java.lang.String.new("" + method.name + "(" + method.parameters + ")"))
			};

			listForm.setListData(listContents); 

		} catch: /.at.stripes.Exception using: { | e |
			swing.JOptionPane.showMessageDialog(
				super.thisDialog,
				"Could not inspect "+value,
				"AmbientTalk Object Inspector",
				swing.JOptionPane.INFORMATION_MESSAGE);
		};
	}
};

def GrammarInspector := extend: InspectorTemplate with: {
	
	def textForm;
	
	def init() {
		def scrollPane		:= swing.JScrollPane.new();
			textForm 		:= swing.JTextArea.new();
		
		scrollPane.setViewportView(textForm);
		
		super^init(scrollPane);
	};
	
	def inspect(value) {
		super.printedForm.setText("An Abstract Grammar Element");
		
 		textForm.setText((reflect: value).print());
	}
};

// The inspectorMap maps Stripes to inspector objects. Whenever an object is to be inspected,
// the map is consulted to see whether it requires a dedicated inspector. Otherwise the default
// inspector is used. When an object bears multiple stripes their order defines the precedence.
def inspectorMap := jlobby.java.util.HashMap.new();

def inspector := object: {
	
	// Objects with this stripe will be inspected using the correct inspector.
	def inspect: stripe using: inspector {
		inspectorMap.put(stripe, inspector);
	};
	
	// Inspect an AmbientTalk value, using the correct inspector based on its stripes
	def inspectOn: value {
		// Determine the stripes of the value
		def stripes 	:= stripesOf: value;
		
		// Try to find a custom inspector for objects with that stripe. Precedence is 
		// based on the order of the stripes (if the first stripe is bound to a custom
		// inspector, subsequent stripes are ignored, using the escpe construct)
		def inspector	:= 
			{ | return | 
				stripes.each: { | stripe |
					def customInspector := inspectorMap.get(stripe);
					if: !(customInspector == nil) then: {
						system.println(customInspector);
						return(customInspector.new());
					};
				};
			
				// If no custom inspector could be found, use the default inspector.
				return(DefaultInspector.new());
			}.escape(); 

		inspector.inspect(value);
		inspector.show();
	};
};

inspector.inspect: /.at.stripes.AbstractGrammar using: GrammarInspector;

inspector;

// def testObject := object: { nil } stripedWith: [ /.at.stripes.AbstractGrammar ];
// inspector.inspectOn: testObject;
