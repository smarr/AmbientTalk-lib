/* The following definitions represent top-level functions that are
   implemented natively in the interpreter. They can be uncommented
   to shadow their native equivalent.

def / := lobby;

def root := self;

def if: booleanCondition then: consequent {
  booleanCondition.ifTrue: consequent
};

def if: booleanCondition then: consequent else: alternative {
  booleanCondition.ifTrue: consequent ifFalse: alternative
};

def while: cond do: body {
  cond.whileTrue: body
};

def foreach: iterator in: table {
  table.each: iterator
};

def do: body if: cond {
  cond.ifTrue: body
};

def do: body unless: cond {
  cond.ifFalse: body
};

def extend: obj with: code {
  (reflect: obj).extend(code)
};

def share: obj with: code {
  (reflect: obj).share(code)
};

def clone: obj {
  (reflect: obj).clone()
};

def !(b) { b.not() };

def -(n) { 0-n };

def +(n) { 0+n };

*/

// example: table: 5 fill: { |i| i } => [1,2,3,4,5]
def table: size fill: closure {
  def t[size] { nil };
  1.to: size+1 do: { |i| t[i] := closure(i) };
  t
};

/*def functor: closure {
  def obj := object: closure;
  eval: `({ // TODO: this evaluates a closure definition within obj, which does nothing...
    // base-level interface for closures
    def apply(args) { self.run(@args) };
    def whileTrue: body { self.run.whileTrue: body };
    def getMethod() { (reflect: self.run).method };
    def getContext() { (reflect: self.run).context };
  }) in: obj;
  obj;
};*/

def functor: closure {
  def functorPrototype := object: {
    // to be overridden by children
    def run(@args) { nil };
    // base-level interface for closures
    def apply(args) { self.run(@args) };
    def whileTrue: body { self.run.whileTrue: body };
    def getMethod() { (reflect: self.run).method };
    def getContext() { (reflect: self.run).context };    
  };
  extend: functorPrototype with: closure;
};