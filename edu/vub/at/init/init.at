/* The following definitions represent top-level functions that are
   implemented natively in the interpreter. They can be uncommented
   to shadow their native equivalent.

def / := lobby;

def root := self;

def if: booleanCondition then: consequent {
  booleanCondition.ifTrue: consequent
}

def if: booleanCondition then: consequent else: alternative {
  booleanCondition.ifTrue: consequent ifFalse: alternative
}

def while: cond do: body {
  cond.whileTrue: body
}

def foreach: iterator in: table {
  table.each: iterator
}

def do: body if: cond {
  cond.ifTrue: body
}

def do: body unless: cond {
  cond.ifFalse: body
}

def extend: obj with: code {
  (reflect: obj).extend(code)
}

def share: obj with: code {
  (reflect: obj).share(code)
}

def clone: obj {
  (reflect: obj).clone()
}

def !(b) { b.not() }

def -(n) { 0-n }

def +(n) { 0+n }

*/

def table(size) {
  def t[size] { nil };
  t
};

def functor: closure {
  def obj := object: closure;
  eval: `{ // TODO: this evaluates a closure definition within obj, which does nothing...
    // base-level interface for closures
    def apply(args) { self.run(@args) };
    def whileTrue: body { self.run.whileTrue: body };
    def getMethod() { (reflect: self.run).getMethod() };
    def getContext() { (reflect: self.run).getContext() };
  } in: obj;
  obj;
  /* def obj.apply(args) {
    self.run(@args)
  } */
  //(reflect: obj).addMethod(methodP.new(`apply, `[args], `{ self.run(args); }))
}