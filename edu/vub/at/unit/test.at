/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


/*
 * Defines unit test code for performing unit tests in AT/2 itself
 */
defstripe AssertionFailed <: /.at.stripes.Exception;
def XAssertionFailed := /.at.exceptions.createException(AssertionFailed);

def FuturesModule := /.at.lang.futures;
FuturesModule.enableFutures(false); // only enable explicit futures

def assert(bln, reason) {
	bln.ifFalse: { raise: XAssertionFailed.new(reason) }
};

def retrieveTestMethodNames(obj) {
	def methodNames := [];
	while: { !(nil == obj) } do: {
		def localTestMethods := ((reflect: obj).listMethods().filter: { |mth| mth.name.text ~= "test.*" });
		methodNames := methodNames + (localTestMethods.map: { |mth| mth.name });
		obj := obj.super;
	};
	methodNames;
};

def consoleReporter := object: {
	def numSuccess := 0;
	def numFailed := 0;
	def numError := 0;
	def init() {
		numSuccess := 0;
		numFailed := 0;
		numError := 0;
	};
	def start(testName, numTests) {
		system.println("Starting unit test " + testName + "("+numTests+" tests)");
	};
	def success(methName) {
		numSuccess := numSuccess + 1;
		system.println("Test " + methName + " ok");
	};
	def failure(methName, assertionFailedExc) {
		numFailed := numFailed + 1;
		system.println("Test " + methName + " failed (reason = "+assertionFailedExc.message+")");
	};
	def error(methName, exc) {
		numError := numError + 1;
		system.println("Error in test " + methName + ": "+exc);
		system.println(exc.message);
		system.println(exc.stackTrace);
	};
	def stop(testName) {
		system.println("Unit test " + testName + " done. Success: " + numSuccess + " Failed: " + numFailed + " Error: " + numError);
	};
};

// unit tests should delegate to this object
def UnitTest := object: {
  def name := "Unnamed";

  def init(newname) {
	  name := newname;
  };

	// methods to assert the validity of programs
	def assertTrue(bln, reason := "expected true, given false") { assert(bln, reason) };
	def assertFalse(bln, reason := "expected false, given true") { assert(!bln, reason) };
	def assertEquals(o1,o2, reason := "expected "+o1+" to be equal to "+o2) { assert(o1==o2, reason) };
	def assertNotEquals(o1,o2, reason := "expected "+o1+" not to be equal to "+o2) { assert(!(o1==o2), reason) };
	def assertLessThan(o1,o2, reason := "expected "+o1+" to be less than "+o2) { assert(o1<o2, reason) };
	def assertGreaterThan(o1,o2, reason := "expected "+o1+" to be greater than "+o2) { assert(o1>o2, reason) };
	def assertLessThanOrEquals(o1,o2, reason := "expected "+o1+" to be <= than "+o2) { assert(o1<=o2, reason) };
	def assertGreaterThanOrEquals(o1,o2, reason := "expected "+o1+" to be >= than "+o2) { assert(o1>=o2, reason) };
	def assertMatches(str, pattern, reason := "expected "+str+" to match "+pattern) { assert(str ~= pattern, reason) };
	def assert: excType raisedIn: code {
		{ |return|
			try: code
		  catch: excType using: { |e|
			  return("ok");
		  };
		  raise: XAssertionFailed.new("Expected exception " + excType + " was not raised");
		}.escape();
	};
	
	def setUp() { nil };
	def tearDown() { nil };
	
	def runTest(reporter := consoleReporter.new()) {
		def numAsyncTests := 0; // count number of outstanding async unit tests
		
		def asyncTestFinished() {
			self.tearDown();
			numAsyncTests := numAsyncTests - 1;
			// last async test fininshed?
			if: (0 == numAsyncTests) then: {
				reporter.stop(self.name);
			};
		};
		
		def testMethods := retrieveTestMethodNames(self);
		
		reporter.start(self.name, testMethods.length);
		
		testMethods.each: { |methName|
			if: (methName.text ~= "testAsync.*") then: {
				// asynchronous unit test
				numAsyncTests := numAsyncTests + 1;
				self.setUp();
				def fut := (reflect: self).select(self, methName).apply([]);
				FuturesModule.when: fut becomes: { |val|
					reporter.success(methName);
					asyncTestFinished();
				} catch: { |e|
					if: (is: e stripedWith: AssertionFailed) then: {
						reporter.failure(methName, e);
					} else: {
						reporter.error(methName, e);
					};
					asyncTestFinished();
				};
				nil;
			} else: {
				// synchronous unit test
				try: {
					self.setUp();
					(reflect: self).select(self, methName).apply([]);
					self.tearDown();
					reporter.success(methName);
				} catch: AssertionFailed using: {|e|
					reporter.failure(methName, e);
				} catch: /.at.stripes.Exception using: { |e|
					reporter.error(methName, e);
				};
			}
		};
		// only stop if there are no outstanding async unit tests
		if: (0 == numAsyncTests) then: {
			reporter.stop(self.name);
		};
	};
};

def TestModule := object: {
	def UnitTest := UnitTest;
	
	def ConsoleReporter := consoleReporter;
	
	def testIt() {
		// a unit test to test the unit test
		def weekDayTest := extend: UnitTest.new("WeekDayTest") with: {
		  def dow := ["mo","tue","wed","thu","fri","sat","sun"];

		  def testEquals() { self.assertEquals(7, dow.length) };
		  def testTrue() { self.assertTrue(dow[1]==dow[1]) };
		  def testFalse() { self.assertFalse(dow[2]==dow[3]) };
		  def testNotEquals() { self.assertNotEquals(dow[2],dow[3]) };
		  def testLessThan() { self.assertLessThan(dow[1].explode().length, dow[2].explode().length) };
		  def testException() { self.assert: /.at.stripes.IndexOutOfBounds raisedIn: { dow[8] } };
      def testAsyncSend() {
	      FuturesModule.when: dow<-at(1)@FuturesModule.FutureMessage becomes: { |v|
		      self.assertEquals("mo", v);
		    };
      };

		  def testError() { self.assertEquals("sun", dow[8]) }; // raises index out of bounds -> error
		  def testFailure() { self.assertNotEquals(dow[2], dow[2]) }; // test correct handling of failure
		};

		// expecting  6 success, 1 failure and 1 error
		def unittesttester := object: {
			def succ := 0; def fail := 0; def err := 0;
			def start(@args) { nil };
			def success(@args) { succ := succ + 1 };
			def failure(@args) { fail := fail + 1 };
			def error(@args) { err := err + 1 };
			def stop(@args) {
				if: !((succ == 7) & (fail == 1) & (err == 1)) then: {
					system.println("Unit Test self-checking test failed!");
				} else: {
					system.println("Unit test module ok");
				}
			};
		};
		weekDayTest.runTest(unittesttester);	
	}
}