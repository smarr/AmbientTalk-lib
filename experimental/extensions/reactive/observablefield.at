import /.at.lang.values;
import /.at.lang.types;
import /.experimental.extensions.reactive.types;
import /.experimental.extensions.reactive.observable;

import /.at.collections.vector;

def atomicBlocksStack := Vector.new();

def atomicBlock := object: {
	def bundledAssignments := [];
	def storeAssignment(ass) {
		bundledAssignments := bundledAssignments + [ ass ];
	};
	def processAssignments() {
		bundledAssignments.each: { |ass| ass(); };
	};
};

def inAtomicBlock() {
	!atomicBlocksStack.isEmpty();
};

def currentAtomicBlock() {
	atomicBlocksStack.at(atomicBlocksStack.length);
};

def newAtomicBlock() {
	atomicBlocksStack.push(atomicBlock.new());
};

def popAtomicBlock() {
	atomicBlocksStack.pop().processAssignments();
};


def ObservableFieldModule := object: {

	def atomic: closure {
		newAtomicBlock();
		def result := closure();
		popAtomicBlock();
		result;
	};

    def createObservableField(nam, val) {
    	object: { 
    		import ObservableTrait;
    		self.addObserverCatalogs(`writes);
    		def new(newHost) { self }; // singleton pattern
    		def name() { nam };
    		def nam_ := /.at.support.util.makeMutator(nam);
    		
    		// if a reactive object is assigned to a field
    		// register an observer on that field that triggers our observers
    		// i.e. if a reactive field assigned to a field is changed, we consider ourselves to be changed too
    		def callback_ := nil;
    		// the callback to the observer
    		if: (is: val taggedAs: ReactiveObject) then: {
    		    // register observer if necessary
    	        callback_ := (reflect: val).register: { |fld, fval|
    	            self.notify: self.observerCatalog.writes withArgs: [val];
    	        };
    	    };
    		
    		def readField() { val };
    		def writeField(newVal) {
    			def writeOperation := {
    		    	if: (is: val taggedAs: ReactiveField) then: {
    		       		val.setValue(newVal);
    		   	 	} else: {
    		        	if: (callback_ != nil) then: {
    		          		// cancel previous observer if there was one
    	               	 	callback_.cancel();
    	           	 	};
    		       	 if: (is: newVal taggedAs: ReactiveObject) then: {
    		         	// register observer if necessary
    		           	callback_ := (reflect: newVal).register: { |fld, val|
    		            	self.notify: self.observerCatalog.writes withArgs: [newVal];
    		           	};
    		      	 };
    		        // set new value and notify observers
    			   	val := newVal; 
    			    self.notify: self.observerCatalog.writes withArgs: [newVal];
    			};
    			val;
    			};
    			if: inAtomicBlock() then: {
    				currentAtomicBlock.storeAssignment(writeOperation); 
    			} else: {
    				writeOperation();
    			};
    			val;
    		};
    		def accMethod := createClosureMethod(self, createMethod(nam, [], `{ readField() }, []));
    		def mutMethod := createClosureMethod(self, createMethod(nam_, [ `v ], `{ writeField(v) }, []));
    		def accessor() { accMethod };
    		def mutator() { mutMethod };
    	} taggedAs: [Field];
    };
    
};

ObservableFieldModule;
