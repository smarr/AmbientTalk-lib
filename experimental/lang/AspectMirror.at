deftype Service;
def MetaMessage := /.at.lang.firstclassrefs.MetaMessage;
def filterMirror := /.at.lang.filterMirror;
def XSelectorNotFound := /.at.lang.exceptions.XSelectorNotFound;
def witnessSet := /.experimental.collections.witnessSet;

import /.at.lang.futures;
enableFutures(false);

deftype Modifiable;
deftype Public;
deftype Private;
def theResolvedFuture := future: {|resolve| resolve(nil) };

def ExclusiveMethodAnnotation(conflicts,Type) {
	extend: Type with: { 
		def annotateMethod(method) {
			def index := method.annotations().find: {|a| conflicts.contains(a); };
			if: (nil != index) then: {
				raise: jlobby.edu.vub.at.exceptions.XIllegalOperation.new("Conflicting type found: " +method.annotations()[index]+ " for type "+ Type );
			};	
			method;		
		};
	} taggedAs: [/.at.lang.types.Isolate, /.at.lang.types.TypeTag, Type];
};

Private := ExclusiveMethodAnnotation([Public,Modifiable],Private);
Public  := ExclusiveMethodAnnotation([Private,Modifiable],Public);
Modifiable := ExclusiveMethodAnnotation([Private,Public],Modifiable);

def makeAspectMirror(base) { 
	extend: defaultMirror.new(base) with: {
		def aspectBeforeSet := witnessSet.new();
		def aspectAfterSet  := witnessSet.new();
		
		def afterCallBack(joinpoint, advice, caller) {
		 	install(joinpoint, advice, caller, [Public, Modifiable],aspectAfterSet); 
		};
		
		def afterCall(methodName, advice, caller) {
			install(joinpoint, advice, caller, [Modifiable],aspectAfterSet); 
		}; 
		
		def beforeCallBack(joinpoint, advice, caller) {
		 	install(joinpoint, advice, caller, [Public, Modifiable],aspectBeforeSet); 
		};
		
		def beforeCall(methodName, advice, caller) {
			install(joinpoint, advice, caller, [Modifiable],aspectBeforeSet); 
		}; 
			
		def install(joinpoint, advice, caller, types,set) {
			def mirror := self;
			def aspect := object: { 
				def apply(delegate, invocation) {						
					def method := mirror.grabMethod(invocation.selector);
					if: (nil != method.annotations().find: {|a| types.contains(a); }) then: {
						if: joinpoint(invocation.selector.text,invocation.arguments) then: {
							advice<-notify(invocation.selector.text,invocation.arguments)@FutureMessage;
						};
					};
				};
			};
			set.addRebind(aspect,caller);
		};
		
		def invokeField(slf, sel) { self.invoke(slf, `(.#sel())) };
		
		
		def invoke(delegate, invocation) {
			system.println("invoke");
			if: ([`==, `print ].contains(invocation.selector) ) then: {
					super^invoke(delegate, invocation);
			} else: {
				when: (group: ([theResolvedFuture]+ aspectBeforeSet.map: { |aspect| aspect.apply(delegate,invocation); })) becomes: { |Idc| 	
					def return := super^invoke(delegate, invocation);
					aspectAfterSet.each: { |aspect|
						aspect.apply(delegate,invocation);
					};
					return;
				};
			};
		};

		//default behaviour to intercept meta-level messages.
		def metaIntercept(msg) {
			// have to go meta-meta because we need to know whether the
			// *mirror* itself can respond to the selector
			if: ((reflect: self).respondsTo(msg.selector)) then: {
				self <+ msg; // process meta-message myself
			} else: {
				super.receive(msg);//TODO ERROR !!!
			}
		};
		
		def receive(msg) {
			if: (is: msg taggedAs: MetaMessage) then: {
				self.metaIntercept(msg); 
		  } else: {
			  	super^receive(msg);
		  }
		};
	};	
};

def service: block {
	  object: block taggedAs: [Service] mirroredBy: { |base| makeAspectMirror(base) };
};

def Television :=  service: {
	def location := "Living Room";	
	//Annotate
	def setPause()@[Public] {
		system.println("Set pause");
		42;
	}
};

export: Television as: Service;
	 
def jos := actor: {
	def MetaMessage := /.at.lang.firstclassrefs.MetaMessage;
	import /.at.lang.futures;
	enableFutures(false);
	def publication;
	
	def advice := object:{
		def notify(methodName,arguments) {
			system.println("notified");
		};
	};
	
	def reconnect() {
		publication.reconnect();
	};
	
	when: Service discovered: { |s|
		when: s<-beforeCallBack( script:{|methodName,arguments| methodName~="set.*" },advice,advice)@[MetaMessage,FutureMessage] becomes: { |f|
			when: Television<-setPause()@FutureMessage becomes: { |x|
				system.println("Die antwoord: " + x);
				publication := disconnect: advice;
			};
		};
	};
}; 



