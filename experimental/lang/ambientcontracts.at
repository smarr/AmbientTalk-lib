import /.at.support.timer;

object: {
	def contract: block {
		// Helper function to create a Field object.
		def makeField(nam, val) {
			object: {
				val := [false, val];
				def new(newHost) { self }; // singleton pattern
				def name := nam;
				def readField() { val[2] };
				def writeField(newVal) { val[2] := newVal; };
				def accessor() { (reflect: self).grabMethod(`readField); };
				def mutator() { (reflect: self).grabMethod(`writeField); };
				def online()    {  val[1] := true };
				def offline()   {  val[1] := false };
				def isOnline()  {  val[1] };
				def isOffline() { !val[1] };
			} taggedAs: [ /.at.types.Field ];
		};

		def base := object: {
			def tagMap := jlobby.java.util.HashMap.new();
			def restored_cb := nil;
			def fulfilled_cb := nil;
			def broken_cb := nil;

			def addField: field for: tag {
				def fieldList := tagMap.get(tag);
				if: (fieldList == nil) then: { fieldList := []; };
				tagMap.put(tag, fieldList + [ field ]);
				(reflect: self).addField(field);
			};
			// Specify a partner in the contract.
			def need: tag named: name {
				def field := makeField(name, nil);
				addField: field for: tag;
			};

			def need: tag named: name timeout: t {
				def field := extend: (makeField(name, nil)) with: {
					def timer := nil;
					def online() {
						if: (timer != nil) then: {
						system.println("cancelling timer");
							timer.cancel();
							timer := nil;
						};
						super.online();
					};

					def offline() {
						super.offline();
						system.println("installing timer");
						if: (timer != nil) then: {
							timer.cancel();
						};
						timer := when: seconds(t) elapsed: {
							timer := nil;
							super.writeField(nil);
							broken_cb.apply([]);
						};
					}
				};
				addField: field for: tag;
			};

			def when: ignore restored: block {
				restored_cb := block;
			};

			def when: ignore fulfilled: block {
				fulfilled_cb := block;
			};

			def when: ignore broken: block {
				broken_cb := block;
			};

			def checkFields() {
				system.println("Checking fields..");
				def haveAll := true;
				foreach: { |tag|
					def fields := tagMap.get(tag);
					foreach: { |f|
						if: (f.isOffline())
						then: {haveAll := false};
					} in: fields;
				} in: tagMap.keySet().toArray();
				haveAll;
			};

			def goOnline() {
				foreach: { |tag|
					def fields := tagMap.get(tag);
					whenever: tag discovered: { |obj|
						system.println("Found a " + tag + "!");
						def done := false;
						foreach: { |f|
							if: ((!done).and: {nil == f.readField()}) then: {
								f.writeField(obj);
								f.online();
								done := true;
								when: obj disconnected: {
									f.offline();
									broken_cb.apply([]);
								};
								when: obj reconnected: {
									f.online();
									if: (checkFields()) then: {restored_cb.apply()};
								};
							if: (checkFields()) then: {
								system.println("contract is a go!");
								fulfilled_cb.apply([]);
							}
							};
						} in: fields;
						if: (!done) then: {
							system.println("did not find a slot for " + obj);
						};
					};
				} in: tagMap.keySet().toArray();
			};
			def contract := self;
		};
		
		block.applyInScope([], base);
		base;
	};
};
