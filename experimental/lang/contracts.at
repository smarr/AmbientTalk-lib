/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2010
 * Authors: Dries Harnie & Christophe Scholliers
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
 
 /* Implementation of ambient contracts, as written in the CEDI2010 paper. */

import /.at.lang.structuraltypes;
import /.at.discovery.discovery;
import /.experimental.lang.AspectMirror;
import /.experimental.lang.DispatchingMirror;


deftype ContractField <: /.at.lang.types.Field;

deftype Marker;

/* Alias for protocolOf. */
def role: obj {
	protocolOf: obj;
};

/* Rebinding strategies when a field disconnects. There are three choices:
 *   - Frail makes the composition fail if a service annotated with this keyword disconnects;
 *   - WeakRebind denotes that the composition pauses until an equivalent service is discovered;
 *   - SturdyRebind works like WeakRebind, but only resumes if the original service reconnects.
 */
def RebindStrategies := object: {
	def Frail := object: {
		def discover(field, contract, object) {
			field.addObj(object);
		};
	
		def disconnect(field, contract, object) {
			if: field.selected.contains(object) then: {
				contract.fail();
			}
		};
		
		def reconnect(field, contract, object) {
			// do nothing
		};
	};
	
	def WeakRebind := object: {
		def disconnected;
			
		def init() { 
			disconnected := jlobby.java.util.HashSet.new;
			self;
		};
		
		def discover(field, contract, object) {
			field.addObj(object);
		};
		
		def disconnect(field, contract, object) {
			if: (field.selected.contains(object)) then: {
				field.selected.remove(object);
				disconnected.add(object);
				if: !(field.checkSatisfied()) then: {
					contract.pause();
				};
			};
		};
		
		def reconnect(field, contract, object) {
			if: (disconnected.contains(object)) then: {
				field.selected.add(object);
				checkSatisfied();
			};
		};
	};
	
	def SturdyRebind := object: {
		def disconnected;
	
		def init() { 
			disconnected := jlobby.java.util.HashSet.new;
			self;
		};
		
		def discover(field, contract, object) {
			if: ((disconnected.isEmpty).and: { !isSatisfied() }) then: {
				field.addObj(object);
			}
		};
		
		def disconnect(field, contract, object) {
			if: (field.selected.contains(object)) then: {
				disconnected.add(object);
				contract.pause();
			};
		};
		
		def reconnect(field, contract, object) {
			if: (disconnected.contains(object)) then: {
				disconnected.remove(object);
				if: (disconnected.isEmpty()) then: {
					//contract.unpause();
				}
			}
		};
	};
};

/* Fields are part of a contract. They keep track of the devices discovered and
 * signal the contract once they are satisfied. Once satisfied, disconnections will
 * consult the rebind strategy to either wait for a reconnection, fail, or wait
 * for a device that also implements the role. See rebinding strategies above.
 */
def makeContractField(maxAmount, role) {
	object: {
		// The name of the field
		def name;
		
		def contract;
		
		def rebind;
		
		// The devices found in the environment that conform to the given role
		def found :=  /.at.collections.java.hashset.HashSet.new();
		
		// The devices actually selected to take part in the contract
		def selected :=  /.at.collections.java.hashset.HashSet.new();
		
		// Stopping the contract also halts all ongoing role subscriptions
		// (when:discovered: returns a canceler object)
		def cancelers := [];
		
		// List of messages to send to each new object that enters the selected set.
		def invariantsToSend := [];
				
		// TODO: return the selected set (with a DispatchingMirror installed) instead of self.
		def readField() { self };
		
		// Writing to the field adds the object to the contract
		def writeField(obj) { addObj(obj) };
		
		def new(newHost) { self };
		def accessor() { (reflect: self).grabMethod(`readField) };
		def mutator() { (reflect: self).grabMethod(`writeField) };
		
		// TODO: check invariants
		def checkSatisfied() {
			def ret := isSatisfied();
			if: ret then: {
				contract.fieldSatisfied(self)
			};
			ret
		};
		
		// Returns true if the contract is "full".
		def isSatisfied() {
			def amount := selected.size;
			(maxAmount == nil).or: { amount == maxAmount };
		};
		
		// Add the object to the set of found objects. If we can still add more to selected, do so.
		def addObj(obj) {
			if: ((maxAmount == nil).or: {selected.size < maxAmount})  then: { // no limit
				selected.add(obj);
				if: checkSatisfied() then: {
					invariantsToSend.each: {|msg| obj <+ msg };
				}
			}
		};
		
		def beforeCallBack: msgName  do: block {
			installCallback(`beforeCallBack, msgName, block);
		};
		
		def afterCallBack: msgName  do: block {
			installCallback(`afterCallBack, msgName, block);
		};

		def installCallback(selector, msgName, block) {
			def advice := object:{ 
				def notify(a,b) { 
					block.applyInScope([a,b], clone: contract) 
				} 
			};
			def pointcut := script:{|methodName,arguments| msgName.text == methodName; };
			
			def msg := <-dummy( pointcut, advice, contract)@[ContractMetaMessage,/.at.lang.futures.FutureMessage];
			msg.selector := selector;
			
			selected.each:{ |service| service <+ msg };
			invariantsToSend := invariantsToSend + [msg];
		};
		
		def applyInvariants(invariants) {
			invariants.applyInScope([], self);
		};

		def startDiscovering() {
			if: (cancelers == []) then: { // Can only start discovery once
			    system.println("starting discovery for " + name);
			    checkSatisfied();
			    
				def c := whenever: role discovered: { |obj|
					found.add(obj);
					rebind.discover(self, contract, obj);
					
					def d := whenever: obj disconnected: {
						found.remove(obj);
						rebind.disconnect(self, contract, obj);
					};
					
					def r := whenever: obj reconnected: {
						found.add(obj);
						rebind.reconnect(self, contract, obj);
					};
					
					cancelers := [d, r];
				};
				cancelers := [c] + cancelers;
			};
		};
		
		def stopDiscovering() {
			cancelers.each: {|c| c.cancel() };
			cancelers := [];
			invariantsToSend := [];
		};
		
	}  taggedAs: [ ContractField ] mirroredBy: { |base| makeDispatchingMirror(base, {base.selected}, role); };
};


// MAPPING OPERATORS
def one(role) {
	makeContractField(1,role); 
};

def many(role) {
	makeContractField(nil,role); 
};

def exactly(amount, role) {
	makeContractField(amount, role); 
};

// REBINDING STRATEGIES
def Frail: participant {
	participant.rebind := RebindStrategies.Frail.new;
	participant;
};

def WeakRebind: participant {
	participant.rebind := RebindStrategies.WeakRebind.new;
	participant;
};

def SturdyRebind: participant {
	participant.rebind := RebindStrategies.SturdyRebind.new;
	participant;
};

// INVARIANTS
def stateInvariant: block on: participant {

};



def contract: block {

	def fields := [];

	def contract := object: {
		def satisfied := 0;
	
		def contract := self;
		def invariants := [];
		
		def invariant: block on: participant {
			invariants := invariants + [[participant,block]];		
		};
		
		
		def start() {
			system.println("contract started");
			fields.each: {|f| f.startDiscovering() };
		};
		
		def stop() {
			system.println("contract stopped");
			fields.each: {|f| f.stopDiscovering() };
		};
		
		def fail() {
			system.println("contract failed");
			stop();
		};
		
		def pause() {
			system.println("contract paused");
		};
		
		def contractSatisfied() {
			system.println("contract satisfied");
			invariants.each:{|i| i[1].applyInvariants(i[2]) };
		};
		
		def fieldSatisfied(f) {
			satisfied := satisfied + 1;
			system.println("field " + f.name + " satisfied");
			if: (fields.length() == satisfied ) then: {
				contractSatisfied();
			};
			
		};
		
	};
	
	// TODO inject contract stuff into scope
	def scope := block.context.lexicalScope;
	(reflect: scope).listFields.each: { |f| 
		if: (f.name != `super) then: {
			(reflect: contract).addField(f);
		};
	};
		
	block.applyInScope([], contract);
	
	(reflect: contract).listFields.each: { |f|
		if: (is: f.readField taggedAs: ContractField) then: {
			def realName := f.name;
			def contractField := f.readField();
			contractField.name := realName;
			contractField.contract := contract;
			
			
			system.println("adding field " + realName + " to contract");
			(reflect: contract).removeSlot(f.name);
			
			(reflect: contract).addField(contractField);
			
			fields := fields + [contractField];
		}
	};
	
	contract;
};

self;