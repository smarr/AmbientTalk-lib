/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2010
 * Authors: Dries Harnie & Christophe Scholliers
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
 
 /* Implementation of ambient contracts, as written in the CEDI2010 paper. */

import /.at.lang.structuraltypes;
import /.at.discovery.discovery;
import /.experimental.lang.AspectMirror;
import /.experimental.lang.DispatchingMirror;


deftype ContractField <: /.at.lang.types.Field;

deftype Marker;

/* Alias for protocolOf. */
def role: obj {
	protocolOf: obj;
};

/* Rebinding strategies when a field disconnects. There are three choices:
 *   - Frail makes the composition fail if a service annotated with this keyword disconnects;
 *   - WeakRebind denotes that the composition pauses until an equivalent service is discovered;
 *   - SturdyRebind works like WeakRebind, but only resumes if the original service reconnects.
 */
def RebindStrategies := object: {
	def Frail := object: {
		def disconnect(field, contract, object) {
			contract.fail();
		};
		
		def reconnect(field, contract, object) {
			// do nothing
		};
	};
	
	def WeakRebind := object: {
		def disconnect(field, contract, object) {
			contract.pause()
		};
		
		def reconnect(field, contract, object) {
			// do nothing
		};
	};
	
	def SturdyRebind := object: {
		def disconnect(field, contract, object) {
			contract.pause();
		};
		
		def reconnect(field, contract, object) {
			// do nothing
		};
	};
};

/* Fields are part of a contract. They keep track of the devices discovered and
 * signal the contract once they are satisfied. Once satisfied, disconnections will
 * consult the rebind strategy to either wait for a reconnection, fail, or wait
 * for a device that also implements the role. See rebinding strategies above.
 */
def makeContractField(maxAmount, role) {
	object: {
		// The name of the field
		def name;
		
		def contract;
		
		def rebind;
		
		// The devices found in the environment that conform to the given role
		def found :=  /.at.collections.java.hashset.HashSet.new();
		
		// The devices actually selected to take part in the contract
		def selected :=  /.at.collections.java.hashset.HashSet.new();
		
		// Stopping the contract also halts all ongoing role subscriptions
		// (when:discovered: returns a canceler object)
		def cancelers := [];
	
	
		def invariants := [];
					
		def beforeCallBack: pointcut do: advice {
			invariants := invariants + [`beforeCallBack, pointcut, advice];
		};
					
		def invariant: block {
			system.println(block);
			eval: `{#@(block.method.bodyExpression.statements)} in: {}.context.lexicalScope;
		};

		// TODO: return the selected set (with a DispatchingMirror installed) instead of self.
		def readField() { self };
		
		// Writing to the field adds the object to the contract
		def writeField(obj) { addObj(obj) };
		
		def new(newHost) { self };
		def accessor() { (reflect: self).grabMethod(`readField) };
		def mutator() { (reflect: self).grabMethod(`writeField) };
		
		// TODO: check invariants
		def checkSatisfied() {
			def amount := selected.size;
			if: ((maxAmount == nil).or: { amount == maxAmount }) then: {
				contract.fieldSatisfied(self)
			}
		};
		
		// Add the object to the set of found objects. If we can still add more to selected, do so.
		def addObj(obj) {
			found.add(obj);
			if: ((maxAmount == nil).or: {selected.size < maxAmount})  then: { // no limit
				selected.add(obj);
				checkSatisfied();
			}
		};
		
		def startDiscovering() {
			if: (cancelers == []) then: { // Can only start discovery once
			    system.println("starting discovery for " + name);
			    checkSatisfied();
			    
				cancelers := [whenever: role discovered: { |obj|
					addObj(obj);
					
					def d := whenever: obj disconnected: {
						found.remove(obj);
						if: (selected.contains(obj)) then: {
							rebind.disconnect(self, contract, obj);
						};
					};
					
					def r := whenever: obj reconnected: {
						addObj(obj);
						if: (selected.contains(obj)) then: {
							rebind.reconnect(self, contract, obj);
						};
					};
					
					cancelers := cancelers + [d, r];
				}];
			};
		};
		
		def stopDiscovering() {
			cancelers.each: {|c| c.cancel() };
			cancelers := [];
		};
		
	   system.println("field "+name+" invariants:" + invariants);
	}  taggedAs: [ ContractField ]   mirroredBy: { |base| makeDispatchingMirror(base, {base.selected}, role); };
};


// MAPPING OPERATORS
def one(role) {
	makeContractField(1,role); 
};

def many(role) {
	makeContractField(nil,role); 
};

def exactly(amount, role) {
	makeContractField(amount,role); 
};

// REBINDING STRATEGIES
def Frail: participant {
	participant.rebind := RebindStrategies.Frail;
	participant;
};

def WeakRebind: participant {
	participant.rebind := RebindStrategies.WeakRebind;
	participant;
};

def SturdyRebind: participant {
	participant.rebind := RebindStrategies.SturdyRebind;
	participant;
};

// INVARIANTS
def stateInvariant: block on: participant {

};

def invariant: block on: participant {
	participant.invariant: block;
};

def contract: block {

	def fields := [];

	def contract := object: {
		def contract := self;
		
		def start() {
			system.println("contract started");
			fields.each: {|f| f.startDiscovering() };
		};
		
		def stop() {
			system.println("contract stopped");
			fields.each: {|f| f.stopDiscovering() };
		};
		
		def fail() {
			system.println("contract failed");
			stop();
		};
		
		def pause() {
			system.println("contract paused");
		};
		
		def fieldSatisfied(f) {
			system.println("field " + f.name + " satisfied");
		};
		
	};
	
	// TODO inject contract stuff into scope
	def scope := block.context.lexicalScope;
	(reflect: scope).listFields.each: { |f| 
		if: (f.name != `super) then: {
			(reflect: contract).addField(f);
		};
	};
		
	block.applyInScope([], contract);
	
	(reflect: contract).listFields.each: { |f|
		if: (is: f.readField taggedAs: ContractField) then: {
			def realName := f.name;
			def contractField := f.readField();
			contractField.name := realName;
			contractField.contract := contract;
			
			
			system.println("adding field " + realName + " to contract");
			(reflect: contract).removeSlot(f.name);
			
			(reflect: contract).addField(contractField);
			
			fields := fields + [contractField];
		}
	};
	
	contract;
};

self;