/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2010
 * Authors: Dries Harnie & Christophe Scholliers
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
 
 /* Simple test script for ambient contracts, see also /.experimental.lang.contracts */

import /.experimental.lang.contracts;


network.online;

deftype Control;

def phone_actor := actor: { |Control|
	import /.experimental.lang.contracts;
	
	def phone := service: {
		def IncomingCall()@[Public] { system.println(name + " is ringing"); };
		def name := "Bob's phone";
		def location := "study";		
	};
	
	def control := object: {
		def name := "phone";
		def offline() { takeOffline: phone; };
		def online() { export: phone as: protocolOf: phone };
	};
	
	export: control as: Control;
	
	control.online();
};

def spawn_audio_actor(loc := "test") {
	actor: { |Control, loc|
		import /.experimental.lang.contracts;
		
		def audio := service: {
			def pause() { system.println("audio device is pausing") };
			def unpause() { system.println("audio device is unpausing") };
			def location := loc;
		};
		
		def control := object: {
			def move(loc) { audio.location := loc; };
			def name := "audio";
			def offline() { takeOffline: audio; };
			def online() { export: audio as: protocolOf: audio };
		};
		
		export: control as: Control;
		
		control.online();
	}
};

spawn_audio_actor();

def Phone := protocol: {
	def IncomingCall();
	def name := "Bob's Phone";
	def location;
};

def AudioDevice := protocol: {
	def pause();
	def unpause();
	def location;
};

def c := contract: {
	def phone := Frail: one(Phone);
	def devices := WeakRebind: many(AudioDevice);
		
	stateInvariant: `location on: devices equals: "test";
	
	invariant: {
		beforeCallBack: `IncomingCall  do: { |methodName,args|
			system.println("pausing all audio devices");
			devices<-pause();
		};
		
		afterCallBack: `IncomingCall  do: { |methodName,args|
			system.println("unpausing all audio devices");
			devices<-unpause();
		};
	} on: phone;  
};

def phoneC := nil;
def audioC := /.at.collections.java.hashset.HashSet.new;


def move(to := "test") {
	audioC.to_array[1]<-move(to);
};

whenever: Control discovered: { |c|
	when: c<-name()@FutureMessage becomes: { |name|
		if: (name == "phone") then: { phoneC := c } else: {audioC.add(c)};
	};
};

c.start();