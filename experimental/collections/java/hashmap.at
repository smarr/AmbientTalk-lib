import ~.traits.map;

def JHashMap := jlobby.java.util.HashMap;

def HashMapModule := object: {

	def HashMapMirror := mirror: {
		
		//def print() {
		//	"<hashmap:" + (print: self.base.toTable()) + ">";
		//};
		
		def print() {
			"<hashmap:{" + (self.base.toTable().map: { |entry|
				(print: entry[1]) + "=>" + (print: entry[2]);
			}).join(", ") + "}>";
		};
		
		def asCode() {
			def elements := asCode: (self.base.toTable());
			"{ def elements := " + elements + " ; HashMap.new(elements) }()";
		};
		
	};
	
	def HashMap := object: {
		
		// wrapped java vector
		def jhashmap := JHashMap.new();
		
		// initialization
		def init(collection := []) { 
			// a collection that supports .each: {|e| ... }
			self.jhashmap := JHashMap.new();
			if: (is: collection taggedAs: /.at.lang.types.Table) then: {
				//suppose table with key-value pairs
				collection.each: { |entry| self.put(entry[1], entry[2]) };
			} else: {
				collection.each: { |k, v| self.put(k, v) };
			};
			self;
		};
		
		def getMap() {
			self.jhashmap;
		};
		
		def setMap(map) {
			self.jhashmap := map;
		};
		
		import MapTrait;
		
		def atPut(key, val) {
			self.jhashmap.put(key, val);
		};
		
		def at(key) {
			self.jhashmap.get(key);
		};
		
		def each: clo {
			def keyIt := self.jhashmap.keySet().iterator();
			def valIt := self.jhashmap.values().iterator();
			while: { keyIt.hasNext() } do: {
				clo(keyIt.next(), valIt.next());
			};
		};
		
		def eachKey: clo {
			def keyIt := self.jhashmap.keySet().iterator();
			while: { keyIt.hasNext() } do: {
				clo(keyIt.next());
			};
		};
		
		def toTable() {
			def table := [];
			self.each: { |k, v|
				table := table + [[k, v]];
			};
			table;
		};
		
		def asTable() { self.toTable() };

		
	} mirroredBy: HashMapMirror;
	
};

HashMapModule;