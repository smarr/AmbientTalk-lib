/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2010
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * TOTAM: Tuples on the Ambient.
 *
 * @author egonzale, cfscholl
 */
def Vector := /.at.collections.vector.Vector;
import /.at.lang.futures;
enableFutures(false);
import /.at.exceptions;
deftype TotamTuple;
deftype LeasedTuple <: TotamTuple;
deftype TotamTupleSpace;
def crimeModule := /.at.crime.CrimeConnection;
def timerModule := /.at.support.timer;

def ambientTupleSpace := object: {
	 def hashMap;
	 def value := object:{
	   def tuple; def tableTsRefs;
	   def init(t) {tuple := t; tableTsRefs := []};
	   def addTs(tsRef) { tableTsRefs := tableTsRefs + [tsRef]};
	   def getTs(){tableTsRefs};	 
	 };
	 def init(){
		hashMap := jlobby.java.util.HashMap.new();
	 };
	 def each: clo {
		def valit := hashMap.values().iterator();
		while: { valit.hasNext() } do: {
			def value := valit.next();
			clo(value.tuple, value.tableTsRefs);
		};
	 };
	 def add(tuple){
		 hashMap.put(tuple.getTupleId, value.new(tuple));
	 };
	 
	 def contains(tupleId){
	//	 hashMap.containsKey(tupleId);
	   { |return|
	      def comparator := { |tid| tid == tupleId};
	      def keyit := hashMap.keySet().iterator();
	      while: { keyit.hasNext() } do: {
		      def key := keyit.next();
		      if: (comparator(key)) then: {return(true) };
		    };
		    false;
	    }.escape();
	 };

	 def remove(tupleId){
		// hashMap.remove(tupleId);
		 def comparator := { |tid| tid == tupleId};
		 def keyit := hashMap.keySet().iterator();
		 def found := false;
		 def toRemove := nil;
		 while: { (keyit.hasNext()).and:{ !found} } do: {
			 def key := keyit.next();
			 if: comparator(key) then: {
				 toRemove := key; found := true;
			 };
		 };
		 if: found then: {
			hashMap.remove(toRemove);
		 } else: {
			 nil;
		 };
	 };
	 //application-dependent method.
	 def addTs(tuple, tsRef){
		 def value := hashMap.get(tuple.getTupleId);
		 if: (nil != value ) then:{
			value.addTs(tsRef);
		 };
	 };
};

//helper functions adapted from context-aware tuples
//for when:matches: implementation
def makeNewClosure(variableNames, closure) {
	def newClosureStatements := `{ | #@(variableNames) | 
		#@(closure.method.bodyExpression.statements) };
	eval: newClosureStatements in: closure.context.lexicalScope;
};

def varNames(template) {
	def table := [];
	template.each: { |attribute|	
		if: (is: attribute taggedAs: /.at.types.Symbol) then: { //its a variable
			def variableName := attribute.symbol; 
			if: !(table.contains(variableName)) then: {
				table := table + [variableName];
			};
		};
	};
 	table;
};

def makeTupleSpace(descriptor := nil){
  def tupleSpaceId :=  /.at.support.util.RandomNumberGenerator().nextInt(); 	
	def localTS := Vector.new(); //contains local tuples
	// contains tuples which needs to be transmitted to the ambient
	def ambientTS := ambientTupleSpace.new(); 
	def localTSListeners := Vector.new(); 
	def seenTS := Vector.new(); // contains [far reference, descriptor] to the seen TS.
	
	//register listener for in or rd operations
	def registerListener(l) { 
	   localTSListeners.add(l);
	  object: { 
		  def cancel() {
			 removeListener(l)
			};
		};
	};
 	
  def removeListener(l) {
	  localTSListeners.remove(l); 
	};
	  
	def notifyListeners(tuple){
		localTSListeners.each: { |l| l<-notifyTupleInserted(tuple) }; 
	};
	
	def removeFromTS(tuple){
		localTS.removeAll: {|t| t.getTupleId == tuple.getTupleId};
		ambientTS.remove(tuple.getTupleId);
	};
	
	//method starting up the tuple propagation from discovery.
	def moveTuples(localTs, remoteTs, remoteDescriptor, remoteTupleSpaceId := 0){
		// add ts to seenTS vector so that it can be
	  // notified if I add a new tuple to the ambient.
		def toSend := [];
   //in the contains function e1 is bound to ts, e2 is [ts, descriptor, tupleSpaceId]
	  if: !(seenTS.contains(remoteTs, {|e1,e2| e1 == e2[1]})) then:{
		  if: (remoteTupleSpaceId == 0 ) then:{
			  // TODO PIGGYBACK tuplespaceId in moveTuples.
			  when: remoteTs<-getTupleSpaceInfo()@FutureMessage becomes: { |info|
					def index := seenTS.indexOf(remoteTs, comp);
					def remoteTsInfo := seenTS.at(index); //returns info in the form [remoteTs, descriptor, tupleSpaceId]
					remoteTsInfo[3] := info[1];
				};
		  };
	   	seenTS.add([remoteTs,remoteDescriptor,remoteTupleSpaceId]);
	  };
	  ambientTS.each: { |tuple, sentTs| 
		  if: (sendTuple(tuple, localTs, remoteDescriptor)) then: { toSend := toSend + [tuple] };
		};
		if: (toSend.length > 0) then: {	
			toSend.each: {|tuple| ambientTS.addTs(tuple, remoteTs) };
   		remoteTs<-receiveTuples(toSend);
	  };
  };
	
	//totam propagation protocol (receiver side)
	def receiveTuple(tuple, ts){
		if: tuple.decideEnter(ts) then: {
    	tuple.doAction(ts);
    	tuple := tuple.changeTupleContent(ts);
			if: tuple.decideStore(ts) then: { 
				ts.out(tuple); 
			}; 
		};
		tuple;
  };
	
	// totam propagation protocol (sender side)
	def sendTuple(tuple, ts, descriptor){
		// toThink: this method could be called twice via inject and discovery when the ts discover.
		// this is not so bad, because a receiving ts checks if it already triggered propagation protocol for this tuple via tupleId.
		if: tuple.decideDie(ts) then: {
      removeFromTS(tuple);
			false;
	  } else:{
		  //only call inScope method if the tuple space had a descriptor
		  if: (descriptor != nil) then: { tuple.inScope(descriptor)}
		  else: {true};
	  };
	};
  
	//method starting up the propagation protocol from inject after 1st hop.
	def sendTupleToAmbient(tuple){
		if: !(ambientTS.contains( tuple.getTupleId)) then: {
			// adding the tuple to the ambient for next sync.
			// do not store antituples.
		  if: (!tuple.getTupleId.isAntituple) then: { 
			  ambientTS.add(tuple);
			};
		  //send tuple to the totam network if sender protocol applies.
		  seenTS.each: { |ts| 
			  if: (sendTuple(tuple, localInterface, ts[2])) then: { 
				  ambientTS.addTs(tuple, ts[1]);
				  ts[1]<-receiveTuples([tuple]) 
				};
		  };
	  };
	};
	
	// implements the functionality of a atomic remove but since it is used by both 
	// local and remote interface, implemented as a private method.
	def atomicRemovePrivate(tupleId, antituple := true) {
		// it should be either in the localTS or 
		// in the ambientTS (if it was injected here but not stored in the localTS)
		//localTS.removeAll: {|t| t.getTupleId == tupleId};
		def result := false;
		def localTupleId := localTS.find: { |t| t.getTupleId == tupleId };
		if: !(nil == localTupleId) then: {
			localTS.removeAll: { |t| t.getTupleId == tupleId }; 
			result := true;	
		};	
		if: (ambientTS.contains(tupleId)) then: {
			//remove the tuple for good :)
			def value := ambientTS.remove(tupleId);
			if: (nil != value) then:{
				def ambientTuple := value.tuple;
				//sends an antituple if required.
				if: antituple then:{
					def propagate := true;
					//only propagate the antituple as long as the tuple is still alive if it was leased, 
					// otherwise it would have died as well in other nodes.
					if: ((is: ambientTuple taggedAs: LeasedTuple).and:{ambientTuple.decideDie(localInterface)}) then: { propagate := false};
				  if: propagate then:{
					  value.getTs.each:{ |tsRef| tsRef<-receiveTuples([makeAntiTuple(ambientTuple)])};
				  };
			  };
		    result := true;
			};
		};
	  result;
  };

  //helper function used by when(ever):in listeners and inpWithAtomicRemove
  def removeRemoteTuple(tuple){
	  def tupleId := tuple.getTupleId(); 
	  // find first the remote far reference for the orignator ts.
	  def remoteTs := { |return|
      seenTS.each: { |tsInfo|
	      if: (tsInfo[3] == tupleId.getTupleSpaceId()) then: {return(tsInfo[1])};
      };
      nil;
    }.escape();
    // ask the originator to remove the tuple
	  if: !(remoteTs == nil) then:{
		  remoteTs<-atomicRemove(tupleId)@FutureMessage;
	  } else: {
		  //this shouldn't happen, if it is a remote tuple, its ts should be in seenTS
		  def [fut,res] := makeFuture();
		  res.resolve(false); 
			fut;
	  };
  };

  def inpWithAtomicRemove(template){
	  def [futRV,resRV] := makeFuture();		  
  	def toReturn := localInterface.rdp(template);
    if: (nil != toReturn) then:{
      def tupleId := toReturn.getTupleId;
	    if: (tupleId.isRemote(tupleSpaceId)) then: {
			  when: removeRemoteTuple(toReturn) becomes: { |removed|
			   if: removed then:{
				   localTS.remove(toReturn);
				   resRV.resolve(toReturn);
			   } else: { resRV.resolve(nil)};
		    } catch: /.at.types.Exception using: { |e|
			    resRV.resolve(nil);
			  };
      } else: { // found and not remote, end
	      localTS.remove(toReturn);
	      resRV.resolve(toReturn);
	    };
	  } else:{ //not found , end
		  resRV.resolve(toReturn);
	  };
	  futRV;
  };

  // remote interface 
  def remoteInterface := object: {
		// iterates over all ambient tuples of the other ts 
		// and triggers the propagation protocol			
		def receiveTuples(tuples){
		  tuples.each: { |tuple|
			  // totam propagation protocol
		    tuple := receiveTuple(tuple, localInterface);
				sendTupleToAmbient(tuple);
		  };
  	};
	
	  def getTupleSpaceInfo() {
		  [tupleSpaceId, descriptor];
	  };
    
    //def atomicRemove := &atomicRemovePrivate;
		def atomicRemove(tupleId, antituple := true) {
	   atomicRemovePrivate(tupleId,antituple);
		};
	  
  };	

	// public interface
	def localInterface := object: {
		// add a tuple to the local ts
	  def out(tuple, timeout :=  timerModule.ZERO){
			if: (doesTupleHasVariables(tuple)) then:{
				error("trying to insert a template into the tuple space");
			} else: {
	      if: (timeout > timerModule.ZERO) then: {
			    timerModule.when: time elapsed: {
				    localTS.remove(tuple);
			    };
			  };
			  //do not add a tuple which was already there
			  //otherwise it may trigger when:read/in twice for same tuple!
			  if: !(localTS.contains( tuple, {|t, t1| t.getTupleId == t1.getTupleId})) then: {
				  def tupleId := tuple.getTupleId();
				  if: (!tupleId.isInTupleSpace) then:{ 
					  //set tupleId because it was inserted by a local out.
					  tupleId.tupleSpaceId := tupleSpaceId; 
					};
			    localTS.add(tuple);
				  notifyListeners(tuple);
			  };
			};
	  };
	  // non-blocking rd operation 
		// returns a tuple matching the template in the ts or 
		// nil if non is present at the time of the request. 
		// if multiple tuples match the tample,
	  // the one returned is selected non-deterministic.
		def rdp(template) { 
			{ |return|
			  localTS.each: { |tuple|
				  //it matches the template and it is not death
				  if: ((template.match(tuple)).and: {!tuple.decideDie(localInterface)}) then: { return(tuple)};
			  };
			  nil;
			}.escape();
		};
		
		// bulk rd operation (~rdg in lighTS)
		// returns all tuple matching the template in the ts or 
		// [] if non is present at the time of the request.
		def rdg(template){
			def toReturn := [];
			localTS.each: { |tuple|
				//it matches the template and it is not death
				if: ((template.match(tuple)).and: {!tuple.decideDie(localInterface)}) then: { 
					toReturn := toReturn + [tuple];
				};
			};
			toReturn;
		};			
		//inserts a tuple into the ambient ( ~ inject in TOTA)
		//note that this just exports a tuple to the ambient
		//but it does not store in the local ts.
		def inject: tuple {
			if: (doesTupleHasVariables(tuple)) then:{
				error("trying to inject a template to the network");
			} else: {	
				// set the tuple id
				(tuple.getTupleId()).tupleSpaceId := tupleSpaceId; 
			  //send to local tuple space if necessary.
			  if: (sendTuple(tuple, self, descriptor)) then: { receiveTuple(tuple, self) };
			  // send to the ambient.
			  sendTupleToAmbient(tuple);
		    //return a publication object to be able to cancel the injection.
		    object:{
			    def retract(){atomicRemovePrivate(tuple.getTupleId)};
		      def cancel(){removeFromTS(tuple)};
		    };
		  };
		};
		// injects a tuple into the ambient with a lease.		
		def inject: tuple timeout: time {
			if: (time > timerModule.ZERO) then: { 
				// modify the delegation chain as follows:
				// propagation protocol <- leasingPropagation <- tuple
			  def leasedPropagation := attachLeasingPropagation(tuple.super, time);
			  tuple.super := leasedPropagation;
			};
			inject: tuple;
		};
		// functions to place a listener on the tuple space ( ~ subscribe in TOTA, reactions of LIME)
		// triggered asynchronously when a tuple matches a template
		// it returns a publication object with a cancel() object to be able to unsusbscribe 
		// 2 types of reactions:
		// duration of registration: (1) when: called once for the first matching tuple 
		//                           (2) whenever: called everytime for a matching tuple.
		// operation listening: in or rd
		def when: templateTable read: closure {
			when: templateTable matches: closure registration: false removeTuples: false;
		};
		def when: templateTable in: closure {
			when: templateTable matches: closure registration: false removeTuples: true;
		};
		def whenever: templateTable read: closure {
			when: templateTable matches: closure registration: true removeTuples: false;
		};
		def whenever: templateTable in: closure {
			when: templateTable matches: closure registration: true removeTuples: true;
		};
			
		// common behaviour of when:whenever:in/read
		def when: template matches: closure registration: installListener removeTuples: inTuple {
	    def registration; def activeRegistration := true;
		  def variableNames := varNames(template);
		  closure :=  makeNewClosure(variableNames, closure); 
			//helper funcs  
			// maps the values of the matched tuple to 
		  //the variables in the template and notify the closure
			def notifyClosure(tuple){
				 // only notify if we are still active 
				if: activeRegistration then:{
			    def mapValues := variableNames.map: { |var|  
			      def index := template.getIndexOf(var);
			      tuple.getField(index); 
			    };
			    closure(@mapValues);
			  };
			};
		  // it manages the registration of listeners for in/read operations.
			def addListener(){
				if: (registration == nil) then: { //makes sure we only install 1 listener per call.
				  def listener := object: {
					  def active := true;
	          def notifyTupleInserted(tuple){
		          if: active then: { 
	              if: ((template.match(tuple)).and:{!tuple.decideDie(localInterface)}) then: {
		              // listener for in operation should remove the tuple!
								  if: inTuple then: { // listener for an in operation
									  if: (tuple.getTupleId().isRemote(tupleSpaceId)) then:{ // the matching tuple is remote 
										  // it needs to do an atomic remove 
										  when: removeRemoteTuple(tuple) becomes: { |removed|
										    if: removed then: {
											    localTS.remove(tuple);
											    notifyClosure(tuple); 
											  };
										  };
									  } else:{  // the matching tuple is local 
									    localTS.remove(tuple);	
									    notifyClosure(tuple); 
								    };
								  } else: { //listener for read operation
									  //it notifies closure
			              notifyClosure(tuple); 
								  };
							    // cancel the subscription for when: listeners
							    // it could be that an async. message was already scheduled for this listener
							    // but if it is a when:, it shouldn't be processed.
		              if: (!installListener) then: { active := false; registration.cancel()};
	              };
	            };
		        };
		      };
			    registration := registerListener(listener);
			  };
			};
			// code for when: template matches: closure registration: installListener removeTuples: inTuple 
			if: inTuple then: { //when:in
				when: inpWithAtomicRemove(template) becomes: { |matchingTuple|
					if: (nil == matchingTuple) then:{
						// we didn't found a matching tuple, install listener.	
				  	addListener();
					} else:{
						notifyClosure(matchingTuple);
					};
				}; 	
			} else:{ 	//when:read 
				def matchingTuple := rdp(template);	
				if: (nil != matchingTuple) then: { //we got a tuple, notify closure
					notifyClosure(matchingTuple); 
				} else: { // we didn't found a matching tuple, install listener.	
				 addListener();
				};
			};
			// install a listener if it is a whenever:
			if: installListener then: { addListener(); };
	    // return value a publication object to cancel the registration
	    object: {
		    def cancel(){
			    activeRegistration := false; // cancel this registration
			    // registration is nil if when:ip/rd and we found a tuple.
			    if: (nil != registration) then:{ registration.cancel()};
		    };
	    };
	  };
		// additional methods provided to keep service  
		// discovery decoupled from tuple space implementation
		
		// notifies the discovery of a TS	
		// and starts the propagation protocol (sender side)
		def notifyTSDiscovered(ts, descriptor := nil, tsId := 0){ 
			// get the descriptor if it is not known.
		  if: (descriptor == nil) then: {
			  when: ts<-getTupleSpaceInfo()@FutureMessage becomes: { |info|	
				  // info = [tupleSpaceId, descriptor]
				  moveTuples(self, ts, info[2], info[1]);
			  };
			} else: {
				moveTuples(self, ts, descriptor, tsId);
			};
    };
    // get remote interface so that it can be 
    // exported to the network
	  def getRemoteInterface(){
		  remoteInterface;
	  };
		// exports this tuple space and listens for other
		// tuples spaces which appear in the network
		// using AT service discovery
    def goOnline(){
	    def p := export: remoteInterface as: TotamTupleSpace;
	    def s := whenever: TotamTupleSpace discovered: { |remoteTs|
		    def comp := {|e1,e2| e1 == e2[1]};
		    if: !(seenTS.contains(remoteTs, comp)) then:{
			    // seen this tuple space for first time, we need descriptor and tupleSpaceId
				  notifyTSDiscovered(remoteTs);
				} else:{ //re-discovering a tuple space already seen.
					def index := seenTS.indexOf(remoteTs, comp);
					def remoteTsInfo := seenTS.at(index); //returns info in the form [remoteTs, descriptor, tupleSpaceId]
					notifyTSDiscovered(remoteTs, remoteTsInfo[2], remoteTsInfo[3]);
				};
			};
	    object:{
		    def cancel(){ p.cancel(); s.cancel(); };
	    };
    };
    // added for debugging purposes
    def toString(){
	    def table := [];
	    localTS.each: {|tuple| table := table + [tuple.toString] };
	   "<tuple space:" + tupleSpaceId + " withTuples: " +  table + " >";
    };

    //TODOdef atomicRemove := &atomicRemovePrivate;
    def atomicRemove(tupleId, antituple := true) {
	   atomicRemovePrivate(tupleId,antituple);
		};	
	}; // end-of-public interface
};

// helper function to construct a tuple id which consist of.
// -tupleSpaceId uniquely identifying the originator of the tuple. 
// -tupleId uniquely identifying the tuple within a tuple space.
def TupleId := isolate: { 
	def tupleId; 
	def tupleSpaceId; // unbound until tuple inserted in a ts.
	def antituple := false;
	def init(tsId := 0, tId := nil, anti := false){
		if: (tId == nil) then:{ 
			tupleId := /.at.support.util.RandomNumberGenerator().nextInt();
		} else:{ tupleId := tId};
		antituple := anti;
		tupleSpaceId := tsId; 
	};
	def isAntituple(){antituple};
	def isInTupleSpace(){ 0 != tupleSpaceId};
	def isRemote(aTsId){ tupleSpaceId != aTsId };
  def getTupleSpaceId(){tupleSpaceId};
	def getTupleId() {tupleId};
	def toString() { "<tsID:" + tupleSpaceId + "tupleId:" + tupleId + "antituple:" + antituple +">" };
	def ==(aTupleId){ 
		(tupleId == aTupleId.getTupleId).and: {tupleSpaceId == aTupleId.getTupleSpaceId};//.and:{ antituple == aTupleId.isAntituple()}
	};	
};

def makeTuple(tupleId, @fields) {
	isolate: { |tupleId, fields|
		//getTupleId shouldn't be part of the public interface, kept for unit testing
		def getTupleId() { tupleId };
	  def length(){ fields.length };
	  def getField(n) { fields[n] };
	  def getFields() {fields};
	  def getIndexOf(val){
		  { |return|
			  def index := 0;
		    fields.each:{ |field| 
			    index := index + 1;
			    if: (is: field taggedAs: /.at.types.Symbol) then: {
				     field := field.symbol;
			    };
			    if: (field == val) then: {return(index)};
		    };
		    index;
	    }.escape();
	  };
	  def findAllSymbols(template, aSymbol){
			def positions := []; def i := 1;
		  while: { i <= template.length} do: {
			  def field := template.getField(i);
			  if: ((is: field taggedAs: /.at.types.Symbol).and: { field.getSymbol == aSymbol}) then: {
				  positions := positions + [i];
			  }; 
			  i := i + 1;
		  };
		  positions;
	  };
	  def match(t1) {
		  def result := true;
		  if: (t1.length == self.length) then: {
		 	  def it := 1; 
			  while: { (it <= fields.length).and: { result} } do: { 
				  def e1 := t1.getField(it); 
				  def e2 := getField(it);
					def symbolField := nil; def tuple := nil; def template := nil;
					if: (is: e1 taggedAs: /.at.types.Symbol) then: { symbolField := e1.getSymbol; tuple := self; template := t1 };
				  if: (is: e2 taggedAs: /.at.types.Symbol) then: { symbolField := e2.getSymbol; tuple := t1; template := self };
					if: (symbolField != nil) then: {
						def positions := findAllSymbols(template, symbolField);
						if: (positions.length > 0) then: { // the field is a symbol which has several appearances in the temple,
						  //all positions in the tuple should have the same value.
						  def val := tuple.getField(positions[1]); 
						  result := { |return|
							  def sameValue := true;
						    positions.each: { |p| sameValue := sameValue.and: {(tuple.getField(p)) == val}; if: (!sameValue) then: {return(false)}};
						    true;
						  }.escape();
						} else: { // the field is symbol which is only once in the template, so it works like a wildcard.
							result := true;
						};
					} else: {  // the field is a value
						result := (e1 == e2); 
					}; 
				  it := it + 1; 
			  };
		  } else: { result := false};
		  result;
	  };
	  def toString(){   
		  def content := fields.map:{ |e| 
			  if: (is: e taggedAs: /.at.types.Symbol) then:{ e.getSymbol.text}
			  else: {e};
			};
			"<"+ tupleId.toString() + content + ">";
		};
	  def each: l  { fields.each: l };
	};
};

def doesTupleHasVariables(tuple){
	{ |return|
		tuple.each: { |field|
		  if: (is: field taggedAs: /.at.types.Symbol) then: { return(true) };
		};
		false;
	}.escape();
};

// default TOTAM tuple behaviour = 
// always in scope and store itself in every hop.
def defaultPropagationProtocol(){
  isolate: {
		// TOTAM specific operations
		// called in every tuple before transmiting the tuple at the sending side !
		def inScope(descriptor){ true };
		// if true -> tuple gets unexported and deleted from local TS.
		def decideDie(ts){false};
		// TOTA-inherited operations
		// called in every tuple at arrival at receiver side.
		def decideEnter(ts) { true };
		// specifies operations on the local TS
		def doAction(ts){};
		// create a new tuple resulting from operations on the tuple itself
		def changeTupleContent(ts){self};
		// if true -> note gets added to local TS
		def decideStore(ts) {true};
	};
};

// templates shouldn't propagate so, 
// they carry a dummy propagation protocol
// which basically doesn't not propagate
def noPropagationProtocol(){
	isolate: { 
		def inScope(descriptor){false};
		def decideDie(ts){true};
		def decideEnter(ts) { false };
		def doAction(ts){};
		def changeTupleContent(ts){self};
		def decideStore(ts) {false};
	};
};
// attaches leasing protocol to a given propagation protocol.
// used implement inject:timeout:
def attachLeasingPropagation(propagationProtocol, time){
	extend: propagationProtocol with: { |time|
		def timeout := time;
		def timerSubscription := nil;
		def expired := false;
		def startSubscription(){
			self.expired := false;
	 	  if: (self.timeout > /.at.support.timer.ZERO) then: {
			  self.timerSubscription := /.at.support.timer.when: time elapsed: {
				  self.timeout := /.at.support.timer.ZERO;
				  self.whenExpired();
			  };
		  };
		};				
		def whenExpired(){
			self.expired := true;
		};
		//overrides default decideDie to take into account
		def decideDie(ts){ self.expired };
		//do not enter if you are expired.
		def decideEnter(ts) {!self.expired };
		//initialize the timer.
		startSubscription();
	} taggedAs: [/.at.types.Isolate, LeasedTuple] mirroredBy: ( object:{
		def pass(){
			def passObj := super^pass();
			def base := self.base;
			if: !base.expired then:{
			  passObj.timeout := base.timerSubscription.getTimeRemaining();
			};
			passObj;
		};
		def resolve(){
			def resolveObj := super^resolve();
			resolveObj.startSubscription();
			resolveObj;
		}
	}childOf: defaultMirror extends: true taggedAs: [/.at.types.Isolate] mirroredBy: defaultMirror );
};

def antiTuplePropagationProtocol() {
	//one hop tuple which further propagates the atomic removal of the original tuple
	isolate:{
	  def die := false;
	  //by design antituples generated by the system do follow the tuple everywhere it was sent.
	  //TODO: keeping the inScope/decideDie as the original will make it follow the tuple as well.
    def inScope(descriptor) {false};
    def decideDie(ts){ die };
    //custom protocol for antituple.
    def decideEnter(ts){true};
    def doAction(ts){
	    ts.atomicRemove(self.getTupleId());
      die := true;
    };
    def decideStore(ts) {false};
    def changeTupleContent(ts){self};
  };
};
	
def makeAntiTuple(tuple){
	//antituple has the same content than its tuple but different sign!
	def tupleId := tuple.getTupleId();
	def antiTupleId := TupleId.new(tupleId.getTupleSpaceId(), tupleId.getTupleId(), true);
	def antiTuple := makeTuple(antiTupleId, tuple.getFields());
	// attach leasing propagation policy if original tuple had it
	if: (is: tuple taggedAs: LeasedTuple) then:{
		def time := tuple.timerSubscription.getTimeRemaining();
		antiTuple.super := attachLeasingPropagation(antiTuplePropagationProtocol(), time);
	} else:{
		antiTuple.super := antiTuplePropagationProtocol();
	};
	antiTuple;
};

// the module object of this file
def TotamModule := object: {
	// public stuff goes here
	def LeasedTuple := LeasedTuple;
	def makeTupleSpace := &makeTupleSpace;
	
	def tuple: fields {
		if: (doesTupleHasVariables(fields)) then: {
			tuple: fields withPropagationProtocol: noPropagationProtocol();
		} else:{
		  tuple: fields withPropagationProtocol: defaultPropagationProtocol(); 
	  };
	};
	
	def tuple: fields withPropagationProtocol: propagationProtocol {
		def tuple := makeTuple(TupleId.new(), @fields);
		tuple.super := propagationProtocol;
		tuple;
	};
  
  // creates an protocol object as follows:
  // - The object is initialized with the code of the argument closure.
  // - The object's dynamic parent is defaultPropagationProtocol.
  // - The object's types are initialized to Isolate, as it gets copied along with the tuple.
	def propagationProtocol: closure {
		extend: defaultPropagationProtocol() with: closure taggedAs: [/.at.types.Isolate];
	};
	// object that understands all meta-level operations applicable on tuples, 
	// implementing them using default semantics:
	// tuplw which is always in scope and store itself in every hop.
	def defaultPropagationProtocol := &defaultPropagationProtocol;
  //def attachLeasingPropagation := &attachLeasingPropagation;

	// a variable is like a wildcard, "a hole" a tuple which always matches. 
	def var: symbol {
	  object: { |symbol|
		  def getSymbol(){symbol};
	  } taggedAs: [/.at.types.Isolate, /.at.types.Symbol];	
	};

	def TotamTest := extend: /.at.unit.test.UnitTest.new("TotamTest", false) with: {
		import /.at.lang.futures;
		enableFutures(false);
		def test := self;
		// definition of tuples and templates used in several tests.
		def aTemplate := tuple: [var: `x, 3, false];
		def makeATuple() {tuple: ["elisa", 3, false]};
		def helloTemplate := tuple: [var: `x, "hallo"];
		def blueProtocol := propagationProtocol: {
			def inScope(descriptor) { descriptor.team == "blue" };
		};
		def makeABlueTuple() { tuple: [123, "bomb"] withPropagationProtocol: blueProtocol};
		// tests functioning of pattern matching in in and rdp.
		def testLocalOutRdpInp(){
			def myTS := makeTupleSpace();
			// insert  tuple.
			myTS.out(makeATuple());
			// read a template for that tuple.
			def tuple := myTS.rdp( aTemplate );
			self.assertNotEquals(nil, tuple);
			self.assertEquals( tuple.getField(1), "elisa");
      self.assertEquals( tuple.getField(2), 3);
      self.assertEquals( tuple.getField(3), false);
      //read a template with two variables.
      def template2Vars := tuple: [var: `x, 3, var:`x];
			tuple := myTS.rdp( template2Vars );
			self.assertEquals(nil, tuple, "here");
			myTS.out( tuple:[false, 3, false]);
			tuple := myTS.rdp(template2Vars);
			self.assertNotEquals(nil, tuple);
			self.assertEquals( tuple.getField(1), false);
      self.assertEquals( tuple.getField(3), false);
      //as tuple space doesn't have a descriptor
      // an inject results in a add to the ts.
      def name := "joan";
      myTS.inject: (tuple: [name, "arnau"]);			
      tuple := myTS.rdp(tuple:[var:`name, var:`y]);
      self.assertNotEquals(nil, tuple);
			self.assertEquals( tuple.getField(1), "joan");
      self.assertEquals( tuple.getField(2), "arnau");
		};
		// tests behaviour of (when:whenever) reactions on read operation
		def testAsyncLocalOutWhenRead(){
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace();
			// insert  tuple.
			def it1 := 0;
			myTS.when: aTemplate read: {
				self.assertEquals("elisa", x);
				// read the tuple
			  self.assertNotEquals(nil, myTS.rdp( aTemplate));
			  it1 := it1 +1;
			};
			def it2 := 0;
			myTS.whenever: aTemplate read:{
				self.assertEquals("elisa", x);
				it2 := it2 +1;
			};
			myTS.out(makeATuple());
			//note makeaTuple creates a new tuple because each tuple has tupleId,
			// and passing aTuple here would try to insert twice the same tuple 
			myTS.out(makeATuple());
			timerModule.when: 1.seconds() elapsed:{
				self.assertEquals(1, it1);
				self.assertEquals(2, it2);
				res.resolve(`ok);
			};
		  fut;
		};
		// tests behaviour of (when:whenever) reactions on in operation 
		def testAsyncLocalOutWhenIn(){
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace();
			// insert  tuple.
			def it1 := 0;
			myTS.when: aTemplate in: {
				self.assertEquals("elisa", x);
			  it1 := it1 +1;
			};
			def it2 := 0;
			myTS.whenever: aTemplate in:{
				self.assertEquals("elisa", x);
				it2 := it2 +1;
			};
			myTS.out(makeATuple());
			myTS.out(makeATuple());
			timerModule.when: 1.seconds() elapsed:{
				self.assertEquals(2, it1 + it2);
				res.resolve(`ok);
			};
		  fut;
		};
		// tests that a halloTuple with defaultPropagationProtocol gets propagated one hop
		// even if descriptor is not the same.
		def testAsyncDefaultPropagationTuple() {
			def descriptor := isolate: { def team := "red"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
				
			myTS.when: helloTemplate read: { 
				self.assertEquals(123, x);	
				s.cancel();
				a<-resolve(res); 
			};
	
			def a := actor: { |TotamTupleSpace|
				def totamModule := /.at.tuples.totam;
				def descriptor := isolate: { def team := "blue"; };	
				def aTS := totamModule.makeTupleSpace(descriptor);
			  // listen for people in the environment
				def s := whenever: TotamTupleSpace discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				// inject a tuple to neighbours
				aTS.inject: (totamModule.tuple: [123, "hallo"]);
				def resolve(res) {
					s.cancel();
					res<-resolve(`ok);
				};    		
		  };
			fut;
		};
		// test that a halloTuple with defaultPropagationProtocol has correct tupleIds.
		def testAsyncTupleIds() {
			def descriptor := isolate: { def team := "red"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := myTS.goOnline();
			def aTuple := makeATuple();
			self.assertFalse(aTuple.getTupleId().isInTupleSpace);	
			myTS.out(aTuple);
			self.assertTrue(aTuple.getTupleId().isInTupleSpace);

			def anotherTuple := makeATuple();
			myTS.out(anotherTuple);	
			// 2 diferent tuples!
			self.assertNotEquals(aTuple.getTupleId, anotherTuple.getTupleId);
			def myTsId := aTuple.getTupleId().getTupleSpaceId();
			// I should only receive once a hello tuple!
			def counter := 0;
			myTS.whenever: helloTemplate read: {
				counter := counter + 1; 
				self.assertEquals(123, x);	
				def tuple := myTS.rdp(helloTemplate);
				self.assertNotEquals(myTsId, tuple.getTupleId().getTupleSpaceId());
				timerModule.when: 2.seconds elapsed: {
					s.cancel();
					test.assertEquals(1, counter);
					a<-resolve(res);
				};
			};
			def a := actor: { |test|
				def totamModule := /.at.tuples.totam;
				import /.at.lang.futures;
				enableFutures(false);
				def helloTemplate := totamModule.tuple: [totamModule.var: `x, "hallo"];
				def descriptor := isolate: { def team := "blue"; };	
				def aTS := totamModule.makeTupleSpace(descriptor);
			  def s := aTS.goOnline();
			  // insert a tuple locally
			  def aTuple := totamModule.tuple: [123, "hallo"];
			  aTS.out(aTuple); //insert locally
			  def aTsId := aTuple.getTupleId().getTupleSpaceId();
				// inject a tuple to neighbours
				aTS.inject: (aTuple);
				def counter := 0;
				// I should only receive once a hello tuple!
				aTS.whenever: helloTemplate read: {
					counter := counter + 1; 
					test<-assertEquals(123, x);	
					def tuple := aTS.rdp(helloTemplate);
					test<-assertEquals(aTsId, tuple.getTupleId().getTupleSpaceId());
				};
				def resolve(res) {
					s.cancel();
					when: test<-assertEquals(1, counter)@FutureMessage becomes: { |val|
						res<-resolve(`ok);
					};
				};    		
		  };
			fut;
		};
		// tests that a hallo tuple with a custom "one hop" propagation protocol works.
		def testAsyncOneHopTuple() {
			def descriptor := isolate: { def team := "blue"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
				
			myTS.when: helloTemplate read: {
				self.assertEquals(123, x);	
				s.cancel();
				a<-resolve(res);
			};
	
			def a := actor: { |TotamTupleSpace|
				def totamModule := /.at.tuples.totam;
			  def descriptor := isolate: { def team := "blue"; };
			  def aTS := totamModule.makeTupleSpace(descriptor);
			  // listen for neighbour ts
				def s := whenever: TotamTupleSpace discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				def oneHopProtocol := totamModule.propagationProtocol: {
					 def hops := 0;
					 def inScope(ts) {hops <2};
					 def changeTupleContent(ts) { hops := hops + 1; self};
				};
				def oneHopTuple := totamModule.tuple: [123, "hallo"] withPropagationProtocol: oneHopProtocol;
				aTS.inject: oneHopTuple;
				//method trigering the end of test 
				def resolve(res) {
					s.cancel();
					// actor a should also have the hallo tuple because he is also in scope of this tuple
					def tuple := aTS.rdp(totamModule.tuple: [123, "hallo"]);
					if: (nil != tuple) then: { res<-resolve(`ok);}
				  else:{ res<-ruin(/.at.exceptions.error("one-hop tuple not found in ts " + aTS))};

				};	
		  };		
			fut;
		};
		// tests that a hallo tuple with a custom propagation protocol targeting blue players.
		// As sender of the tuple is from the red team, it shouldn't get it.
		def testAsyncOnlyBluePlayersTuple() {
			def descriptor := isolate: { def team := "blue"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
			myTS.when: helloTemplate read: {
				self.assertEquals(123, x);	
				s.cancel();
				a<-resolve(res);
			};
			def a := actor: { |TotamTupleSpace, blueProtocol|
				def totamModule := /.at.tuples.totam;
				def descriptor := isolate: { def team := "red"; };
				def aTS := totamModule.makeTupleSpace(descriptor);
				def s := whenever: TotamTupleSpace discovered: { |ts|
						aTS.notifyTSDiscovered(ts);
				};
				def ablueTuple := totamModule.tuple: [123, "hallo"] withPropagationProtocol: blueProtocol;
				aTS.inject: ablueTuple;
				def resolve(res) {
					s.cancel();
					//check that the tuple it is indeed not in this ts.
					def tuple := aTS.rdp(totamModule.tuple: [123, "hallo"]);
					if: (nil == tuple) then: {res<-resolve(`ok);}
					else:{ res<-ruin(/.at.exceptions.error("tuple received by a ts out of the tuple's scope!"))}
				};
	  	};		
			fut;
		};
    // tests that a halloTuple with defaultPropagationProtocol is injected with a timeout.
    // actor b is only online after the halloTuple is expired, so it shouldn't get it. 
		def testAsyncInjectWithLeaseFor() {
			def descriptor := isolate: { def team := "blue"; };
			def [fut,res] := makeFuture();
			def [fut2,res2] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
      // install listener to read a hello tuple.
			myTS.when: helloTemplate read: {
				self.assertEquals(123, x);
			};
			when: fut2 becomes: { |v|
				s.cancel();
			  a<-resolve(res);
			};
			def b := actor: { |TotamTupleSpace, res2|
				def totamModule := /.at.tuples.totam;
				def descriptor := isolate: { def team := "blue"; };
				def myTS := totamModule.makeTupleSpace(descriptor);
				def goOnline(){
				  def sub := export: myTS.getRemoteInterface as: TotamTupleSpace;
				  /.at.support.timer.when: 2.seconds() elapsed:{
					   sub.cancel();
					   //try to read the tuple sent by a) which should have expired by now!
						 def tuple := myTS.rdp(totamModule.tuple: [123, "hallo"]);
						 if: (nil == tuple) then: { res2<-resolve(`ok);}
					   else: { res2<-ruin(/.at.exceptions.error("tuple found in ts " + myTS))};
				  };
				};
			};
			
			def a := actor: { |TotamTupleSpace, b|
				def totamModule := /.at.tuples.totam;			
				def descriptor := isolate: { def team := "red"; };
				def aTS := totamModule.makeTupleSpace(descriptor);
				def s := whenever: TotamTupleSpace discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				def blueProtocol := totamModule.propagationProtocol: {
					def inScope(descriptor) { descriptor.team == "blue" };
				};
				def ablueTuple := totamModule.tuple: [123, "hallo"] withPropagationProtocol: blueProtocol;
				aTS.inject: ablueTuple timeout: 5.seconds();
				// myTs in unit test should receive this tuple.
				// myTS in actor b goes online only once the tuple is expired.
				/.at.support.timer.when: 5.seconds() elapsed:{ b<-goOnline() };
				def resolve(res) {
					s.cancel();
					res<-resolve(`ok);
				};	
			};		
      fut;
    }; //end-testAsyncInjectWithLeaseFor
				
		def testAsyncAntiTuple(){
			def [fut,res] := makeFuture();
			def [syncFut,syncRes] := makeFuture();
			def [sync2Fut,sync2Res] := makeFuture();
			def myTS := makeTupleSpace(isolate: { def team := "blue" });
			def s := myTS.goOnline();
			def template := tuple: [var: `x, "bomb"];
		  myTS.inject: makeABlueTuple;
		  when: syncFut becomes:{ |value|
				 def tuple :=  myTS.rdp(template);
         if: (tuple == nil) then:{
	         self.fail("originator should have the bomb!");
	       } else:{
			     player<-consumeBomb();
			   };
			} catch: {
				self.fail("ruined 1st synchronization future");
			};
			when: sync2Fut becomes:{ |value|
				def tuple :=  myTS.rdp(template);
				if: (tuple != nil) then:{ 
					self.fail("originator shouldn't have the bomb either!");
				} else:{ 
					res.resolve(`ok);
					s.cancel();	
				};	
			} catch: {
				self.fail("ruined 2nd synchronization future");
			};
			def anotherPlayer := actor: {  |syncRes, sync2Res|
			  deftype TotamTupleSpace;
				def totamModule := /.at.tuples.totam;	
				def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
        //the bomb is present in the tuple space
        /.at.support.timer.when: 1.seconds() elapsed:{ 
	         def tuple :=  myTS.rdp(template);
           if: (tuple.getField(1) != 123) then:{
	 						syncRes<-ruin("anotherPlayer - read uncorrect bomb");
					 } else:{	syncRes<-resolve(`ok);};
        };
        //but now that the other player has consume it, it shouldn't be there anymore.
			  def searchForBomb(){
				  def tuple :=  myTS.rdp(template);
				  if: ( tuple != nil) then:{
					 sync2Res<-ruin("anotherPlayer shouldn't have found the bomb!");
				  } else:{
						sync2Res<-resolve(`ok);
					  s.cancel();
				  };
			  };
		  };
		  def originator := myTS;
			def player := actor: { |originator, anotherPlayer, test|
				import /.at.lang.futures;
				enableFutures(false);
				deftype TotamTupleSpace;
				def totamModule := /.at.tuples.totam;	
			  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
        def consumeBomb(){
	        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
			 	  myTS.when: template read: {
				    def tuple := myTS.rdp(template);
					  when: test<-assertEquals(123, tuple.getField(1))@FutureMessage becomes:{ |val|
					    when: originator<-atomicRemove(tuple.getTupleId)@FutureMessage becomes:{|val|
						    anotherPlayer<-searchForBomb();
					      s.cancel();
					    };
					  };
					};
				};
		  };
		  fut;
		}; //end-testAsyncAntiTuple	
		
		def testAsyncAntiTupleLeased(){
			def [fut,res] := makeFuture();
			import /.at.lang.multifutures;
			def [syncFut,syncRes] := makeMultiFuture(3);
			def [sync2Fut,sync2Res] := makeMultiFuture(2);
			def myTS := makeTupleSpace(isolate: { def team := "blue" });
			def s := whenever: TotamTupleSpace discovered: { |ts|
				myTS.notifyTSDiscovered(ts);
			};
			def se := export: myTS.getRemoteInterface as: TotamTupleSpace;
		  myTS.inject: makeABlueTuple timeout: 6.seconds();
			def originator := myTS;
			whenEach: syncFut becomes:{ |val|
			  if: (val ==1) then: { s.cancel()};	
			};
			def template := tuple: [var: `x, "bomb"];
		  whenAll: syncFut resolved:{ |value|
    	   //at this point this is the network configuration:
			   //originator: seenTS contains anotherPlayer, player
				 //player: seenTS contains originator, anotherPlayer, yetAnotherPlayer
				 //anotherPlayer: seenTS contains 0.
				 def tuple :=  myTS.rdp(template);
		     if: ( tuple == nil) then: { 
		       self.fail("originator should have the bomb!");
		     } else:{
			     self.assertEquals(123, tuple.getField(1));
			     player<-consumeBomb();
			   };
			} ruined: {
				self.fail("ruined 1st synchronization future");
			};
			whenAll: sync2Fut resolved:{ |value|
				// at this time 5 antituples are sent but yetAnotherPlayer would not propagate 
				//the antituple because it is already death
				def tuple :=  myTS.rdp(template);
				if: ( tuple != nil) then:{ 
					self.fail("originator shouldn't have the bomb either!");
				} else:{ 
					res.resolve(`ok);
					se.cancel();
				};	
			} ruined: { self.fail("ruined 2nd synchronization future") };
			
			def anotherPlayer := actor: {  |syncRes, sync2Res, TotamTupleSpace|
				def totamModule := /.at.tuples.totam;
				def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
	      def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
	      //the bomb is present in the tuple space
	      def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
	      /.at.support.timer.when: 1.seconds() elapsed:{ 
	         def tuple :=  myTS.rdp(template);
					 if: (( tuple != nil).and:{ tuple.getField(1) != 123}) then:{ 
							syncRes<-ruin("anotherPlayer - read uncorrect bomb");
					 } else:{	syncRes<-resolve(`ok) };
	      };
	      //but now that the other player has consume it, it shouldn't be there anymore.
			  def searchForBomb(){
				  def tuple :=  myTS.rdp(template);
				  if: ( tuple != nil) then:{
					 sync2Res<-ruin("anotherPlayer shouldn't have found the bomb!");
				  } else:{
						sync2Res<-resolve(`ok);
					  s.cancel();
				  };
			  };		
		  }; //end-anotherPlayer	  
			def player := actor: { |originator, anotherPlayer, test, syncRes, sync2Res, TotamTupleSpace|
				import /.at.lang.futures;
				enableFutures(false);
				def totamModule :=/.at.tuples.totam;
			  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
	      def s := export: myTS.getRemoteInterface() as: TotamTupleSpace;
	      def se := whenever: TotamTupleSpace discovered: { |ts|
					myTS.notifyTSDiscovered(ts);
				};
				def yetAnotherPlayer(){ 
					actor: {
					  deftype TotamTupleSpace;
						def totamModule :=/.at.tuples.totam;
					  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
		        def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
						def read(res, firstRead := true) {
							def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
						  def tuple :=  myTS.rdp(template);
						  if: (tuple == nil) then: {
							  // no tuple found
							 	if: (firstRead) then: { res<-ruin("yetAnotherPlayer should have the bomb!")} else:{ res<-resolve(`ok); };
							} else: {
								if: (tuple.getField(1) == 123) then:{
					        if: (firstRead) then: { res<-resolve(`ok) }else:{ res<-ruin("yetAnotherPlayer 2 should have the bomb!") };
					      } else:{
					  	    // if you are here is because it was not firstRead (otherwise lenght ==)
									res<-ruin("yetAnotherPlayer got uncorrect bomb!");
							  };
							};     
						 myTS;
				    };
				  }; //end-actor
			  }; //end-yetAnotherPlayer
			/.at.support.timer.when: 1.seconds() elapsed:{
			  when: syncRes<-resolve(1)@FutureMessage becomes:{ |val|
					def player := yetAnotherPlayer();
					/.at.support.timer.when: 2.seconds() elapsed:{
				    when: player<-read(syncRes, true)@FutureMessage becomes:{|playerTs|
					    se.cancel();
					    //disconnect the far reference so that the antituple cannot be sent to yetAnotherPlayer;
					    def sub := disconnect: playerTs;
						  /.at.support.timer.when: 4.seconds() elapsed:{ 
				        sub.reconnect(); 
				        /.at.support.timer.when: 1.seconds() elapsed:{player<-read(sync2Res,false)};
				      };
				    };
				  };
				}};
		    def consumeBomb(){
			   def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
				  myTS.when: template read: { 
					  def tuple :=  myTS.rdp(template);
				    when: test<-assertEquals(123, x)@FutureMessage becomes:{ |val|
					    when: originator<-atomicRemove(tuple.getTupleId)@FutureMessage becomes:{|val|
					      anotherPlayer<-searchForBomb();
					      s.cancel();
					    };
					  };
					};
			  };
			};
		  fut;
		}; //end-testAsyncAntiTupleLeased 
		
		// test that a when:in over a remote tuple works.
		// uses the same scenario that the testAsyncAntiTuple 
		def testAsyncWhenInRemote(){
			def [fut,res] := makeFuture();
			def [syncFut,syncRes] := makeFuture();
			def [sync2Fut,sync2Res] := makeFuture();
			def myTS := makeTupleSpace(isolate: { def team := "blue" });
			def s := myTS.goOnline();
			def template := tuple: [var: `x, "bomb"];
		  myTS.inject: makeABlueTuple;
		  when: syncFut becomes:{ |value|
				 def tuple :=  myTS.rdp(template);
         if: (tuple == nil) then:{
	         self.fail("originator should have the bomb!");
	       } else:{
			     player<-consumeBomb();
			   };
			} catch: {
				self.fail("ruined 1st synchronization future");
			};
			when: sync2Fut becomes:{ |value|
				def tuple :=  myTS.rdp(template);
				if: (tuple != nil) then:{ 
					self.fail("originator shouldn't have the bomb either!");
				} else:{ 
					res.resolve(`ok);
					s.cancel();	
				};	
			} catch: {
				self.fail("ruined 2nd synchronization future");
			};
			def anotherPlayer := actor: {  |syncRes, sync2Res|
			  deftype TotamTupleSpace;
				def totamModule := /.at.tuples.totam;	
				def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := export: myTS.getRemoteInterface as: TotamTupleSpace;
        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
        //the bomb is present in the tuple space
        /.at.support.timer.when: 1.seconds() elapsed:{ 
	         def tuple :=  myTS.rdp(template);
           if: (tuple.getField(1) != 123) then:{
	 						syncRes<-ruin("anotherPlayer - read uncorrect bomb");
					 } else:{	syncRes<-resolve(`ok);};
        };
        //but now that the other player has consume it, it shouldn't be there anymore.
			  def searchForBomb(){
				  def tuple :=  myTS.rdp(template);
				  if: ( tuple != nil) then:{
					 sync2Res<-ruin("anotherPlayer shouldn't have found the bomb!");
				  } else:{
						sync2Res<-resolve(`ok);
					  s.cancel();
				  };
			  };
		  };
		  def originator := myTS;
			def player := actor: { |originator, anotherPlayer, test|
				import /.at.lang.futures;
				enableFutures(false);
				deftype TotamTupleSpace;
				def totamModule := /.at.tuples.totam;	
			  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := myTS.goOnline;
        def consumeBomb(){
	        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
			 	  myTS.when: template in: {
					  when: test<-assertEquals(123, x)@FutureMessage becomes:{ |val|
						  anotherPlayer<-searchForBomb();
					    s.cancel();
					  };
					};
				};
		  };
		  fut;
		}; //end-testAsyncWhenInRemote 
	};
};