def BugFixTest := extend: /.at.unit.test.UnitTest.new("BugFixTest") with: {

  import /.at.lang.futures;
	enableFutures(false);
		
	// Tests whether the same async message can be sent multiple times.
	def testAsyncMultipleAsyncMessages() {
		def [f1, res1] := makeFuture();
		def o1 := object: {
			def m() { res1.resolve(1) };
		};
		def [f2, res2] := makeFuture();
		def o2 := object: {
			def m() { res2.resolve(2) };
		};
		def msg := <-m();
		o1 <+ msg;
		o2 <+ msg;
		when: (group: [ f1, f2 ]) becomes: { |values|
			self.assertEquals(1, values[1]);
			self.assertEquals(2, values[2]);
		};
	};
	
	// Tests whether using import in isolates still makes them pass-by-copy
	// and allows the imported methods to be invoked on the copied isolate
	def testAsyncIsolatesAndImports() {
		def i := isolate: {
			def m() { "foo" }
		};
		def j := isolate: { |i|
			import i;
		};
		def a := actor: {
			def accept(obj) { obj.m() }
		};
		when: a<-accept(j)@FutureMessage becomes: { |v|
			self.assertEquals("foo", v)
		}
	};
	
	// test following bug #49 in which the discovery actor failed
	// to access 'system' and 'lobby' slots in deserialized code
	def testAsyncDeserializationInDiscoveryActor() {
		def peer := actor: {
			def obj := object: { } taggedAs: [/.at.types.Isolate] mirroredBy: (extend: defaultMirror with: {
				def x := 5;
			  def pass() {
				  /.at.support.util.uponArrivalBecome: { |x|
					  system; // ensure we can access system and the root
					  /.at;
					  x
					}
			  }
			} taggedAs: [/.at.types.Isolate]);
			deftype DeserializationBugfixTest;
			export: obj as: DeserializationBugfixTest;
		};

		deftype DeserializationBugfixTest;
		future: { |reply|
			when: DeserializationBugfixTest discovered: { |o|
			  reply(o);
		  };
		};
	};
	
	// test whether invocation on a far ref fails with an illegal
	// operation exception
	def testAsyncInvocationOnFarRefFails() {
		(actor: {
			// ref is a far reference
			def get(ref) {
			  /.at.unit.test.UnitTest.assert: /.at.types.IllegalOperation raisedIn: { ref.m() };
		  };
		})<-get(object: { def m() { 42 } })@FutureMessage;
	};
	
	// following bug report #50, test whether an object that is parameter-passed
	// by far reference twice receives the same globally unique ID such that two
	// far references to the same object can be properly compared for equality
	def testAsyncUniqueObjectExport() {
		def peer := actor: {
			def first;
			def receive1(x) { first := x; };
			def receive2(y) { first == y };
		};
		def o := object: { };
		peer<-receive1(o);
		when: peer<-receive2(o)@FutureMessage becomes: { |answer|
			self.assertTrue(answer);
		};
	};
	
};

self