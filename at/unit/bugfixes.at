def BugFixTest := extend: /.at.unit.test.UnitTest.new("BugFixTest") with: {

  import /.at.lang.futures;
		
	// Tests whether the same async message can be sent multiple times.
	def testAsyncMultipleAsyncMessages() {
		def [f1, res1] := makeFuture();
		def o1 := object: {
			def m() { res1.resolve(1) };
		};
		def [f2, res2] := makeFuture();
		def o2 := object: {
			def m() { res2.resolve(2) };
		};
		def msg := <-m();
		o1 <+ msg;
		o2 <+ msg;
		when: (group: [ f1, f2 ]) becomes: { |values|
			self.assertEquals(1, values[1]);
			self.assertEquals(2, values[2]);
		};
	};
	
	// Tests whether using import in isolates still makes them pass-by-copy
	// and allows the imported methods to be invoked on the copied isolate
	def testAsyncIsolatesAndImports() {
		def i := isolate: {
			def m() { "foo" }
		};
		def j := isolate: { |i|
			import i;
		};
		def a := actor: {
			def accept(obj) { obj.m() }
		};
		when: a<-accept(j)@FutureMessage becomes: { |v|
			self.assertEquals("foo", v)
		}
	};
};

self