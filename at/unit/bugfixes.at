def BugFixTest := extend: /.at.unit.test.UnitTest.new("BugFixTest") with: {

  import /.at.lang.futures;
	enableFutures(false);

	// Tests whether the same async message can be sent multiple times.
	def testAsyncMultipleAsyncMessages() {
		def [f1, res1] := makeFuture();
		def o1 := object: {
			def m() { res1.resolve(1) };
		};
		def [f2, res2] := makeFuture();
		def o2 := object: {
			def m() { res2.resolve(2) };
		};
		def msg := <-m();
		o1 <+ msg;
		o2 <+ msg;
		when: (group: [ f1, f2 ]) becomes: { |values|
			self.assertEquals(1, values[1]);
			self.assertEquals(2, values[2]);
		};
	};
	
	// Tests whether using import in isolates still makes them pass-by-copy
	// and allows the imported methods to be invoked on the copied isolate
	def testAsyncIsolatesAndImports() {
		def i := isolate: {
			def m() { "foo" }
		};
		def j := isolate: { |i|
			import i;
		};
		def a := actor: {
			def accept(obj) { obj.m() }
		};
		when: a<-accept(j)@FutureMessage becomes: { |v|
			self.assertEquals("foo", v)
		}
	};
	
	// test following bug #49 in which the discovery actor failed
	// to access 'system' and 'lobby' slots in deserialized code
	def testAsyncDeserializationInDiscoveryActor() {
		def peer := actor: {
			def obj := object: { } taggedAs: [/.at.types.Isolate] mirroredBy: (extend: defaultMirror with: {
				def x := 5;
			  def pass() {
				  /.at.support.util.uponArrivalBecome: { |x|
					  system; // ensure we can access system and the root
					  /.at;
					  x
					}
			  }
			} taggedAs: [/.at.types.Isolate]);
			deftype DeserializationBugfixTest;
			export: obj as: DeserializationBugfixTest;
		};

		deftype DeserializationBugfixTest;
		future: { |reply|
			when: DeserializationBugfixTest discovered: { |o|
			  reply(o);
		  };
		};
	};
	
	// test whether invocation on a far ref fails with an illegal
	// operation exception
	def testAsyncInvocationOnFarRefFails() {
		(actor: {
			// ref is a far reference
			def get(ref) {
			  /.at.unit.test.UnitTest.assert: /.at.types.IllegalOperation raisedIn: { ref.m() };
		  };
		})<-get(object: { def m() { 42 } })@FutureMessage;
	};
	
	// following bug report #50, test whether an object that is parameter-passed
	// by far reference twice receives the same globally unique ID such that two
	// far references to the same object can be properly compared for equality
	def testAsyncUniqueObjectExport() {
		def peer := actor: {
			def first;
			def receive1(x) { first := x; };
			def receive2(y) { first == y };
		};
		def o := object: { };
		peer<-receive1(o);
		when: peer<-receive2(o)@FutureMessage becomes: { |answer|
			self.assertTrue(answer);
		};
	};
	
	// tests whether fields and methods with the same name cannot
	// co-exist within the same object (bug #51)
	def testFieldMethodDuplicates() {
		self.assert: /.at.types.DuplicateSlot raisedIn: {
			object: { def m; def m(); }
		}
	};

	def testAsyncSymbioticFutures() {
		def [testF,testR] := makeFuture();
		jlobby.at.unit.SymbioticFuturesTest.test(object: {
			import /.at.support.timer;
			def access() {
				def [f,r] := makeFuture();
				when: seconds(3) elapsed: {
					r.resolve(1);
				};
				f;
			}
		}, object: {
			// this method is invoked when the SymbioticFuturesTest has the resolved
			// value for the future
			def run() {
				testR.resolve(`ok);
			}
		});
		testF;
	};
	
	def testAsyncFutureTypeSymbioticInvocations() {
		def [testF,testR] := makeFuture();
		jlobby.at.unit.SymbioticFuturesTest.testFuture(object: {
			import /.at.support.timer;
			def accessFuture(x) {
				def [f,r] := makeFuture();
				when: seconds(3) elapsed: {
					r.resolve(x+1);
				};
				f;
			}
		}, object: {
			// this method is invoked when the SymbioticFuturesTest has the resolved
			// value for the future
			def run() {
				testR.resolve(`ok);
			}
		});
		testF;
	};
	
	/* test whether futures work on unannotated messages when enabling them by default */
	def testAsyncDefaultFutures() {
		def [f,r] := /.at.lang.futures.makeFuture();
		def a := actor: { |r|
			import /.at.lang.futures;
			enableFutures(true);
			
			def obj := object: { def m() { 5 } };
			when: obj<-m() becomes: { |x|
			  r<-resolve(x);
			};
		};
		f
	};
	
	/* test whether a single message can be sent multiple times and that
	 * each message send carries its own, independently resolvable future.
	 */
	def testAsyncFuturePerSend() {
		def msg := <-m()@FutureMessage;
		def rcvr := object: {
			def count := 0;
			def m() { count := count + 1 };
		};
		def sync1 := when: (rcvr <+ msg) becomes: { |val|
			self.assertEquals(1, val);
		};
		def sync2 := when: (rcvr <+ msg) becomes: { |val|
			self.assertEquals(2, val);
		};
		group: [sync1, sync2]
	};
	
	/**
	 * Tests the new slot-based reflective interface defined on mirrors.
	 */
	def testSlotbasedReflection() {
		def o := object: {
			def x := 5;
			def y() { 6 };
			def sum(x,y) { x + y };
		};
		
		def m := (reflect: o);
		
		// [super, super:=, x, x:=, y, sum]
		self.assertEquals(6, m.listSlots.length);
		
		def xAccessor := m.grabSlot(`x);
		def xMutator := m.grabSlot(`x:=);
		
		def ctx := /.at.lang.values.createContext(o, o);
		
		// o.x == 5
		self.assertEquals(5, xAccessor.apply([],ctx));
		// o.x := 1
		self.assertEquals(1, xMutator.apply([1],ctx));
		// o.x == 1
		self.assertEquals(1, xAccessor.apply([],ctx));

		def [acc, mut] := /.at.lang.values.createFieldSlot(`foo, 7);
		// def o.foo() { 7 }		
		m.addSlot(acc);
		// [super, super:=, x, x:=, y, sum, foo]
		self.assertEquals(7, m.listSlots.length);
		
		def fooAccessor := m.grabSlot(`foo);
		// o.foo == 7
		self.assertEquals(7, o.foo);
		
		// def o.foo:=(v) { foo := v }
		m.addSlot(mut);
		o.foo := 10;
		// o.foo == 10
		self.assertEquals(10, o.foo);
		
		// o.foo := 8
		m.invoke(o, /.at.lang.values.createInvocation(`foo:=, [8], []));
		// o.foo == 8
		self.assertEquals(8, o.foo);
	};
	
	/**
	 * Tests the new slot-based reflective interface on mirrors of mirages.
	 */
	def testSlotbasedReflectionOnMirages() {
		def o := object: {
			def x := 5;
			def y() { 6 };
			def sum(x,y) { x + y };
		} mirroredBy: (extend: defaultMirror with: {
			
			// automatically removes super/super:= from the list
			def listSlots() {
				def slots := super^listSlots();
				slots.filter: { |slot| !((slot.name == `super).or: { slot.name == `super:= }) };
			};
			
		});
		
		def m := (reflect: o);
		
		// [x, x:=, y, sum]
		self.assertEquals(4, m.listSlots.length);
		
		def xAccessor := m.grabSlot(`x);
		def xMutator := m.grabSlot(`x:=);
		
		def ctx := /.at.lang.values.createContext(o, o);
		
		// o.x == 5
		self.assertEquals(5, xAccessor.apply([],ctx));
		// o.x := 1
		self.assertEquals(1, xMutator.apply([1],ctx));
		// o.x == 1
		self.assertEquals(1, xAccessor.apply([],ctx));

		def [acc, mut] := /.at.lang.values.createFieldSlot(`foo, 7);
		// def o.foo() { 7 }		
		m.addSlot(acc);
		// [x, x:=, y, sum, foo]
		self.assertEquals(5, m.listSlots.length);
		
		def fooAccessor := m.grabSlot(`foo);
		// o.foo == 7
		self.assertEquals(7, o.foo);
		
		// def o.foo:=(v) { foo := v }
		m.addSlot(mut);
		o.foo := 10;
		// o.foo == 10
		self.assertEquals(10, o.foo);
		
		// o.foo := 8
		m.invoke(o, /.at.lang.values.createInvocation(`foo:=, [8], []));
		// o.foo == 8
		self.assertEquals(8, o.foo);
	};
	
	/**
	 * Tests whether one can add and remove slots to an object dynamically.
	 */
	def testSlotRemoval() {
		def o := object: { def x := 1; def m() { x } };

		self.assertEquals(1, o.x);
		self.assertEquals(1, o.m);
		self.assertEquals(1, (reflect: o).removeSlot(`x));
		
		// test that x is no longer present
		self.assert: /.at.types.SelectorNotFound raisedIn: { o.x };
		// even when accessed from within a method
		self.assert: /.at.types.UndefinedSlot raisedIn: { o.m };

		def [acc,mut] := /.at.lang.values.createFieldSlot(`x, 5);
		(reflect: o).addSlot(acc);

		self.assertEquals(5, o.m);

		(reflect: o).addSlot(mut);
		o.x := 6;
		self.assertEquals(6, o.m);
		(reflect: o).removeSlot(`x);

		(reflect: o).addSlot(acc);
		(reflect: o).removeSlot(`x:=);
		self.assertEquals(6, o.m);
	};
	
	// tests whether the functor: construct defined in init.at works
	def testFunctor() {
		def f := functor: { def x := 1; def run(y) { x + y } };
		self.assertEquals(6, f(5));
	};
	
	def testDiamondImport() {
		def A := object: {
			def a() { "A" };
			def d() { "D" };
		};
		def B := object: {
			import A;
			def b() { "B" };
		};
		def C := object: {
			import A;
			def c() { "C" };
		};
		def D := object: {
			import B alias d := e;
			import C alias d := e;
		};
		self.assertEquals("A", D.a());
		self.assertEquals("B", D.b());
		self.assertEquals("C", D.c());
		self.assertEquals("D", D.e());
		self.assertFalse((reflect: D).respondsTo(`d));
	};
	
	def testConflicts() {
		def A1 := object: {
			def a() { "A1" };
		};
		def A2 := object: {
			def a() { "A2" };
		};
		def B := object: {
			import A1;
			def b() { "B" };
		};
		def C := object: {
			import A2;
			def c() { "C" };
		};
		self.assert: /.at.types.ImportConflict raisedIn: {
			def D := object: {
				import B;
				import C; // A2's a conflicts with A1's a
			}
		};
	};
	
	// test whether methods tagged as @Required are not included in the composite
	def testRequiredMethodsAreFiltered() {
		def T := object: {
			def m() { self.n() };
			def n() @[/.at.types.Required];
		};
		def o := object: {
			import T;
		};
		self.assertFalse((reflect: o).respondsTo(`n));
		
		def o2 := object: {
			import T;
			def n() { 42 };
		};
		self.assertEquals(42, o2.m());
	};
	
	def testMirageMirroredByIntrospectiveMirror() {
		def nativeObj := object: { };
		def newMirage := object: { def m() { 42 } } mirroredBy: (reflect: nativeObj);
		self.assertEquals(42, newMirage.m());
	};
	
};

self