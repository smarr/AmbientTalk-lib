def CrimeFactory := jlobby.edu.vub.crime.CrimeFactory;
def ExpressionFactory := jlobby.edu.vub.crime.grammar.ExpressionFactory;
def GenericFact := jlobby.edu.vub.crime.grammar.GenericFact;
def ExpressionList := jlobby.edu.vub.crime.grammar.ExpressionList;
def Event := jlobby.edu.vub.crime.grammar.Event;
def AmbientTalkAction := jlobby.edu.vub.crime.AmbientTalkAction;
def IndexingVisitor := jlobby.edu.vub.crime.parser.IndexingVisitor;
import /.at.exceptions;

def isJavaObject(o) {
	((reflect: o).listMethods.map: { |e| e.name }).contains(`getClass);
};

def newEvent(act,deact,vars) {

	def mapArguments(args) {
		def argmap := jlobby.java.util.HashMap.new();		
		def it := vars.iterator;
		def i := 0;
		while: { it.hasNext } do: {
			def var := it.next;
			argmap.put(var.toString(), args.get(i));
			i := i +1;
		};

		object: {
			def get(literal) {
				//UGLY UGLY UGLY 
				//Reason I can't seem to convert a string to literal so I have to do it the otherway around
				//+ The getName of a variable puts a ?
				argmap.get("?"+literal.text());
			};
		};
	};

	Event.new(
	AmbientTalkAction.new(
		isolate: {
			def getClass() { jlobby.edu.vub.crime.Action };
			def activated(args){ 		
				act(mapArguments(args)); 
			};
			def deactivate(arguments){ 
				deact(arguments); 
			}; 
	}));
};

def convertTupleToCrimeFact(tuple) {
	def newFact := GenericFact.new( "private" , tuple.getField(1) );
	def theIndexer :=  IndexingVisitor.new(newFact);

	def index := 1;
	tuple.each: { |f|
		if: isJavaObject(f) then: {
			//its a variable so we don't need to make it into an argument anymore
			theIndexer.nextAttribute(f);
		} else: {
			//its a constant and will be converted anyway by the coercer :)
			def attr := ExpressionFactory.attribute(f);
			theIndexer.nextAttribute(attr);
		};
	};
	newFact;
};

def packRule(table,act,deact) {
	isolate: { |table,act,deact|
		def getTable() {table};
		def getAct() {act};
		def getDeact() {deact};
	};
};

def makeRule(table,act,deact) {
	def prerequisite := ExpressionList.whichAcceptsFacts();
	def consequence := ExpressionList.whichAcceptsFactsAndEvents();
	table.each: {|e| prerequisite.add(convertTupleToCrimeFact(e)); };
	def vars := prerequisite.variables;
	def it := vars.iterator;
	def event := newEvent(act, deact,vars);
	while: { it.hasNext } do: {
		event.addAttribute(it.next);
	};
	consequence.add(event);
	ExpressionFactory.rule(consequence, prerequisite);
};

def makeTemplate(@fields) {
	isolate: {
	def length(){ fields.length };
	def getField(n) { fields[n] };
	def match(t1) {
		if: (t1.length == self.length) then: {
			def it := 1;
			def result := true;
			fields.each: {|e2| 
				def e1 := t1.getField(it); 
				result := result.and: { e1 = e2 };
				it := it +1; 
			};
			result;
		} else: {
			false;
		};
	};
	
	def each: l  {
		fields.each: l;
	};
	};
};

def makeTuple(@fields) {
	fields.each: { |e|
		if: isJavaObject(e) then: {
			error("Attempt to create a tuple with a variable !"); 
		};
	};
	makeTemplate(@fields);
};

def makeCrimeEngine() { 
	
	//create new engine;
	def engine := CrimeFactory.createEngine();
	
	//public interface of a crime engine.
	object: {
    def insertTuple(tuple) {
	    engine.assert(convertTupleToCrimeFact(tuple));
    };

    def retractTuple(tuple) {
	    engine.retract(convertTupleToCrimeFact(tuple));
    };

    def when: table activated: act {
	    when: table activated: act deactivated: {|args| nil};
    };

    def when: table activated: act deactivated: deact {
	    def rule :=  makeRule(table,act,deact);
	    engine.deploy(rule);
	    isolate: { 
		    def cancel() {
			    engine.undeploy(rule);
		    };
	    };
    };
  };
};

def CrimeModule := object: {
	
	def makeCrimeEngine := &makeCrimeEngine;
	def makeTuple := &makeTuple;
	def makeTemplate := &makeTemplate;
	def var: symbol {
		ExpressionFactory.variable(symbol.text);	
	};
		
	def CrimeTest := extend: /.at.unit.test.UnitTest.new("Crime", false) with: {
		import /.at.lang.futures;
		enableFutures(false);
		def myCrime := makeCrimeEngine();
		
		def testAsyncActivacte() {
			def t1 := makeTemplate("GPS", var: `x, 3);
			def t2 := makeTemplate("GPS", 3, var: `x);				
			def [fut,res] := makeFuture();
			
			myCrime.when: [t1, t2] activated: {|args|
				def x := args.get(`x).toString;	
				res.resolve(x);
			} deactivated: { |args|
				
			};
			def shouldTrigger := makeTuple("GPS", 3, 3);
			myCrime.insertTuple(shouldTrigger);
			myCrime.retractTuple(shouldTrigger);
			when: fut becomes: { |value|
				self.assertEquals("3", value);	
			};
		};
		
		def testAsyncSendRule() {
			def [fut,res] := makeFuture();
			def t1 := makeTemplate("GPS", var: `x, 3);
			def t2 := makeTemplate("GPS", 3, var: `x);
			
			def a := actor: {
				import /.at.crime.CrimeConnection;
				def myCrime := makeCrimeEngine();
				
				def doOperation(rule,res) {				
					myCrime.when: rule.getTable() activated: {|args|  
						rule.getAct()(args,"cool on actor a activated"); 
					};
					
					def shouldTrigger := makeTuple("GPS", 3, 3);
					myCrime.insertTuple(shouldTrigger);
					res.resolve(nil);
				};
			};

			def packedRule := packRule([t1, t2], script: { |args,ma| system.println("<a:: >"+ma); }, script:{ |args,md| system.println("<d:: >"+md);});
			a<-doOperation(packedRule,res);	
			fut;
		};
	};
};