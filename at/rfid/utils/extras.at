// unless
def unless: test then: closure {
	if: !test then: closure;
};

// export an object for each tag it sports
def autoExport(someObject) {
	(tagsOf: someObject).each: {|tt|
		export: someObject as: tt;
	};
};


// closure with typetags
def isolate: closure taggedAs: tagTable {
	object: closure taggedAs: [/.at.types.Isolate] + tagTable;
};

// check if methods is annotated with a given typetag
def is: someMethod annotatedAs: someAnnotation {
	someMethod.annotations.contains(someAnnotation);
};

// support for mutator methods
deftype Mutator;
def Types := /.at.types;

def mutatorsOf: someObject {
	(reflect: someObject).listMethods.select: {|m|
		is: m annotatedAs: Mutator;
	};
};

def is: methodName mutatorOf: someObject {
	try: {
		is: (reflect: someObject).grabMethod(methodName) annotatedAs: Mutator;
	} catch: Types.SelectorNotFound using: {|e| false };
};

// a try:catch: method without that catches any exception
def try: closure catchUsing: failClosure {
	try: closure catch: Types.Exception using: { |e| failClosure(e) };
};

def pwd() {
	def ns := (print: ~);
	ns.explode.select(5,ns.length()).implode;
};

def AT_HOME := jlobby.java.lang.System.getProperty("AT_HOME");

// debug and info methods
def DEBUG := false;
def INFO  := true;

def debug(str) {
	if: (DEBUG) then: {
		system.println("[DEBUG] " + str);
	};
};

def info(str) {
	if: (INFO) then: {
		system.println("[INFO] " + str);
	};
};

self;