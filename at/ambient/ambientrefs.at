/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* This module implements revised ambient references where message delivery
 * policies are expressed at the messaging level rather than at the
 * reference level.
 *
 * An ambient reference is a time, synchronisation and space-decoupled reference.
 * It extends far references with anonymous and group communication.
 *  
 * An ambient reference does not refer to one specific object, but rather
 * to a set of objects, known as its range. The range can be described
 * by means of a type tag (and optionally a filter)
 *
 * Messages can be sent to one or all objects in range.
 * Messages can be buffered such that they can be sent to objects
 * that enter the ambient reference's range at a later point in time.
 * Such buffered messages can be annotated with an expiration period
 * such that they can be eventually removed.
 *
 * An ambient reference can be considered a little publish/subscribe
 * engine of its own. The reference can be used by objects to
 * publish messages into the environment. In order to receive such
 * messages, objects must register themselves by declaring themselves
 * to be 'in range' of the appropriate ambient reference.
 *
 * An Ambient Reference denotes an abstract set of objects:
 * - intensional set: (type tag | protocol) + filter closure
 * - extensional set: table of far references
 *
 * It supports different kinds of messaging strategies:
 * - message arity:
 *  - @One: choose a single receiver from the set, returns future [default]
 *  - @All: broadcast msg to all receivers in set, returns multifuture
 * - message lifetime:
 *  - @Instant: potential receivers are the current principals only,
 *     if no match message is lost.
 *  - @Transient(timeout): potential receivers are current principals +
 *     all principals in scope between now and the timeout period.
 *     If no match, buffer message until timeout.
 *  - @Durable: potential receivers are the current principals or any other principal
 *     joining later. Message can be retracted explicitly via its future. [default]
 * - message reply destination:
 *  - @Future: attaches a future to the message to consume result(s) [default]
 *  - @Oneway: no return values are required
 *  - @Due(timeout): attaches a future to the message which, after it has been sent
 *    to one or more receivers, may time out. Note that the timeout period only starts
 *    when the message has an actual receiver, not when it is sent to the AR itself.
 *
 *  - @Expires(timeout): a combination of @Transient(timeout) and @Due(timeout)
 *    But not the same as just combining these. It sets the timeout period of each outgoing
 *    message to (timeout - (time_transmitted - time_sent)), meaning that the longer it
 *    took to discover a receiver, the less time the future gets to wait for the reply.
 *
 * Defaults can be changed at the reference level.
 *
 * Useful operations:
 * - snapshot: AR -> table of far refs
 *
 * Objects are exported:
 * - by Type or protocol
 * - by Type or protocol with properties
 *
 * To be investigated:
 * - dealing with the 'retraction object': how to pass it to the sender?
 * - dealing with 'dropped' or 'lost' messages: e.g. @Instant + @Future and no one in range -> ?
 * - allow ARs composed of both an extensional and an intensional set
 * - for @One messaging, consider a ranking policy to determine the most
 *   'suitable' service in range.
 * - a union operator: AR(R1) + AR(R2) -> AR(R1 U R2)
 * - a 'metaobject protocol' to enable custom attributes
 *
 * @author tvcutsem
 */

def FuturesModule := /.at.lang.futures;
def MFuturesModule := /.at.lang.multifutures;
def Vector := /.at.collections.vector.Vector;
def Util := /.at.support.util;
def OneWayMessage := FuturesModule.OneWayMessage;

import /.at.support.timer;
import /.at.lang.firstclassrefs;
//import /.at.m2mi.api;
import /.at.ambient.discovery;

FuturesModule.enableFutures(false); // enable futures for explicitly tagged messages

def log := /.at.support.logger.makeLogger("[ambientrefs.at]", /.at.support.logger.DEBUG);
def debug(text) {
	log(text, /.at.support.logger.DEBUG)
};

deftype ARAnnotation;

deftype MsgArity <: ARAnnotation;
deftype One <: MsgArity;
deftype All <: MsgArity;

deftype MsgLifetime <: ARAnnotation;
deftype Instant <: MsgLifetime;
deftype TransientT <: MsgLifetime;
deftype Durable <: MsgLifetime;

def Transient(period) {
	extend: TransientT with: { |period|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype MsgReplyAddress <: ARAnnotation;
deftype Future <: MsgReplyAddress;
deftype DueT <: MsgReplyAddress;
deftype Oneway <: MsgReplyAddress;

def Due(timeout) {
	extend: DueT with: { |timeout|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype Expirable <: TransientT, DueT;
def Expires(timeout) {
	extend: Expirable with: { |timeout|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype AmbientRef;

deftype PropertyObjectT;
def PropertyObject := object: {
	def service;
	def properties;
	def init(svcObject, props) {
		service := svcObject;
		properties := props;
	};
	def ==(other) {
		(does: other respondTo: `service).and: { service == other.service };
	};
} taggedAs: [/.at.types.Isolate, PropertyObjectT];

/*def signalTimeout(msg) {
	if: (does: msg respondTo: `future) then: {
		(msg.future)<-ruinWithException(
			FuturesModule.XTimeoutException.new(msg.future))@[OneWayMessage,MetaMessage];
	}
};*/

// a dropped message exception is a special kind of timeout exception
// that guarantees the caller that no 'orphan computations' can exist
// because the message was never sent in the first place
deftype MessageDropped <: FuturesModule.TimeoutException;
def XMessageDropped := /.at.exceptions.createException(MessageDropped);
def signalDropped(msg) {
	if: (does: msg respondTo: `future) then: {
		(msg.future)<-ruinWithException(
			XMessageDropped.new("message dropped: "+msg.selector))@[OneWayMessage,MetaMessage];
	}
};

def makeAmbientReference(extensionalRange,
	                       Type,
	                       filter,
	                       defaultArity,
	                       defaultLifetime,
	                       defaultReply) {
	object: {
		
		// alternative to using mirages to trap async messages:
		// use higher order messaging
		/*def toAll: asyncMsg expires: period reply: due {
			
		}*/
		
	} taggedAs: [ AmbientRef ] mirroredBy: (mirror: {

    import TFarRef;
    import TObservable;

    def range := extensionalRange;

    def init(base) {
	    super^init(base);
	    // create two types of observers: those for service discovery
	    // and those for service loss
	    TObservable^init(`discovered, `lost);
	
	    // TODO: should we perform service discovery when the range
	    // was given as an extensional set?
	    // TODO: also take the hidden 'recall period' of a service tracker into account
	
	    // when the correct mirror is instantiated, start the service discovery
			whenever: Type discovered: { |uniref|
				
				debug("whenever:discovered: discovered uniref " + uniref);
				
				def service := uniref;
				def props := isolate: { };
				if: (is: uniref taggedAs: PropertyObjectT) then: {
					service := uniref.service;
					props := uniref.properties;
				};
				
				if: filter(props) then: {
					// add the discovered service to the AR's range
					debug("whenever:discovered: service added to range: " + service);
					range := range + [service];

					// notify when:discovered: observers
					self.notify: self.observerCatalog.discovered withArgs: [service];	
				};
			};

			whenever: Type lost: { |uniref|
				debug("whenever:lost: lost uniref " + uniref);
				def service := uniref;
				def props := isolate: { };
				if: (is: uniref taggedAs: PropertyObjectT) then: {
					service := uniref.service;
					props := uniref.properties;
				};
				
				if: filter(props) then: {			
					// remove the lost service from the AR's range
					debug("whenever:lost: service removed from range: " + service);
					range := range.filter: { |ref| !(ref == service) };
					
					// remove all unacknowledged messages from the far ref's native
					// outbox, chances are high these messages are lost, but it might
					// be that they were delivered, so sticking with at-most-once semantics
					// requires that we drop the message
					def out := retract: service;
					debug("whenever:lost: retracting and dropping messages from service " + service +": "+out);
					
					// notify when:lost: observers
					self.notify: self.observerCatalog.lost withArgs: [service];
				};
			};
    };

    // add when: adaptor discovered: { |ref| ... } observer
    def addDiscoveryObserver(obs) {
	    self.addObserver: obs to: self.observerCatalog.discovered;
    };

    // add when: adaptor lost: { |ref| ... } observer
    def addLossObserver(obs) {
	    self.addObserver: obs to: self.observerCatalog.lost;
    };

    def makeSnapshot() { range };

		// == provide required methods for TFarRef trait ==
		
		def intercept(message) {
			// perform case analysis
			
			// ideally, we just ask the message to process itself given our state
			// msg already pre-processed case-analysis using partial evaluation
			// msg.acceptedBy(self)
			def handler;
			if: (does: message respondTo: `handler) then: {
				handler := message.handler;
			} else: {
				handler := makeMessageHandlerFor(extend: msg with: {} taggedAs:
					[defaultArity,defaultLifetime,defaultReply]);
			};
			
			// TODO: how can we pass this retractionObject to the caller?
			// via future is not an option, e.g. @One@Durable@Oneway -> no future attached
			// to the message
			// also, def [fut,reg] := o<-m()@[One,Durable,Oneway] does not work either
			// because Oneway does not 'return' a future, unless then [nil,reg] is returned?
			def retractionObject := handler.receivedBy(self);
		};
		
			/*def msgArity;			
			if: (is: msg taggedAs: One) then: {
				msgArity := One;
			} else: {
				if: (is: msg taggedAs: All) then: {
					msgArity := All;
				} else: {
					msgArity := defaultArity;
				}
			};
			
			def msgLifeTime;
			if: (is: msg taggedAs: Transient) then: {
				msgLifeTime := Transient;
			} else: {
				if: (is: msg taggedAs: Expirable) then: {
					msgLifeTime := Util.getAnnotationOfType(msg, Expirable);
				} else: {
					if: (is: msg taggedAs: Durable) then: {
						msgLifeTime := Durable;
					} else: {
						msgLifeTime := defaultLifetime;
					}
				}
			};
			
			debug(self.print + " <- " + msg.selector + "[A: "+msgArity.typeName+",L: "+msgLifeTime.typeName+"]");
			
			if: (msgArity == One) then: {
				if: (range.length > 0) then: {
					// send the message to the first available service
					debug("sending @One msg " + msg.selector + " to " + range[1]);
					range[1] <+ msg;
					// don't queue the message
				} else: {
					if: !(msgLifeTime == Transient) then: {
						debug("queueing @One msg " + msg.selector + " in uniOutbox");
						uniOutbox := uniOutbox + [msg];
						if: (msgLifeTime == Expirable) then: {
							when: msgLifeTime.timeout elapsed: {
								debug("removing @One msg " + msg.selector + " from uniOutbox");
								uniOutbox := uniOutbox.filter: { |m| !(m==msg) };
								signalTimeout(msg);
							}
						} // else msgLifeTime == DURABLE
					} else: {
						// @One, @Transient and no one in range -> message is dropped
						signalDropped(msg);
					};
				}
			} else: { // else msgArity == ALL
				range.each: { |receiver|
					debug("sending @All msg " + msg.selector + " to "+receiver);
					receiver <+ msg };
				if: !(msgLifeTime == Transient) then: {
					debug("queueing @All msg " + msg.selector + " in omniOutbox");
					omniOutbox := omniOutbox + [msg];
					if: (msgLifeTime == Expirable) then: {
						when: msgLifeTime.timeout elapsed: {
							debug("removing @All msg " + msg.selector + " from omniOutbox");
							omniOutbox := omniOutbox.filter: { |m| !(m==msg) };
							signalTimeout(msg);
						}
					} // else msgLifeTime == DURABLE
				};
			};*/	
	
		def toString() {
		  "ambient:"+Type.typeName+"(#"+range.length+")";
		};
	
		def transportStrategy := { |range,Type,filter,defaultArity,defaultLifetime,defaultReply|
			// when arriving at the remote host, create a new local ambient reference
			/.at.ambient.ambientrefs.ambient: Type
															 where: filter
															 withArity: defaultArity
															 withLifetime: defaultLifetime
															 withReply: defaultReply
															 initWith: range;
															
		};
	})
};

// Trait hierarchy
// OR should be implemented using either delegation or composite traits
// AND should be implemented using double dispatch

/*in intensional ambientref Type: {
	def range;
	def when: ar discovered: clo {
		whenever: Type discovered: clo // + filter, keeping track of lost objs etc.
	}
};

in extensional ambientref rng: {
	def range := rng;
	def when: ar discovered: clo {
		object: { def cancel() { true } }
	}
};*/

//in message with reply DUE:
def makeDueReplyTrait(initDuePeriod) {
	object: {
		import makeFutureDueReplyTrait();
		
		def duePeriod := initDuePeriod;
		def sendMessage(rcvr) {
			// msg contains future, which is either resolved|ruined with reply
			// or times out if @Due or @Expires was specified

		  // due time should only start when message is sent to an actual receiver
			// multifutures need to know whose replies to ban! Otherwise, we might report
			// a timeout AND a value of a receiver in the final multifuture
			debug("[sendMessage (DUE)]: sending "+self.message.selector+" to "+rcvr);
			when: self.duePeriod elapsed: {
				debug("[sendMessage (DUE)]: "+self.message.selector+" timed out");
				self.message.future<-timeout(rcvr, self.message)@MetaMessage;
			};
			rcvr <+ self.message;
		};
		def allMessagesSent() {
		  // notify unbounded multifutures that they should consider
		  // themselves totally resolved
			debug("[allMessagesSent (DUE)]: all "+self.message.selector+" msges sent, starting closing timer");
		  when: self.duePeriod elapsed: {
				debug("[allMessagesSent (DUE)]: all "+self.message.selector+" sent, closing multifuture, if any");
			  self.message.future<-becomeResolved()@MetaMessage;		
		  }
		};		
	}
};

//in message with reply FUTURE | DUE:
def makeFutureDueReplyTrait() {
	object: {
		def attachFutureToMessage(msg) {
			def [fut,res] := self.createFuture();
			debug("[attachFutureToMessage]: creating future for "+msg.selector+": "+fut);
			FuturesModule.futurize(msg, fut, FuturesModule.FutureMessage);	
		}
	}
};

//in message with reply ONEWAY | FUTURE:
def makeOnewayFutureReplyTrait() {
	object: {
		def sendMessage(rcvr) {
			debug("[sendMessage (ONEWAY|FUTURE)]: sending "+self.message.selector+" to "+rcvr);
			rcvr <+ self.message; // TODO: message MUST include future for this to work with @Future!!
		};
		def allMessagesSent() { };
	}
};

//in message with reply FUTURE:
def makeFutureReplyTrait() {
	object: {
		import makeFutureDueReplyTrait();
		import makeOnewayFutureReplyTrait();
	}
};

//in message with reply ONEWAY:
def makeOnewayReplyTrait() {
	object: {
		import makeOnewayFutureReplyTrait();
		def attachFutureToMessage(msg) { msg };
	}
};

//in message with arity ONE:
def makeOneArityTrait() {
	object: {
		def createFuture() { FuturesModule.makeFuture() };
		def sendTo: ar ifNoneInRange: code {
			if: (ar.range.length == 0) then: code else: {
				debug("[sendTo:ifNoneInRange: (ONE)]: sending "+self.message.selector + " to a rcvr in range");
				self.sendMessage((ar.range)[1]);
			};
		};
		def sendAndDiscover(ar) {
			// if the single message could be delivered to an object in range,
			// no retraction is necessary
			def registration := object: { def cancel() { false } };
			self.sendTo: ar ifNoneInRange: {
				debug("[sendAndDiscover (ONE)]: no one in range, starting single search for "+self.message.selector);
				registration := self.search: ar whenFound: { |pub| pub.cancel() };
			};
			registration
		};
	}
};

//in message with arity ALL:
def makeAllArityTrait() {
	object: {
		def createFuture() { MFuturesModule.makeMultiFuture() };
		def sendTo: ar ifNoneInRange: code {
			if: (ar.range.length == 0) then: code else: {
				debug("[sendTo:ifNoneInRange: (ALL)]: sending "+self.message.selector + " to " + ar.range.length + "receivers");
				ar.range.each: { |rcvr|
					self.sendMessage(rcvr);
				}
			};
		};
		def sendAndDiscover(ar) {			
			self.sendTo: ar ifNoneInRange: { };
			// this method returns a registration object which
			// is implicitly passed on to sendAndDiscover
			// (allows early retraction of the message)
			self.search: ar whenFound: { |pub| };
		};	
	}
};

//in message with lifetime INSTANT:
def makeInstantLifetimeTrait() {
	object: {
		def receivedBy(ar) {
			debug("[receivedBy (INSTANT)]: sending "+self.message.selector + " to rcvrs in range first");
			self.sendTo: ar ifNoneInRange: {
				debug("[receivedBy (INSTANT)]: "+self.message.selector + " dropped!");
				/*signalDropped(self.message)*/
			};
			self.allMessagesSent();
			// return publication object to 'retract' the message
			// of course, in the case of an instant message no retraction is necessary
			object: { def cancel() { false } };
		}	
	}
};

//in message with lifetime (TRANSIENT | DURABLE):
def makeTransientDurableLifetimeTrait() {
	object: {
		def receivedBy(ar) { self.sendAndDiscover(ar) };
		def startSearchIn: ar whenFound: clo {
			debug("[startSearchIn:.. (TRANS|DURABLE)]: searching for rcvrs for "+self.message.selector);
			def pub := ar.addDiscoveryObserver({ |rcvr|
				self.sendMessage(rcvr);
				clo(pub);
			});
		};
		def stopSearch(pub) {
			debug("[startSearchIn:.. (TRANS|DURABLE)]: stopping search for rcvrs for "+self.message.selector);
			pub.cancel();
			self.allMessagesSent();
		};	
	}
};

//in message with lifetime TRANSIENT:
def makeTransientLifetimeTrait(initTransientPeriod) {
	object: {
		import makeTransientDurableLifetimeTrait();
		
		def transientPeriod := initTransientPeriod;
		def search: ar whenFound: clo {
			def pub := self.startSearchIn: ar whenFound: clo;
			debug("[search:whenFound: (TRANSIENT)]: will stop search for "+self.message.selector + " in " +self.transientPeriod);
			def timerPub := when: self.transientPeriod elapsed: {
				self.stopSearch(pub);
			};
			// invoking cancel causes preliminary retraction of the message
			object: {
				def cancel() {
					timerPub.cancel();
					self.stopSearch(pub);
				}
			}
		};	
	}
};

//in message with lifetime DURABLE: {
def makeDurableLifetimeTrait() {
	object: {
		import makeTransientDurableLifetimeTrait();
		
		def search: ar whenFound: clo {
			def pub := self.startSearchIn: ar whenFound: clo;
			debug("[search:whenFound: (DURABLE)]: returning search pub for "+self.message.selector);
			// returns publication that can be used to stop msg delivery
			object: {
				def cancel() {
					self.stopSearch(pub);
				}
			};
		};	
	}
};

//in message with lifetime EXPIRES: {
def makeExpiresLifetimeTrait(expPeriod) {
	object: {
		import makeTransientLifetimeTrait(expPeriod) alias receivedBy := originalReceivedBy;
		import makeDueReplyTrait(expPeriod) exclude duePeriod;
		def timeSent;
		def receivedBy(ar) {
			debug("[receivedBy (EXPIRES)]: capturing time sent for "+self.message.selector);
			self.timeSent := now();
			self.originalReceivedBy(ar);
		};
		def duePeriod() {
			def to := self.transientPeriod - (now() - self.timeSent);
			debug("[duePeriod (EXPIRES)]: calculated due time = "+to);
			to;
		};	
	}
};

def makeMessageHandlerFor(msg) {	
	// perform case analysis based on the types
	
	def ArityTrait;
	def ReplyTrait;
	def LifetimeTrait;
  
  // ARITY = ONE | ALL
	if: (is: msg taggedAs: One) then: {
		ArityTrait := { makeOneArityTrait() };
	} else: {
		if: (is: msg taggedAs: All) then: {
			ArityTrait := { makeAllArityTrait() };
		} else: {
			// DEFAULT SHOULD BE DEPENDENT ON AR RECEIVER
			//ArityTrait := makeOneArityTrait();
		}
	};
	
	// EXPIRABLE => LIFETIME = TRANSIENT AND REPLY = DUE
	if: (is: msg taggedAs: Expirable) then: {
		def ann := Util.getAnnotationOfType(msg, Expirable);
		LifetimeTrait := { makeExpiresLifetimeTrait(ann.timeout) };
		ReplyTrait := { object: { } };
	} else: {
		
		// TODO: call FuturesModule.futurize(msg, future, type)
		// to equip message with future behaviour
		
		// REPLY = DUE | ONEWAY | FUTURE
		if: (is: msg taggedAs: DueT) then: {
			def ann := Util.getAnnotationOfType(msg, DueT);
			ReplyTrait := { makeDueReplyTrait(ann.timeout) };
		} else: {
			if: (is: msg taggedAs: Oneway) then: {
				ReplyTrait := { makeOnewayReplyTrait() };
			} else: {
				if: (is: msg taggedAs: Future) then: {
					ReplyTrait := { makeFutureReplyTrait() };
				} else: {
					// DEFAULT SHOULD BE DEPENDENT ON AR RECEIVER
					//ReplyTrait := makeOnewayReplyTrait();
				}
			}
		};
		
		// LIFETIME = INSTANT | TRANSIENT | DURABLE
		if: (is: msg taggedAs: Instant) then: {
		  LifetimeTrait := { makeInstantLifetimeTrait() };
	  } else: {
			if: (is: msg taggedAs: TransientT) then: {
				def ann := Util.getAnnotationOfType(msg, TransientT);
				LifetimeTrait := { makeTransientLifetimeTrait(ann.period) };
			} else: {
				if: (is: msg taggedAs: Durable) then: {
					LifetimeTrait := { makeDurableLifetimeTrait() };
				} else: {
					// DEFAULT SHOULD BE DEPENDENT ON AR RECEIVER
					//LifetimeTrait := makeDurableLifetimeTrait();
				}
			};
	  };
		
	};
	
	if: (((ArityTrait == nil).or: {
		     ReplyTrait == nil }).or: {
			LifetimeTrait == nil }) then: {
		// postpone decision until message sending time
		debug("[makeHandler]: postponing creation of handler for message "+msg.selector);
		msg
	} else: {
		// perform trait composition and fill in the required message slot
		// to bind the traits to the message
		def handler := object: {
		  import ArityTrait();
		  import ReplyTrait();
		  import LifetimeTrait();
		  def message := self.attachFutureToMessage(msg);
	  };
		debug("[makeHandler]: handler created for "+msg.selector);
		extend: handler.message with: { |handler| };
	}
};

deftype ARModule;

def enableAmbientRefs() {
	if: !(is: actor taggedAs: ARModule) then: {
		FuturesModule.enableFutures(false);
		actor.install: (extend: actor with: {
			def createMessage(sel, args, types) {
				def msg := super^createMessage(sel, args, types);
				if: (is: msg taggedAs: ARAnnotation) then: {
					makeMessageHandlerFor(msg);					
				} else: {
					msg
				}
			}; // end createMessage
			
			/*def send(receiver, msg) {
				def result := super^send(receiver, msg);
				if: (does: msg respondTo: `future) then: {
					msg.future
				} else: {
					result
				}
			};*/
			
		} taggedAs: [ ARModule ]);	
	}
};

deftype Nothing;
def dfltRange := [];
def dfltType := Nothing;
def dfltFilter := isolatelambda: { |o| true } scoped: {};
def dfltArity := One;
def dfltLifetime := Durable;
def dfltReply := Oneway;

def nativeWhenever: farref discovered: code {
	whenever: farref discovered: code
};
def nativeWhenever: farref lost: code {
	whenever: farref lost: code
};
def nativeExport: obj as: type {
	export: obj as: type;
};

def AmbientRefModule := object: {
	
	def enableAmbientRefs := &enableAmbientRefs;
	
  def One := One;
  def All := All;

  def Instant := Instant;
	def Transient := &Transient;
	def Durable := Durable;

	def Future := Future;	
  def Due := &Due;
	def Oneway := Oneway;

	def Expires := &Expires;
	
	def MessageDropped := MessageDropped;
	
	// language constructs for connection awareness
	
	def whenever: ambientRef discovered: code {
		if: (is: ambientRef taggedAs: AmbientRef) then: {
			ambientRef<-addDiscoveryObserver(code)@MetaMessage;
		} else: {
			nativeWhenever: ambientRef discovered: code;
		}
	};
	
	def when: ambientRef discovered: code {
		def pub := whenever: ambientRef discovered: {
			pub.cancel();
			code();
		};
	};
	
	def whenever: ambientRef lost: code {
		if: (is: ambientRef taggedAs: AmbientRef) then: {
		  ambientRef<-addLossObserver(code)@MetaMessage;
		} else: {
			nativeWhenever: ambientRef lost: code;
		}
	};
	
	def when: ambientRef lost: code {
		def pub := whenever: ambientRef lost: {
			pub.cancel();
			code();
		};
	};
	
	// allow exporting an object together with a set of properties
	def export: serviceObject as: type with: clo {
		def props := isolate: clo;
		nativeExport: PropertyObject.new(serviceObject, props) as: type;
	};

  // override export:as: to include a property object
	def export: serviceObject as: type {
		export: serviceObject as: type with: { nil };
	};
	
	def discover: T {
		def [fut,res] := FuturesModule.makeFuture();
		when: T discovered: { |t|
			res.resolve(t);
		};
		fut;
	};
	
	def ambient: T {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T withArity: A {
		makeAmbientReference(dfltRange, T, dfltFilter, A, dfltLifetime, dfltReply);
	};
	def ambient: T withLifetime: L {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, L, dfltReply);
	};
	def ambient: T withArity: A withLifetime: L {
		makeAmbientReference(dfltRange, T, dfltFilter, A, L, dfltReply);
	};
	def ambient: T withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, dfltLifetime, R);
	};
	def ambient: T withArity: A withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, A, dfltLifetime, R);
	};
	def ambient: T withLifetime: L withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, L, R);
	};
	def ambient: T withArity: A withLifetime: L withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, A, L, R);
	};
	def ambient: T where: filter {
		makeAmbientReference(dfltRange, T, filter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withArity: A {
		makeAmbientReference(dfltRange, T, filter, A, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withLifetime: L {
		makeAmbientReference(dfltRange, T, filter, dfltArity, L, dfltReply);
	};
	def ambient: T where: filter withReply: R {
		makeAmbientReference(dfltRange, T, filter, dfltArity, dfltLifetime, R);
	};
	def ambient: T where: filter withArity: A withLifetime: L withReply: R {
		makeAmbientReference(dfltRange, T, filter, A, L, R);
	};
	
	def ambientalize: range {
		makeAmbientReference(range, dfltType, dfltFilter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambientalize: range withArity: A {
		makeAmbientReference(range, dfltType, dfltFilter, A, dfltLifetime, dfltReply);
	};
	def ambientalize: range withLifetime: L {
		makeAmbientReference(range, dfltType, dfltFilter, dfltArity, L, dfltReply);
	};
	def ambientalize: range withArity: A withLifetime: L {
		makeAmbientReference(range, dfltType, dfltFilter, A, L, dfltReply);
	};
	
	def ambient: T where: F withArity: A withLifetime: L withReply: R initWith: Range {
		makeAmbientReference(Range, T, F, A, L, R);
	};
	
	def snapshot: ref {
		ref<-makeSnapshot()@[FuturesModule.FutureMessage,MetaMessage];
	};
	
	def snapshot: ref after: period {
		def [f,r] := FuturesModule.makeFuture();
		when: period elapsed: {
			r.resolve(snapshot: ref);
		};
		f;
	};
	
	def AmbientRefsTest() {
		extend: /.at.unit.test.UnitTest.new("RevisedAmbientRefTest") with: {
			deftype rARFooTest;
			deftype rARBarTest;
			deftype ARNonExistent;

			def providerHost := actor: {
				deftype rARFooTest;
				def service := object: {
					def testMethod(x) { x+1 };
				};
				/.at.ambient.ambientrefs.export: service as: rARFooTest;

				deftype rARBarTest;
				def service2 := object: {
					def testContent(x) { x*x };
				};
				def y := 42;
				/.at.ambient.ambientrefs.export: service2 as: rARBarTest with: { |y| def z := 5 };
			};
			
			enableAmbientRefs();
			
			def a := ambient: rARFooTest;

			/*def testAsyncOneDurableFuture() {
				FuturesModule.when: a<-testMethod(5)@[One,Durable,Future] becomes: { |v|
					self.assertEquals(6,v);
				};
			};
			def testAsyncOneExpirable() {
				def blackHole := ambient: ARNonExistent;
				FuturesModule.when: blackHole<-testMethod(5)@[One,Expires(seconds(1))] becomes: { |v|
					self.fail("method should have never been processed");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};
			/*def testAsyncOneInstantFuture() {
				FuturesModule.when: a<-testMethod(5)@[One,Instant,Future] becomes: { |v|
					self.assertEquals(6,v);
				} catch: { |e|
					self.assertTrue(is: e taggedAs: MessageDropped);
				};
			};
			def testOneDurableWithoutReply() {
				self.assertEquals(nil, a<-testMethod(5)@[One,Durable,Oneway]);
			};
			def testAsyncMatchingWhere() {
				def a := ambient: rARBarTest where: { |props| props.y > 40 };
				FuturesModule.when: a<-testContent(5)@[One,Durable,Reply] becomes: { |v|
					self.assertEquals(25,v);
				} catch: { |e| raise: e };
			};
			def testAsyncNonMatchingWhere() {
				def a := ambient: rARBarTest where: { |props| props.z == 6 };
				FuturesModule.when: a<-testContent(5)@[One,Expires(seconds(4)),Reply] becomes: { |v|
					// should not happen!
					self.fail("discovered a non-matching ambient reference");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};
			def testAsyncParamPassing() {
				def act := actor: { def rcv(ar) { ar } };
				FuturesModule.when: act<-rcv(a)@FuturesModule.FutureMessage becomes: { |newAR|
					self.assertTrue(is: newAR taggedAs: AmbientRef);
					self.assertFalse(is: newAR taggedAs: /.at.types.FarReference);
					self.assertFalse(a == newAR);
				};
			};*/
		};
		
	}; // end AmbientRefsTest
	
}; // end AmbientRefModule