/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* This module implements revised ambient references where message delivery
 * policies are expressed at the messaging level rather than at the
 * reference level. This is the implementation with an "extensional" reach.
 *
 * An ambient reference is a time, synchronisation and space-decoupled reference.
 * It extends far references with anonymous and group communication.
 *  
 * An ambient reference does not refer to one specific object, but rather
 * to a set of objects, known as its range. The range can be described
 * by means of a type tag (and optionally a filter)
 *
 * Messages can be sent to one or all objects in range.
 * Messages can be buffered such that they can be sent to objects
 * that enter the ambient reference's range at a later point in time.
 * Such buffered messages can be annotated with an expiration period
 * such that they can be eventually removed.
 *
 * An ambient reference can be considered a little publish/subscribe
 * engine of its own. The reference can be used by objects to
 * publish messages into the environment. In order to receive such
 * messages, objects must register themselves by declaring themselves
 * to be 'in range' of the appropriate ambient reference.
 *
 * An Ambient Reference denotes an abstract set of objects:
 * - intensional set: (type tag | protocol) + filter closure
 * - extensional set: table of far references
 *
 * It supports different kinds of messaging strategies:
 * - message arity:
 *  - @One: choose a single receiver from the set, returns future [default]
 *  - @All: broadcast msg to all receivers in set, returns multifuture
 * - message lifetime:
 *  - @Instant: potential receivers are the current principals only,
 *     if no match message is lost.
 *  - @Transient(timeout): potential receivers are current principals +
 *     all principals in scope between now and the timeout period.
 *     If no match, buffer message until timeout.
 *  - @Sustain: potential receivers are the current principals or any other principal
 *     joining later. Message can be retracted explicitly via its future. [default]
 * - message reply destination:
 *  - @Future: attaches a future to the message to consume result(s) [default]
 *  - @Oneway: no return values are required
 *  - @Due(timeout): attaches a future to the message which, after it has been sent
 *    to one or more receivers, may time out. Note that the timeout period only starts
 *    when the message has an actual receiver, not when it is sent to the AR itself.
 *
 *  - @Expires(timeout): a combination of @Transient(timeout) and @Due(timeout)
 *    But not the same as just combining these. It sets the timeout period of each outgoing
 *    message to (timeout - (time_transmitted - time_sent)), meaning that the longer it
 *    took to discover a receiver, the less time the future gets to wait for the reply.
 *
 * Defaults can be changed at the reference level.
 *
 * Useful operations:
 * - snapshot: AR -> table of far refs
 *
 * Objects are exported:
 * - by Type or protocol
 * - by Type or protocol with properties
 *
 * To be investigated:
 * - dealing with 'dropped' or 'lost' messages: e.g. @Instant + @Future and no one in reach -> ?
 * - for @One messaging, consider a ranking policy to determine the most 'suitable' service in range.
 * - a 'metaobject protocol' to enable custom attributes (or just a more open implementation)
 *
 * Implementation-wise:
 * Important optimization: change the MOP of createMessage to return a residual function
 * Then, using partial evaluation, we can construct an optimized message constructor
 * that attaches the different types as indices into a table for quick dispatch
 * ('virtual function tables' for AR messages via partial evaluation!)
 * => would also be useful for futures! @Due,@Oneway,@FutureMessage processing
 *
 * - every message send must have an associated 'delivery handle'
 *   => has at least one method: cancel(), to retract the message
 *   In case of @oneway, return val is the handle
 *   In the case of @future, handle is retrieved via the
 *   method handleOf: <future>. Problem: handle only constructed
 *   at message reception time, not creation time => use explicit future to sync?
 *
 * @author tvcutsem
 */

def FuturesModule := /.at.lang.futures;
def MFuturesModule := /.at.lang.multifutures;
def Vector := /.at.collections.vector.Vector;
def Util := /.at.support.util;
def OneWayMessage := FuturesModule.OneWayMessage;

import /.at.support.timer;
import /.at.lang.firstclassrefs;
def DiscoveryModule := /.at.ambient.discovery;

def TEventualRef := TFarRef;
FuturesModule.enableFutures(false); // enable futures for explicitly tagged messages

def log := /.at.support.logger.makeLogger("[ambientrefs.at]", /.at.support.logger.DEBUG);
def debug(text) {
	log(text, /.at.support.logger.DEBUG)
};

deftype ARAnnotation;

deftype MsgArity <: ARAnnotation;
deftype One <: MsgArity;
deftype All <: MsgArity;

deftype MsgLifetime <: ARAnnotation;
deftype Instant <: MsgLifetime;
deftype TransientT <: MsgLifetime;
deftype Sustain <: MsgLifetime;

def Transient(period) {
	extend: TransientT with: { |period|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype MsgReplyAddress <: ARAnnotation;
deftype Future <: MsgReplyAddress;
deftype DueT <: MsgReplyAddress;
deftype Oneway <: MsgReplyAddress;

def Due(timeout) {
	extend: DueT with: { |timeout|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype Expirable <: TransientT, DueT;
def Expires(timeout) {
	extend: Expirable with: { |timeout|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype AmbientReference;

deftype DescriptorT;
def DescriptorObject := object: {
	def service;
	def properties;
	def init(svcObject, props) {
		service := svcObject;
		properties := props;
	};
	def ==(other) {
		(does: other respondTo: `service).and: { service == other.service };
	};
} taggedAs: [/.at.types.Isolate, DescriptorT];

/*def signalTimeout(msg) {
	if: (does: msg respondTo: `future) then: {
		(msg.future)<-ruinWithException(
			FuturesModule.XTimeoutException.new(msg.future))@[OneWayMessage,MetaMessage];
	}
};*/

// a dropped message exception is a special kind of timeout exception
// that guarantees the caller that no 'orphan computations' can exist
// because the message was never sent in the first place
deftype MessageDropped <: FuturesModule.TimeoutException;
def XMessageDropped := /.at.exceptions.createException(MessageDropped);
def signalDropped(msg) {
	if: (does: msg respondTo: `future) then: {
		(msg.future)<-ruinWithException(
			XMessageDropped.new("message dropped: "+msg.selector))@[OneWayMessage,MetaMessage];
	}
};

def makeAmbientReference(extensionalReach,
	                       typetagOrProtocol,
	                       filter,
	                       defaultArity,
	                       defaultLifetime,
	                       defaultReply) {
	object: {
		
		// alternative to using mirages to trap async messages:
		// use higher order messaging
		/*def toAll: asyncMsg expires: period reply: due {
			
		}*/
		
	} taggedAs: [ AmbientReference ] mirroredBy: (mirror: {

    import TEventualRef;
    import TObservable;

    def reach := Vector.new();
    extensionalReach.each: { |obj| reach.add(obj) };

    def init(base) {
	    super^init(base);
	    // create two types of observers: those for service discovery
	    // and those for service loss
	    TObservable^init(`discovered, `lost);
	
	    // TODO: also take the hidden 'recall period' of a service tracker into account
	
	    // when the correct mirror is instantiated, start the service discovery
			DiscoveryModule.whenever: typetagOrProtocol discovered: { |descriptor|
				
				debug(self.print + " discovered uniref " + descriptor);
				
				def service := descriptor;
				def attributes := isolate: { };
				if: (is: descriptor taggedAs: DescriptorT) then: {
					service := descriptor.service;
					attributes := descriptor.properties;
				};
				
				if: filter(attributes) then: {
					// add the discovered service to the AR's reach
					debug(self.print + " added to reach: " + service);
					reach.add(service);
					
					// notify when:discovered: observers
					self.notify: self.observerCatalog.discovered withArgs: [service];	
				};
			};

			DiscoveryModule.whenever: typetagOrProtocol lost: { |descriptor|
				debug(self.print + " lost uniref " + descriptor);
				def service := descriptor;
				def attributes := isolate: { };
				if: (is: descriptor taggedAs: DescriptorT) then: {
					service := descriptor.service;
					attributes := descriptor.properties;
				};
				
				if: reach.contains(service) then: {			
					// remove the lost service from the AR's reach
					debug(self.print + " removed from reach: " + service);
					reach.remove(service);
					
					// remove all unacknowledged messages from the far ref's native
					// outbox, chances are high these messages are lost, but it might
					// be that they were delivered, so sticking with at-most-once semantics
					// requires that we drop the message
					def out := retract: service;
					debug(self.print + " retracting and dropping messages to " + service +": "+out);
					
					// notify when:lost: observers
					self.notify: self.observerCatalog.lost withArgs: [service];
				};
			};
    };

    // add when: adaptor discovered: { |ref| ... } observer
    def addDiscoveryObserver: obs {
	    self.addObserver: obs to: self.observerCatalog.discovered;
    };

    // add when: adaptor lost: { |ref| ... } observer
    def addLossObserver: obs {
	    self.addObserver: obs to: self.observerCatalog.lost;
    };

    def makeSnapshot() { reach.asTable() };

		// == provide required methods for TEventualRef trait ==
		
		def intercept(message) {
			// perform case analysis
			
			// ideally, we just ask the message to process itself given our state
			// msg already pre-processed case-analysis using partial evaluation
			// msg.acceptedBy(self)
			def handler;
			if: (does: message respondTo: `handler) then: {
				handler := message.handler;
			} else: {
				handler := attachHandlerToMessage(message,defaultArity,defaultReply,defaultLifetime).handler;
				// TODO: problem: future may have been accessed in the mean time
				message.handle.future := handler.attachFutureToMessage(message);
			};
			
			def registration := handler.dispatch(self, message);
			message.handle.setRegistration(registration);
		};
	
		def toString() {
		  "ambient:"+typetagOrProtocol.typeName+"(#"+reach.length+")";
		};
	
		def transportStrategy() {
			def extReach := reach.asTable();
			{ |extReach,typetagOrProtocol,filter,defaultArity,defaultLifetime,defaultReply|
			  // when arriving at the remote host, create a new local ambient reference
			  /.at.ambient.ambientrefs.ambient: typetagOrProtocol
															   where: filter
															   withArity: defaultArity
															   withLifetime: defaultLifetime
															   withReply: defaultReply
															   initWith: extReach;
															
		  }
		};
	})
};

// Trait hierarchy
// OR should be implemented using either delegation or composite traits
// AND should be implemented using double dispatch

//in message with reply ONEWAY:
def TOneway := object: {
	def attachFutureToMessage(msg) { nil };
	def discoveryStopped(msg) { };
	def sendMessage(rcvr, msg) {
		debug("[sendMessage (ONEWAY)]: sending "+msg.selector+" to "+rcvr);
		rcvr <+ msg;
	};
};

//in message with reply FUTURE:
def TReply := object: {
	def attachFutureToMessage(msg) {
		def [fut,res] := self.createFuture(); // dispatch TArity
		debug("[attachFutureToMessage]: creating future for "+msg.selector+": "+fut);
		fut
		//FuturesModule.futurize(msg, fut, FuturesModule.FutureMessage);	
	};
	def discoveryStopped(msg) { };
	def sendMessage(rcvr, msg) {
		debug("[sendMessage (FUTURE|DUE)]: sending "+msg.selector+" to "+rcvr);
		def [fut, res] := FuturesModule.makeFuture();
		
		// send the original msg (= msg without the handle, the handler and the future)
		def originalMsg := msg.super.super; //handle & handler
		
		rcvr <+ FuturesModule.futurize(originalMsg, fut, FuturesModule.FutureMessage);
		// resolution of copy's future resolves this message's future
		msg.handle.future<-resolveWithValue(fut)@MetaMessage;
		fut
	};
};

//in message with reply DUE:
def makeTDue(initDuePeriod) {
	extend: TReply with: {		
		def timeLeftForReply(msg) { initDuePeriod };
		def discoveryStopped(msg) {
		  // notify unbounded multifutures that they should consider
		  // themselves totally resolved
			debug("[discoveryStopped (DUE)]: all "+msg.selector+" msges sent, starting closing timer");
		  when: self.timeLeftForReply(msg) elapsed: {
				debug("[discoveryStopped (DUE)]: all "+msg.selector+" sent, closing future");
			  msg.handle.future<-becomeResolved()@MetaMessage;		
		  }
		};
		def sendMessage(rcvr, msg) {
			// msg contains future, which is either resolved|ruined with reply
			// or times out if @Due or @Expires was specified

		  // due time should only start when message is sent to an actual receiver
			// multifutures need to know whose replies to ban! Otherwise, we might report
			// a timeout AND a value of a receiver in the final multifuture
			
			debug("[sendMessage (DUE)]: sending "+msg.selector+" to "+rcvr);

			def fut := super^sendMessage(rcvr, msg);
			when: self.timeLeftForReply(msg) elapsed: {
				debug("[sendMessage (DUE)]: "+msg.selector+" timed out");
				// self.message.future<-timeout(rcvr, self.message)@MetaMessage;
				fut<-timeout(rcvr, msg)@[MetaMessage,OneWayMessage];
			};
			fut
		};		
	}
};

//in message with arity ONE:
def TOne := object: {
	def createFuture() { FuturesModule.makeFuture() };
	def send: msg to: ar ifNoneInReach: closure {
		if: (ar.reach.isEmpty) then: closure else: {
			def receiver := ar.reach.random;
			debug("[sendTo:ifNoneInReach: (ONE)]: sending "+msg.selector + " to random receiver: " + receiver);
			self.sendMessage(receiver, msg);
		};
	};
	def sendAndRegister(ar, msg) {
		// if the single message could be delivered to an object in range,
		// no retraction is necessary
		def registration := object: { def cancel() { false } };
		self.send: msg to: ar ifNoneInReach: {
			debug("[sendAndRegister (ONE)]: no one in range, starting single search for "+msg.selector);
			// dispatch TDiscoveryLT
			registration := self.registerMessageUntilReceiverFound(ar, msg);
		};
		registration
	};
};

//in message with arity ALL:
def TAll := object: {
	def createFuture() { MFuturesModule.makeMultiFuture() };
	def send: msg to: ar ifNoneInReach: closure {
		if: (ar.reach.isEmpty) then: closure else: {
			debug("[sendTo:ifNoneInReach: (ALL)]: sending "+msg.selector + " to " + ar.reach.length + "receivers");
			ar.reach.each: { |receiver|
				self.sendMessage(receiver, msg);
			}
		};
	};
	def sendAndRegister(ar, msg) {			
		self.send: msg to: ar ifNoneInReach: { };
		// this method returns a registration object which
		// is implicitly passed on to sendAndRegister
		// (allows early retraction of the message)
		self.registerMessage(ar, msg); // dispatch TDiscoveryLT
	};
};

//in message with lifetime INSTANT:
def TInstant := object: {
	def dispatch(ar, msg) {
		debug("[dispatch (INSTANT)]: sending "+msg.selector + " to rcvrs in range first");
		self.send: msg to: ar ifNoneInReach: { // dispatch TArity
			debug("[dispatch (INSTANT)]: "+msg.selector + " dropped!");
			/*signalDropped(self.message)*/
		};
		self.discoveryStopped(msg); // dispatch TCommLT
		// return publication object to 'retract' the message
		// of course, in the case of an instant message no retraction is necessary
		object: { def cancel() { false } };
	}
};

//in message with lifetime TRANSIENT:
def makeTTransient(initTransientPeriod) {
	def makeAutoExpirable(originalRegistration) {
		def timerRegistration := when: initTransientPeriod elapsed: {
			originalRegistration.cancel();
		};
		object: {
			def cancel() { // signals a premature cancellation
				timerRegistration.cancel(); // stop the timer
				originalRegistration.cancel(); // cancel the registration now
			}
		}
	};
	extend: TSustain with: {		
		def transientPeriod(msg) { initTransientPeriod };
		// override the methods defined by the sustainable lifetime trait
		def registerMessageUntilReceiverFound(@args) {
			def reg := super^registerMessageUntilReceiverFound(@args);
			makeAutoExpirable(reg);
		};
		def registerMessage(@args) {
			def reg := super^registerMessage(@args);
			makeAutoExpirable(reg);
		};
	};
};

//in message with lifetime SUSTAINABLE: {
def TSustain := object: {
	def dispatch(ar, msg) { self.sendAndRegister(ar, msg) }; // dispatch TArity
	
	def registerMessageUntilReceiverFound(ar, msg) {
		debug("[registerMessageUntilReceiverFound (SUSTAINABLE)]: searching for rcvrs for "+msg.selector);
		def registration := ar.addDiscoveryObserver: { |rcvr|
			self.sendMessage(rcvr, msg);
			registration.cancel();
		};
		// returns publication that can be used to stop msg delivery
		def stopDiscovery() { self.discoveryStopped(msg) }; // dispatch TCommLT
		object: {
			def cancel() {
				registration.cancel();
				stopDiscovery();
			}
		};
	};
	
	def registerMessage(ar, msg) {
		debug("[registerMessage (SUSTAINABLE)]: searching for rcvrs for "+msg.selector);
		def registration := ar.addDiscoveryObserver: { |rcvr|
			self.sendMessage(rcvr, msg);
		};
		// returns publication that can be used to stop msg delivery
		def stopDiscovery() { self.discoveryStopped(msg) }; // dispatch TCommLT
		object: {
			def cancel() {
				registration.cancel();
				stopDiscovery();
			}
		};
	};
};

//in message with lifetime EXPIRES: {
def makeTExpires(expPeriod) {
	object: {
		import makeTTransient(expPeriod);
		import makeTDue(expPeriod) exclude timeLeftForReply;
		def timeSent;
		def timeLeftForReply(msg) {
			def to := self.transientPeriod(msg) - (now() - msg.handle.sendTime);
			debug("[timeLeftForReply (EXPIRES)]: calculated due time = "+to);
			to;
		};	
	}
};

def attachHandlerToMessage(msg, ArityTrait := nil, ReplyTrait := nil, LifetimeTrait := nil) {	
	// perform case analysis based on the types
  
  // ARITY = ONE | ALL
	if: (is: msg taggedAs: One) then: {
		ArityTrait := { TOne };
	} else: {
		if: (is: msg taggedAs: All) then: {
			ArityTrait :=  { TAll };
		} else: {
			// AR RECEIVER DEFAULT
		}
	};
	
	// EXPIRABLE => LIFETIME = TRANSIENT AND REPLY = DUE
	if: (is: msg taggedAs: Expirable) then: {
		def ann := Util.getAnnotationOfType(msg, Expirable);
		LifetimeTrait := { makeTExpires(ann.timeout) };
		ReplyTrait := { object: { } };
	} else: {
		
		// REPLY = DUE | ONEWAY | FUTURE
		if: (is: msg taggedAs: DueT) then: {
			def ann := Util.getAnnotationOfType(msg, DueT);
			ReplyTrait := { makeTDue(ann.timeout) };
		} else: {
			if: (is: msg taggedAs: Oneway) then: {
				ReplyTrait := { TOneway };
			} else: {
				if: (is: msg taggedAs: Future) then: {
					ReplyTrait := { TReply };
				} else: {
					// AR RECEIVER DEFAULT
				}
			}
		};
		
		// LIFETIME = INSTANT | TRANSIENT | SUSTAINABLE
		if: (is: msg taggedAs: Instant) then: {
		  LifetimeTrait := { TInstant };
	  } else: {
			if: (is: msg taggedAs: TransientT) then: {
				def ann := Util.getAnnotationOfType(msg, TransientT);
				LifetimeTrait := { makeTTransient(ann.period) };
			} else: {
				if: (is: msg taggedAs: Sustain) then: {
					LifetimeTrait := { TSustain };
				} else: {
					// AR RECEIVER DEFAULT
				}
			};
	  };
		
	};
	
	if: (((ArityTrait == nil).or: {
		     ReplyTrait == nil }).or: {
			LifetimeTrait == nil }) then: {
		// postpone decision until message sending time
		debug("[makeHandler]: postponing creation of handler for message "+msg.selector);
		msg
	} else: {		
		// perform trait composition and fill in the required message slot
		// to bind the traits to the message
		def handler := object: {
		  import ArityTrait();
		  import ReplyTrait();
		  import LifetimeTrait();
	  };
		debug("[makeHandler]: handler created for "+msg.selector);
		extend: msg with: { |handler| };
	}
};

deftype ARModule;

def enableAmbientRefs() {
	if: !(is: actor taggedAs: ARModule) then: {
		FuturesModule.enableFutures(false);
		
		def extendWithHandle(msg, handle) { extend: msg with: {|handle|} };
		
		actor.install: (extend: actor with: {
			def createMessage(sel, args, types) {
				def msg := super^createMessage(sel, args, types);
				if: (is: msg taggedAs: ARAnnotation) then: {
					attachHandlerToMessage(msg);
				} else: {
					msg
				}
			}; // end createMessage
			
			def send(receiver, msg) {
				if: (is: receiver taggedAs: AmbientReference) then: {
				  def [cancelFuture,cancelResolver] := FuturesModule.makeFuture();
				  def handle := object: {
					  // TODO: future can only be assigned here to msges with handlers
					  //def future := msg.handler.attachFutureToMessage(msg);
					  def future := if: (does: msg respondTo: `handler) then: { msg.handler.attachFutureToMessage(msg) };
					  def sendTime := now();
					  def setRegistration(r) { cancelResolver.resolve(r) };
					  def cancel() { cancelFuture<-cancel() };
				  };
				  super^send(receiver, extendWithHandle(msg, handle));
				  handle // value of ambient message send is always a handle
			  } else: {
				  super^send(receiver, msg);
			  };
			}; // end send
			
		} taggedAs: [ ARModule ]);
	}
};

deftype Nothing;
def dfltRange := [];
def dfltType := Nothing;
def dfltFilter := script: { |o| true } carrying: [];
def dfltArity := One;
def dfltLifetime := Sustain;
def dfltReply := Oneway;

def AmbientRefModule := object: {
		
  def One := One;
  def All := All;

  def Instant := Instant;
	def Transient := &Transient;
	def Sustain := Sustain;

	def Future := Future;	
  def Due := &Due;
	def Oneway := Oneway;

	def Expires := &Expires;
	
	def MessageDropped := MessageDropped;
	
	// language constructs for connection awareness
	
	def whenever: ambientRef discovered: code {
		if: (is: ambientRef taggedAs: AmbientReference) then: {
			(reflect: ambientRef).addDiscoveryObserver: code;
		} else: {
			DiscoveryModule.whenever: ambientRef discovered: code;
		}
	};
	
	def when: ambientRef discovered: code {
		def pub := whenever: ambientRef discovered: { |ref|
			pub.cancel();
			code(ref);
		};
	};
	
	def whenever: ambientRef lost: code {
		if: (is: ambientRef taggedAs: AmbientRef) then: {
		  (reflect: ambientRef).addLossObserver: code;
		} else: {
			DiscoveryModule.whenever: ambientRef lost: code;
		}
	};
	
	def when: ambientRef lost: code {
		def pub := whenever: ambientRef lost: { |ref|
			pub.cancel();
			code(ref);
		};
	};
	
	// allow exporting an object together with a set of properties
	def export: serviceObject as: typetagOrProtocol with: closure {
		def attributes := isolate: closure;
		DiscoveryModule.export: DescriptorObject.new(serviceObject, attributes) as: typetagOrProtocol;
	};

  // override export:as: to include a property object
	def export: serviceObject as: type {
		export: serviceObject as: type with: { nil };
	};
	
	def export: svcObject {
		DiscoveryModule.export: svcObject;
	};
	
	// def [tFuture, discoverySubscription] := discover: Type
	def discover: T {
		def [fut,res] := FuturesModule.makeFuture();
		def sub := when: T discovered: { |t|
			res.resolve(t);
		};
		[fut,sub];
	};
	
	// def [tFuture, discoverySubscription] := discover: Type where: { |t| filter(t) }
	def discover: T where: filter {
	  def [arFuture, arResolver] := FuturesModule.makeFuture();
	  def sub := DiscoveryModule.whenever: T discovered: { |remoteRef|
		  def props := isolate: { nil };
		  if: (is: remoteRef taggedAs: PropertyObject) then: {
			  remoteRef := remoteRef.service;
			  props := remoteRef.properties;
		  };

	    if: (filter(props)) then: {
		    sub.cancel();
		    arResolver.resolve(remoteRef)
	    };
	  };
	  [arFuture, sub];
	};
	
	def ambient: T {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T withArity: A {
		makeAmbientReference(dfltRange, T, dfltFilter, A, dfltLifetime, dfltReply);
	};
	def ambient: T withLifetime: L {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, L, dfltReply);
	};
	def ambient: T withArity: A withLifetime: L {
		makeAmbientReference(dfltRange, T, dfltFilter, A, L, dfltReply);
	};
	def ambient: T withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, dfltLifetime, R);
	};
	def ambient: T withArity: A withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, A, dfltLifetime, R);
	};
	def ambient: T withLifetime: L withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, dfltArity, L, R);
	};
	def ambient: T withArity: A withLifetime: L withReply: R {
		makeAmbientReference(dfltRange, T, dfltFilter, A, L, R);
	};
	def ambient: T where: filter {
		makeAmbientReference(dfltRange, T, filter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withArity: A {
		makeAmbientReference(dfltRange, T, filter, A, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withLifetime: L {
		makeAmbientReference(dfltRange, T, filter, dfltArity, L, dfltReply);
	};
	def ambient: T where: filter withReply: R {
		makeAmbientReference(dfltRange, T, filter, dfltArity, dfltLifetime, R);
	};
	def ambient: T where: filter withArity: A withLifetime: L withReply: R {
		makeAmbientReference(dfltRange, T, filter, A, L, R);
	};
	
	def ambientalize: range {
		makeAmbientReference(range, dfltType, dfltFilter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambientalize: range withArity: A {
		makeAmbientReference(range, dfltType, dfltFilter, A, dfltLifetime, dfltReply);
	};
	def ambientalize: range withLifetime: L {
		makeAmbientReference(range, dfltType, dfltFilter, dfltArity, L, dfltReply);
	};
	def ambientalize: range withArity: A withLifetime: L {
		makeAmbientReference(range, dfltType, dfltFilter, A, L, dfltReply);
	};
	
	def ambient: T where: F withArity: A withLifetime: L withReply: R initWith: Range {
		makeAmbientReference(Range, T, F, A, L, R);
	};
	
	def snapshot: ref {
		ref<-makeSnapshot()@[FuturesModule.FutureMessage,MetaMessage];
	};
	
	def snapshot: ref after: period {
		def [f,r] := FuturesModule.makeFuture();
		when: period elapsed: {
			r.resolve(snapshot: ref);
		};
		f;
	};
	
	def AmbientRefsTest() {
		extend: /.at.unit.test.UnitTest.new("RevisedAmbientRefTest") with: {
			deftype rARFooTest;
			deftype rARBarTest;
			deftype ARAsyncReplyServiceTestT;
			deftype ARNonExistentTestT;
			deftype ARManyServiceTestT;

			def providerHost := actor: {
				deftype rARFooTest;
				def ARModule := /.at.ambient.ambientrefs;
				def service := object: {
					def testMethod(x) { x+1 };
				};
				ARModule.export: service as: rARFooTest;

				deftype rARBarTest;
				def service2 := object: {
					def testContent(x) { x*x };
				};
				def y := 42;
				ARModule.export: service2 as: rARBarTest with: { |y| def z := 5 };
				
				deftype ARAsyncReplyServiceTestT;
				def service3 := object: {
					def replyTo(f) { f<-reply(42) };
				};
				ARModule.export: service3 as: ARAsyncReplyServiceTestT;
				
				deftype ARManyServiceTestT;
				def service4 := object: {
					def serve(request) { request + 1 };
				};
				ARModule.export: service4 as: ARManyServiceTestT;			
			};
			
			def providerHost2 := actor: {
				deftype ARManyServiceTestT;
				/.at.ambient.ambientrefs.export: (object: {
					def serve(request) { request + 2 };
				}) as: ARManyServiceTestT;
			};
						
			def a := ambient: rARFooTest;
			def asyncReply := ambient: ARAsyncReplyServiceTestT;
			def omni := ambient: ARManyServiceTestT;

      // ONE, SUSTAIN, FUTURE
			def testAsyncOneSustainFuture() {
				def handle := a<-testMethod(5)@[One,Sustain,Future];
				FuturesModule.when: handle.future becomes: { |v|
					self.assertEquals(6,v);
				};
			};
			// ONE, TRANSIENT, FUTURE
			def testAsyncOneTransientFuture() {
				def handle := a<-testMethod(5)@[One,Transient(seconds(12)),Future];
				FuturesModule.when: handle.future becomes: { |v|
					self.assertEquals(6,v);
				} catch: { |e|
					self.fail("subject should have been found");
				};
			};
			// ONE, EXPIRES
			def testAsyncOneExpirable() {
				def blackHole := ambient: ARNonExistentTestT;
				def handle := blackHole<-testMethod(5)@[One,Expires(seconds(5))];
				FuturesModule.when: handle.future becomes: { |v|
					self.fail("method should have never been processed");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};
			// ONE, INSTANT, ONEWAY
			def testOneInstantOneway() {
				def handle := a<-testMethod(5)@[One,Instant,Oneway];
				self.assertEquals(nil, handle.future);
			};
			// ONE, SUSTAIN, ONEWAY
			def testOneSustainOneway() {
				def handle := a<-testMethod(5)@[One,Sustain,Oneway];
				self.assertEquals(nil, handle.future);
			};
			// ONE, INSTANT, ONEWAY
			def testAsyncOneInstantOnewayNotDropped() {
				FuturesModule.future: { |return|				
					when: asyncReply discovered: { |ref|
						def handle := asyncReply<-replyTo(object: {
							def reply(x) {
								return(x);
							}
						})@[One,Instant,Oneway];
						self.assertEquals(nil, handle.future);	
					}
				}
			};
			// ALL, TRANSIENT, DUE
			def testAsyncAllTransientDue() {
				def handle := omni<-serve(0)@[All,Transient(seconds(6)),Due(seconds(4))];
				MFuturesModule.whenAll: handle.future resolved: { |vals|
					self.assertEquals(2, vals.length);
					self.assertTrue(vals.contains(1));
					self.assertTrue(vals.contains(2));
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};
			// ALL, TRANSIENT, FUTURE
			def testAsyncAllTransientFuture() {
				FuturesModule.future: { |reply|
					def count := 0;
					def handle := omni<-serve(0)@[All,Transient(seconds(6)),Future];
					MFuturesModule.whenEach: handle.future becomes: { |val|
					  self.assertTrue((val == 1).or: { val == 2 });
					  count := count + 1;
					  if: (count == 2) then: {
						  reply(true);
					  };
				  };
				};
			};
			// ALL, EXPIRES
			def testAsyncAllExpires() {
				def handle := omni<-serve(0)@[All,Expires(seconds(8))];
				MFuturesModule.whenAll: handle.future resolved: { |vals|
					self.assertEquals(2, vals.length);
					self.assertTrue(vals.contains(1));
					self.assertTrue(vals.contains(2));
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};
			// ALL, SUSTAIN, ONEWAY
			def testAsyncAllSustainOneway() {
				FuturesModule.future: { |return|
					def handle := asyncReply<-replyTo(object: {
						def reply(x) {
							return(x);
						}
					})@[All,Sustain,Oneway];
					self.assertEquals(nil, handle.future);	
				}
			};
			def testAsyncMatchingWhere() {
				def a := ambient: rARBarTest where: { |props| props.y > 40 };
				def handle := a<-testContent(5)@[One,Sustain,Future];
				FuturesModule.when: handle.future becomes: { |v|
					self.assertEquals(25,v);
				} catch: { |e| raise: e };
			};
			def testAsyncNonMatchingWhere() {
				def a := ambient: rARBarTest where: { |props| props.z == 6 };
				def handle := a<-testContent(5)@[One,Expires(seconds(5)),Future];
				FuturesModule.when: handle.future becomes: { |v|
					// should not happen!
					self.fail("discovered a non-matching ambient reference");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};
			def testAsyncParamPassing() {
				def act := actor: { def rcv(ar) { ar } };
				FuturesModule.when: act<-rcv(a)@FuturesModule.FutureMessage becomes: { |newAR|
					// after this, there will be 2 copies of a, one created upon parameter passing
					// and one created upon method return
					self.assertTrue(is: newAR taggedAs: AmbientReference);
					self.assertFalse(is: newAR taggedAs: /.at.types.FarReference);
					self.assertFalse(a == newAR);
				};
			};
			// this unit test implements the simple voting example between proximate
			// players in a multiplayer game
			def testAsyncVoting() {
				deftype VotePlayerTest;
				
				def spawnPlayers(max) {
				  1.to: max+1 do: { |i|
						actor: { |i|
							deftype VotePlayerTest;
							/.at.ambient.ambientrefs.export: (object: {
								def askToVote(poll) { i }
							}) as: VotePlayerTest with: {
								def team := "blue";
							};
						}
				  }	
				};
				
				def MAX := 5;
				spawnPlayers(MAX);
				
				def maxVoteTime := seconds(8);
				def proximateTeamPlayers := ambient: VotePlayerTest where: { |p| p.team == "blue" };

				def handle := proximateTeamPlayers<-askToVote("poll")@[All,Expires(maxVoteTime)];
				
				MFuturesModule.whenAll: handle.future resolved: { |votes|
					//(handle.future<-sender())<-voteResult(votes)@Oneway;
					self.assertEquals(MAX, votes.length);
					1.to: MAX+1 do: { |i|
						self.assertTrue(votes.contains(i));
					}
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};

			def protocolExporterPeer := actor: {
				import /.at.ambient.ambientrefs;
				export: (object: {
					def protocolAmbientRefTestMethod() { `ok }
				});
			};
			def protocolAmbientRef := ambient: (/.at.lang.structuraltypes.protocol: {
				def protocolAmbientRefTestMethod()
			});

			def testAsyncProtocolAmbientRef() {
				def handle := protocolAmbientRef<-protocolAmbientRefTestMethod()@[One,Transient(seconds(10)),Future];
				FuturesModule.when: handle.future becomes: { |val|
					self.assertEquals(`ok, val);
				}
			};
			
			// TODO: defaults + futures don't work! Because of the default, the traits are not
			// applied at message creation time, hence, no future is attached to the message!
			// ONE, SUSTAIN [as default], FUTURE [as default]
			/*def testAsyncOneDefaultSustainDefaultFuture() {
				def defaultSustainFuture := ambient: rARFooTest withLifetime: Sustain withReply: Future;
				FuturesModule.when: defaultSustainFuture<-testMethod(5)@[One,Future] becomes: { |v|
					self.assertEquals(6,v);
				};
			};*/
		};
		
	}; // end AmbientRefsTest
	
	// auto-enable ambient reference behaviour upon loading
	enableAmbientRefs();
	
}; // end AmbientRefModule