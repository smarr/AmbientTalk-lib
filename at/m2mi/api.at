/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Implementation of a bridge between AmbientTalk and M2MI.
 *
 * M2MI is published under the GNU General Public License.
 * All original Java M2MI sources are (c) 2001-2004 by Alan Kaminsky.
 * See http://www.cs.rit.edu/~ark/m2mi.shtml for an overview of M2MI
 *
 * In order to correctly initialize M2MI, do the following first:
 * 1) copy the *.properties file in this directory to your home directory.
 *    (this allows both the M2MP Daemon (see below) and the M2MI API to
 *    access the properties)
 * 2) in the device.properties file, change the ID to the MAC address
 *    of your network card (or a similar UNIQUE identifier)
 * 3) If you want to use M2MI to contact objects running in other VMS
 *    (either local or remote), you need to set up the M2MP Daemon.
 *    In a separate console, run the 'runm2mpdaemon' script included
 *    in this directory.
 *
 * @author tvcutsem
 */

def M2MIClass := jlobby.edu.rit.m2mi.M2MI;
def M2MI_export := M2MIClass.&export;
def M2MI_getMultihandle := M2MIClass.&getMultihandle;
def M2MI_getOmnihandle := M2MIClass.&getOmnihandle;
def M2MI_getUnihandle := M2MIClass.&getUnihandle;
def M2MI_unexport := M2MIClass.&unexport;

def Coercer_coerce := jlobby.edu.vub.at.objects.coercion.Coercer.&coerce;
def cast: obj into: interface {
	Coercer_coerce(obj, interface);
};

def TypeTagToInterfaceConverter := jlobby.at.m2mi.TypeTagToInterfaceConverter;
def TTTIC_TYPETAGLOADER := TypeTagToInterfaceConverter._TYPETAGLOADER_;
def TTTIC_convert := TypeTagToInterfaceConverter.&convert;

// initialize the M2MI layer
try: {
	M2MIClass.initialize(TTTIC_TYPETAGLOADER);
} catch: /.at.types.JavaException using: { |e|
	system.println("Cound not load M2MI library: " + e.message);
};

// creates a method invoker object that turns generic 'invoke'
// invocations into more specific invocations (needed only when
// using {omni|muli|uni}references, not with handles directly)
def createInvokerFor(obj) {
	object: {
		def invoke(msg) {
			obj <+ msg;
		};
	};
};

def M2MIModule := object: {
	
	def export: obj asM2MI: interface {
		// force the AmbientTalk object to implement
		// the given Java interface type
		def wrappedObj := cast: obj into: interface;
		M2MI_export(wrappedObj, interface);
		object: {
			def unexport() { M2MI_unexport(wrappedObj) };
		};
	};
	
	def multihandle: if {
		M2MI_getMultihandle(if);
	};
	
	def omnihandle: if {
		M2MI_getOmnihandle(if);
	};
	
	def unihandle: if for: obj {
		M2MI_getUnihandle(cast: obj into: if, if);
	};
	
	def attach: obj to: multiOrUniHandle {
		multiOrUniHandle.attach(cast: obj into: (multiOrUniHandle.getInterface()));
	};
	
	def detach: obj from: multiHandle {
		multiHandle.detach(cast: obj into: (multiHandle.getInterface()));
	};
	
	def detach: uniHandle {
		uniHandle.detach();
	};
	
	// turns an AT type tag into a Java interface type
	def toInterface: typetag {
	  TTTIC_convert(typetag);
	};
	
	// ambienttalk-enabled handles
	
	/**
	 * An ambientTalkHandle wraps an M2MI handle.
	 * It turns every AmbientTalk invocation on a type T
	 * into an M2MI invocation of the method 'invoke' on the Java interface
	 * type T', where T' is automatically generated from T.
	 */
	def makeAmbientTalkHandle(typetag, m2miHandleCreator) {
		def m2miHandle := m2miHandleCreator(toInterface: typetag);
		object: {
			def new(@args) { makeAmbientTalkHandle(typetag, m2miHandleCreator) };
		} mirroredBy: (mirror: {
			def invoke(slf, sel, args) {
				raise: /.at.exceptions.createException(/.at.types.IllegalOperation).new(
					"Cannot synchronously invoke " + sel + " on an omnireference for " + typetag);
			};
			def invokeField(slf, sel) { self.invoke(slf, sel, []) };
			def receive(msg) {
				system.println("invoking " + msg + " on " + m2miHandle);
				msg.receiver := nil; // ensures this proxy is not serialized along
				m2miHandle.invoke(msg);
			};
			// ensure that an ambienttalk handle does not become a far reference
			// when passed remotely. Rather it implements its own by-reference parameter
			// passing semantics
			def pass() {
				/.at.support.util.uponArrivalBecome: { |typetag, m2miHandle|
					/.at.m2mi.api.makeAmbientTalkHandle(typetag, { |type| m2miHandle });
				};
			};
			def attach(obj) {
				attach: createInvokerFor(obj) to: m2miHandle;
				object: {
					def detach() {
						m2miHandle.detach(obj)
					}
				};
			};
		});
	};
	
	def omnireference: typetag {
		makeAmbientTalkHandle(typetag, &omnihandle: );
	};
	def multireference: typetag {
		makeAmbientTalkHandle(typetag, &multihandle: );
	};
	def unireference: typetag for: obj {
		makeAmbientTalkHandle(typetag, { |if| unihandle: if for: createInvokerFor(obj) });
	};
	
	/**
	 * When an AmbientTalk object is exported as a type tag, a special invocation
	 * handler object is exported instead. This invocation handler transforms the
	 * 'invoke' messages which carry the real AT message into an actual AT message
	 * send on the real object.
	 */
	def export: obj asTypeTag: typetag {
		export: createInvokerFor(obj) asM2MI: (toInterface: typetag);
	};
	
	
	def M2MITest() {
		extend: /.at.unit.test.UnitTest.new("M2MITest") with: {

			def RunnableI := jlobby.java.lang.Runnable;

			def performInvocationTest(handleConstructor) {
				def [fut, res] := /.at.lang.futures.makeFuture();
				def pub;
				def aRunnable := object: {
					def run() {
						pub.unexport();
						res.resolve(true);
					};
				};
				pub := export: aRunnable asM2MI: RunnableI;
				def handle := handleConstructor(aRunnable, RunnableI);
				handle.run(); // asynchronously invoke run via the handle
				fut
			};

			def testAsyncUnihandleInvocation() {
				performInvocationTest({|obj, if|
				  unihandle: if for: obj;
				});
			};
			
			def testAsyncOmnihandleInvocation() {
				performInvocationTest({|obj, if|
				  omnihandle: if;
				});
			};
			
			def testAsyncMultihandleInvocation() {
				performInvocationTest({|obj, if|
				  def mh := multihandle: if;
				  attach: obj to: mh;
				  mh;
				});
			};
			
			def testTypeTagToInterfaceConversion() {
			  deftype Foo;
			  def interface := toInterface: Foo;
			  def outer := self;
			  def invoker := object: {
			    def invoke(msg) {
			      outer.assertEquals("test", msg);
			    };
			  };
			  def coerced := cast: invoker into: interface;
			  // will be a synchronous invocation as invoker and invokee
			  // are shared by the same actor thread
			  self.assertEquals(nil, coerced.invoke("test"));
			};
			
			def testAsyncInvocationOnCustomInterface() {
				// future used to synchronize both actors:
				// the unit test actor can only broadcast the message via the
				// omnireference when it is sure that the other actor has
				// exported its Bar object
				def [fut, res] := /.at.lang.futures.makeFuture();
				def peer := actor: { |res|
					import /.at.m2mi.api;
					deftype Bar;
					export: (object: {
						def invoke(msg) {
							system.println("invoker asynchronously invoked with arg " + msg);
						};
					}) asM2MI: (toInterface: Bar);
					res<-resolve(true);
				};
				
				/.at.lang.futures.when: fut becomes: { |ack|
					deftype Bar;
					def allBars := omnihandle: (toInterface: Bar);
					allBars.invoke("test");
				}
			};

			deftype FooBar; // describes objects with a tralala method
						
			// tests the behaviour of {omni|multi|uni}references
			def performInvocationOnATReferenceTest(arg, refConstructor) {
				def [fut, res] := /.at.lang.futures.makeFuture();
				def pub;
				def aFooBar := object: {
					def tralala(a) {
						system.println("tralala asynchronously invoked with arg " + a + " on " + aFooBar);
						pub.unexport();
						res.resolve(true);
					};
				};
				pub := export: aFooBar asTypeTag: FooBar;
				def ref := refConstructor(aFooBar, FooBar);
				ref<-tralala(arg); // asynchronously invoke tralala via the ref
				fut
			};
			
			def testAsyncUnireferenceInvocation() {
				performInvocationOnATReferenceTest("uniref", {|obj, tag|
				  unireference: tag for: obj;
				});
			};
			
			def testAsyncMultireferenceInvocation() {
				performInvocationOnATReferenceTest("multiref", {|obj, tag|
				  def mr := multireference: tag;
				  (reflect: mr).attach(obj);
				  mr;
				});
			};

      // TODO: there is a race condition when invoking the omniref
      // in parallel with a uni or multiref, and there is also an invocation
      // too many
			/*def testAsyncOmnireferenceInvocation() {
				performInvocationOnATReferenceTest("omniref", {|obj, tag|
				  omnireference: tag;
				});
			};*/
			
		};
	};
	
}