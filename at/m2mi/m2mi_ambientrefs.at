/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* 
 * Yet another implementation of ambient references, this time using
 * pure M2MI communication and exploiting omnihandles to efficiently
 * implement one-to-many message passing.
 *
 * This module implements revised ambient references where message delivery
 * policies are expressed at the messaging level rather than at the
 * reference level.
 *
 * An ambient reference is a time, synchronisation and space-decoupled reference.
 * It extends far references with anonymous and group communication.
 *  
 * An ambient reference does not refer to one specific object, but rather
 * to a set of objects, known as its reach. The reach can be described
 * by means of a type tag or protocol (and optionally a filter).
 * The filter MUST be serialisable, as it is sent to remote clients for remote evaluation!
 *
 * Messages can be sent to one or all objects in range.
 * Messages can be buffered such that they can be sent to objects
 * that enter the ambient reference's range at a later point in time.
 * Such buffered messages can be annotated with an expiration period
 * such that they can be eventually removed.
 *
 * An ambient reference can be considered a little publish/subscribe
 * engine of its own. The reference can be used by objects to
 * publish messages into the environment. In order to receive such
 * messages, objects must register themselves by declaring themselves
 * to be 'in range' of the appropriate ambient reference.
 *
 * An Ambient Reference denotes an abstract set of proximate objects.
 *
 * It supports different kinds of messaging strategies:
 * - message arity:
 *  - @One: choose a single receiver from the set, returns future [default]
 *  - @All: broadcast msg to all receivers in set, returns multifuture
 * - message lifetime:
 *  - @Instant: potential receivers are the current principals only,
 *     if no match message is lost.
 *  - @Transient(timeout): potential receivers are current principals +
 *     all principals in scope between now and the timeout period.
 *     If no match, buffer message until timeout.
 *  - @Sustain: potential receivers are the current principals or any other principal
 *     joining later. Message can be retracted explicitly via its future. [default]
 * - message reply destination:
 *  - @Reply: attaches a future to the message to consume result(s) [default]
 *  - @Oneway: no return values are required
 *  - @Due(timeout): attaches a future to the message which, after it has been sent
 *    to one or more receivers, may time out. Note that the timeout period only starts
 *    when the message has an actual receiver, not when it is sent to the AR itself.
 *
 *  - @Expires(timeout): a combination of @Transient(timeout) and @Due(timeout)
 *    But not the same as just combining these. It sets the timeout period of each outgoing
 *    message to (timeout - (time_transmitted - time_sent)), meaning that the longer it
 *    took to discover a receiver, the less time the future gets to wait for the reply.
 *
 * Defaults can be changed at the reference level.
 * Every message send to an ambient reference returns a 'handle' object which
 * can be used to 'retract' the message send (by invoking its cancel method).
 * This is useful for explicitly stopping @Sustain message sends.
 *
 * Useful operations:
 * - snapshot: AR -> table of far refs
 *
 * Objects are exported:
 * - by Type or protocol
 * - by Type or protocol with properties
 *
 * To be investigated:
 * - dealing with 'dropped' or 'lost' messages: e.g. @Instant + @Reply and no one in range -> ?
 * - for @One messaging, consider a ranking policy to determine the most 'suitable' service in range.
 * - a 'metaobject protocol' to enable custom attributes (or just a more open implementation)
 *
 *
 * !! Beware: with this version of ambient refs, any message sent to an AR is also
 * looped back to the sender itself (if it hosts an object exported under a matching type) !!
 *
 * Implementation-wise:
 * Important optimization: change the MOP of createMessage to return a residual function
 * Then, using partial evaluation, we can construct an optimized message constructor
 * that attaches the different types as indices into a table for quick dispatch
 * ('virtual function tables' for AR messages via partial evaluation!)
 * => would also be useful for futures! @Due,@Oneway,@FutureMessage processing
 *
 * TODO: factor out all state out of the handlers. This allows the
 * composition of handlers to occur off-line. At runtime, we only need to select
 * the appropriate pre-composed handler and compose it with a state object specifying
 * potential timeouts.
 *
 * @author tvcutsem
 */

def FuturesModule := /.at.lang.futures;
def MFuturesModule := /.at.lang.multifutures;
def Vector := /.at.collections.vector.Vector;
def Util := /.at.support.util;
def ProtocolM := /.at.lang.structuraltypes;
def OneWayMessage := FuturesModule.OneWayMessage;
import /.at.support.timer;
import /.at.lang.firstclassrefs;
import /.at.m2mi.api;

FuturesModule.enableFutures(false); // enable futures for explicitly tagged messages

def log := /.at.support.logger.makeLogger("[m2mi_ambientrefs.at]", /.at.support.logger.DEBUG);
def debug(text) {
	log(text, /.at.support.logger.DEBUG)
};

def makeAnnotation(Type) {
	extend: Type with: {
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype ARAnnotation;

deftype MsgArity <: ARAnnotation;
deftype OneT <: MsgArity;
deftype AllT <: MsgArity;


def OneA := makeAnnotation(OneT);
def OneA.arityHandler := {OneArity};
def OneA.createFuture := { FuturesModule.makeFuture() };

def AllA := makeAnnotation(AllT);
def AllA.arityHandler := {AllArity};
def AllA.createFuture := { MFuturesModule.makeMultiFuture() };

deftype MsgLifetime <: ARAnnotation;
deftype InstantT <: MsgLifetime;
deftype TransientT <: MsgLifetime;
deftype SustainT <: MsgLifetime;

def InstantA := makeAnnotation(InstantT);
def InstantA.lifetimeHandler := {InstantLifetime};

def TransientA(period) {
	def a := makeAnnotation(TransientT);
	def a.lifetimeHandler := { TransientLifetime(period) };
	a
};
def SustainA := makeAnnotation(SustainT);
def SustainA.lifetimeHandler := { SustainLifetime };

deftype MsgReplyAddress <: ARAnnotation;
deftype FutureReturningT <: MsgReplyAddress;
deftype ReplyT <: FutureReturningT;
deftype DueT <: FutureReturningT;
deftype OnewayT <: MsgReplyAddress;

def ReplyA := makeAnnotation(ReplyT);
def ReplyA.replyHandler := { FutureReply };

def DueA(timeout) {
	def a := makeAnnotation(DueT);
	def a.replyHandler := { DueReply(timeout) };
	a
};
def OnewayA := makeAnnotation(OnewayT);
def OnewayA.replyHandler := { OnewayReply };

deftype Expirable <: TransientT, DueT;
def ExpiresA(timeout) {
	def a := makeAnnotation(Expirable);
	def a.lifetimeHandler := { ExpireLifetime(timeout) };
	def a.replyHandler := { object: { } };
	a
};

deftype AmbientRef;
deftype ReplyHandlerT;

def RECALL_PERIOD := seconds(5);
def DISCOVERY_RATE := seconds(2);
def ANYCAST_TIMEOUT := millisec(500);

/* Ambient references with a HOM API:

def makeAmbientReference(ScopeDescriptor) {
	def reach := omnihandle: ScopeDescriptor.Type;

	def trampoline: clo bounce: hdl {
		object: clo mirroredBy: (mirror: {
			def receive(msg) {
				hdl(msg)
			}
		})
	};
	
	object: {
		def toAll := trampoline: {
			def expires(timeout) {
				trampoline: { } bounce: { |msg| sendAllExpires(timeout, msg) };
			};
			def instant := trampoline: {
				def oneway := trampoline: { } bounce: { |msg| sendAllInstantOneway(msg) };
				def future := trampoline: { } bounce: { |msg| sendAllInstantFuture(msg) };
				def due(ctimeout) := trampoline: { } bounce: { |msg| sendAllInstantDue(ctimeout, msg) };
			} bounce: { |msg| sendAllInstantDefault(msg) };
			
			def transient(timeout) {
				trampoline: {
					def oneway;
					def future;
					def due(ctimeout);
				} bounce: { |msg| };	
			};
			def sustain := trampoline: {
				def oneway;
				def future;
				def due(ctimeout);
			} bounce: { };
		} bounce: { |msg| sendAllDefault(msg) };
		
		def toOne := trampoline: {
			def expires(timeout) {
				trampoline: { } bounce: { |msg| sendOneExpires(timeout, msg) };
			};
			def instant := trampoline: {
				def oneway := trampoline: { } bounce: { |msg| sendOneInstantOneway(msg) };
				def future := trampoline: { } bounce: { |msg| sendOneInstantFuture(msg) };
				def due(ctimeout) := trampoline: { } bounce: { |msg| sendOneInstantDue(ctimeout, msg) };
			} bounce: { |msg| sendOneInstantDefault(msg) };
			
			def transient(timeout) {
				trampoline: {
					def oneway;
					def future;
					def due(ctimeout);
				} bounce: { |msg| };	
			};
			def sustain := trampoline: {
				def oneway;
				def future;
				def due(ctimeout);
			} bounce: { };
		} bounce: { |msg| sendOneDefault(msg) };
	}
};*/

deftype ProtocolAmbientRefType;

def makeAmbientReference(TypeOrProtocol,
	                       filter,
	                       defaultArity,
	                       defaultLifetime,
	                       defaultReply) {
	object: { } taggedAs: [ AmbientRef ] mirroredBy: (mirror: {
    import TFarRef;

    def reach;
    def scope;

    if: (is: TypeOrProtocol taggedAs: /.at.types.TypeTag) then: {
	    // convert type tag directly into Java interface
	    reach := omnireference: TypeOrProtocol;
	    scope := filter;
    } else: {	
	    // use a dummy type tag and test protocol conformance at discovery time
	    reach := omnireference: ProtocolAmbientRefType;
	    scope := isolatelambda: { |service|
		    (/.at.lang.structuraltypes.does: service.protocol
			                             match: TypeOrProtocol).and: { filter(service) };
		  } scoped: {|TypeOrProtocol,filter|};
    };

    def makeSnapshot() {
			def [fut,res] := FuturesModule.makeFuture();
			def snapshot := [];
			
			def replyhandler := unireference: ReplyHandlerT for: (object: {
				def reply(receiver) { snapshot := snapshot + [receiver] };
			});

			self.performAnycast(replyhandler);
			when: ANYCAST_TIMEOUT elapsed: {
	      detachUniRef: replyhandler;
				res.resolve(snapshot);
			};
			fut;
    };

    def performAnycast(replyHandler) {
	    reach<-anycast(scope, replyHandler);
    };

    def performBroadcast(msg, id, ttl) {
	    reach<-broadcast(scope, msg, id, ttl);
    };

    // TODO: implement these?
    def addDiscoveryObserver(obs);
    def addLossObserver(obs);

    // == required methods for TFarRef trait ==

    def intercept(message) {			
			def ArityT := {defaultArity};
			def LifetimeT := {defaultLifetime};
			def CommLifetimeT := {defaultReply};
			if: (is: message taggedAs: MsgArity) then: {
				ArityT := Util.getAnnotationOfType(message, MsgArity).arityHandler;
			};
			if: (is: message taggedAs: MsgLifetime) then: {
				LifetimeT := Util.getAnnotationOfType(message, MsgLifetime).lifetimeHandler;
			};
			if: (is: message taggedAs: MsgReplyAddress) then: {
				CommLifetimeT := Util.getAnnotationOfType(message, MsgReplyAddress).replyHandler;
			};
						
			def handler := object: {
				import ArityT();
				import LifetimeT();
				import CommLifetimeT();
			};
			
			(message.handle.cancelFuture)<-resolveWithValue(handler.send(self, message))@MetaMessage;
		};

		def toString() {
		  "ambient:"+TypeOrProtocol.typeName;
		};
	
		def transportStrategy := { |TypeOrProtocol,filter,defaultArity,defaultLifetime,defaultReply|
			// when arriving at the remote host, create a new local ambient reference
			/.at.m2mi.m2mi_ambientrefs.ambient: TypeOrProtocol
															   where: filter
															   withArity: defaultArity
															   withLifetime: defaultLifetime
															   withReply: defaultReply;															
		};

  });
};

def min(x,y) { (x < y).ifTrue: { x } ifFalse: { y } };

def makeLeasedIdEntry(id,originalTTL) {
	object: {
		def timeToLive := originalTTL;
	  def id := id;
	  def lapse(duration) { timeToLive := timeToLive - duration };
	  def renew(duration) { timeToLive := min(originalTTL, timeToLive + duration) };
	  def expired() { timeToLive < seconds(0) };
	}
};

// create a table of leased entries
def makeLeasedEntryTable() {
	def entries := Vector.new();
	def leaseRevoker;
	
	def activateLeaseRevoker() {
		leaseRevoker := whenever: RECALL_PERIOD elapsed: {
		  entries.removeAll: { |entry|
			  entry.lapse(RECALL_PERIOD);
			  entry.expired(); // if true, the entry will be removed
		  };
		  if: (entries.isEmpty) then: {
			  // all entries deleted, can stop checking
			  leaseRevoker.cancel();
			  leaseRevoker := nil;
		  };
	  };
	};
	
	object: {
		def containsEntry(id) {
			entries.contains(id, { |elt,entry| elt == entry.id })
		};
		def addEntry(id, ttl) {
			entries.add(makeLeasedIdEntry(id, ttl));
			if: (leaseRevoker == nil) then: {
				activateLeaseRevoker();
			};
		};
		def renewEntry(id, ttl) {
			def idx := (entries.find: { |entry| entry.id == id });
			entries.at(idx).renew(ttl);
		};
		def deactivateLeaseRevoker() {
			(nil == leaseRevoker).ifFalse: {
				leaseRevoker.cancel();
			};
			entries := nil;
		};
	}
};

deftype AmbientMessageHandler;

def exportServiceObject(obj, TypeOrProtocol, attributes) {
	def attributes.protocol := ProtocolM.protocolOf: obj;
	
	def alreadyReceivedMessages := makeLeasedEntryTable();

	def unicastMessageHandler := unireference: AmbientMessageHandler for: obj;
	
	def broadcastMessageHandler := object: {
		def anycast(scope, replyHandler) {
			if: scope(attributes) then: {
			  replyHandler<-reply(unicastMessageHandler);
			}
		};
		def broadcast(scope, msg, id, ttl) {
			if: scope(attributes) then: {
				if: !alreadyReceivedMessages.containsEntry(id) then: {
					if: !(ttl == 0) then: {
						alreadyReceivedMessages.addEntry(id, ttl);
					};
					// system.println("" + obj + "received " + msg.selector + " id = " + id + " ttl = " + ttl);
					obj <+ msg;
				} else: {
					// msg already previously received, update lease time
					// to make sure we don't hear it twice
					alreadyReceivedMessages.renewEntry(id, ttl);
				}
			}
		};
	};
	
	def pub := export: broadcastMessageHandler asTypeTag:
	  ((is: TypeOrProtocol taggedAs: /.at.types.TypeTag).ifTrue: {
		  TypeOrProtocol;
		} ifFalse: {
		  ProtocolAmbientRefType;
		});
	
	object: {
		def unexport() {
			pub.unexport();
			detachUniRef: unicastMessageHandler;
			alreadyReceivedMessages.deactivateLeaseRevoker();
		}
	}
};

// Trait Hierarchy for message handlers

def InstantLifetime := object: {
	def timeLeft(forMsg) { seconds(0) };
	def stillValid(msg) { false };
};
def TransientLifetime(timeout) {
	object: {
		def transientPeriod := timeout;
	  def timeLeft(forMsg) { (forMsg.handle.sendTime + timeout) - now() };
		def stillValid(msg) { self.timeLeft(msg) > seconds(0) };
  }
};
def SustainLifetime := object: {
	// RECALL_PERIOD is the maximum amount of time receiver wants to recall the message
	def timeLeft(forMsg) { RECALL_PERIOD };
	def stillValid(msg) { true };
};

def ExpireLifetime(timeout) {
	object: {
		import TransientLifetime(timeout);
		import DueReply(timeout) exclude duePeriod;
		
		def duePeriod(forMsg) {
			self.transientPeriod - (now() - forMsg.handle.sendTime);
		};
	}
};

def ArityTrait := object: {
	def keepSending: msg to: ar while: body {
		def continuation;
		
		def sendOnce() {		
			FuturesModule.when: body() becomes: { |continue|
				if: continue then: {
					continuation := when: DISCOVERY_RATE elapsed: {
						if: self.stillValid(msg) then: { // DISPATCH to Discovery Lifetime
							sendOnce();
					  } else: {
						  // stop sending
							self.allMessagesSent(msg); // DISPATCH to Reply Destination
					  }
					}
				} else: {
					// stop searching
					self.allMessagesSent(msg); // DISPATCH to Reply Destination
				}
			}
		};
	  sendOnce();
	
	  object: {
		  def cancel() {
			  (nil == continuation).ifFalse: { continuation.cancel() };
		  }
	  }
	};
};

def OneArity := object: {
	import ArityTrait;
	def send(ar, msg) {
		self.keepSending: msg to: ar while: {
			def replies := [];
			def replyhandler := unireference: ReplyHandlerT for: (object: {
				def reply(receiver) { replies := replies + [receiver] };
			});
			ar.performAnycast(replyhandler);
			
			FuturesModule.future: { |signal|
				when: ANYCAST_TIMEOUT elapsed: {
					if: (replies.length > 0) then: {
						//self.unicastMessage(replies[1], msg); // DISPATCH to Reply Destination
						replies[1] <+ msg;
						detachUniRef: replyhandler;
						signal(false); // stop searching
					} else: {
						signal(true); // keep on searching for receivers
					}
				}
			}
		};
	};
};

def [trueFuture,resolver] := FuturesModule.makeFuture();
resolver.resolve(true);

def AllArity := object: {
	import ArityTrait;
	def send(ar, msg) {
		def id := (print: msg.selector) + now().intValue;
		self.keepSending: msg to: ar while: {
			def ttl := self.timeLeft(msg); // DISPATCH to Discovery Lifetime
			//self.broadcastMessage(ar, msg, id, ttl); // DISPATCH to Reply Destination
			ar.performBroadcast(msg, id, ttl);
			trueFuture; // can always deliver a one-to-many message to more receivers
		}
	};
};

def OnewayFutureReplyTrait := object: {
	def allMessagesSent(msg) { /* do nothing */ };
};

def OnewayReply := object: {
	import OnewayFutureReplyTrait;
};

def FutureReply() {
	object: {
		import OnewayFutureReplyTrait;
		//import FutureDueReplyTrait;
  }
};

def DueReply(timeout) {
	object: {
		//import FutureDueReplyTrait;		
		def duePeriod(forMsg) { timeout };
	  def allMessagesSent(msg) {
		  when: self.duePeriod(msg) elapsed: {
		    (msg.future)<-becomeResolved()@[OneWayMessage,MetaMessage];
	    };
	  }
  };
};

deftype Nothing;
def dfltType := Nothing;
def dfltFilter := isolatelambda: { |o| true } scoped: {};
def dfltArity := OneArity;
def dfltLifetime := SustainLifetime;
def dfltReply := OnewayReply;

deftype ARModule;
def enableAmbientRefs() {
	if: !(is: actor taggedAs: ARModule) then: {
		actor.install: (extend: actor with: {
			/*def createMessage(sel, args, types) {
				def msg := super^createMessage(sel, args, types);
				if: (is: msg taggedAs: FutureReturningT) then: {
					def [fut,res] := Util.getAnnotationOfType(msg, MsgArity).createFuture();
					FuturesModule.futurize(msg, fut);
				} else: {
					msg
				}
			};*/ // end createMessage
			
			def send(receiver, msg) {
				if: ((is: receiver taggedAs: AmbientRef).and: { !(is: msg taggedAs: MetaMessage) }) then: {
				  def [cancelFuture,cancelRes] := FuturesModule.makeFuture();
				  def handle := object: {
					  def cancelFuture := cancelFuture;
					  def future := nil;
					  def sendTime := now();
					  def cancel() { cancelFuture<-cancel() };
				  };
					if: (is: msg taggedAs: FutureReturningT) then: {
						def [fut,res] := Util.getAnnotationOfType(msg, MsgArity).createFuture();
						handle.future := fut;
						msg := FuturesModule.futurize(msg, fut);
					} else: {
						// TODO: actually, we should also add a future to the message
						// if the receiver AR has a @Future or @Due default AND this
						// message is not tagged as @Oneway						
					};
				  super^send(receiver, extend: msg with: { |handle| });
				  handle // return value of send to AR is always the handle
			  } else: {
				  super^send(receiver, msg);
			  };
			};
		} taggedAs: [ ARModule ]);	
	}
};

enableAmbientRefs();

def AmbientRefModule := object: {
		
  def One() { OneA() };
  def All() { AllA() };

  def Instant() { InstantA() };
	def Transient(t) { TransientA(t) };
	def Sustain() { SustainA() };

	def Reply() { ReplyA() };	
  def Due(t) { DueA(t) };
	def Oneway() { OnewayA() };

	def Expires(t) { ExpiresA(t) };
	
	// language constructs for connection awareness
	
	def whenever: ambientRef discovered: code {
		if: (is: ambientRef taggedAs: AmbientRef) then: {
			(reflect: ambientRef).addDiscoveryObserver(code);
		} else: {
			DiscoveryModule.whenever: ambientRef discovered: code;
		}
	};
	
	def when: ambientRef discovered: code {
		def pub := whenever: ambientRef discovered: { |ref|
			pub.cancel();
			code(ref);
		};
	};
	
	def whenever: ambientRef lost: code {
		if: (is: ambientRef taggedAs: AmbientRef) then: {
		  (reflect: ambientRef).addLossObserver(code);
		} else: {
			DiscoveryModule.whenever: ambientRef lost: code;
		}
	};
	
	def when: ambientRef lost: code {
		def pub := whenever: ambientRef lost: { |ref|
			pub.cancel();
			code(ref);
		};
	};
	
	// allow exporting an object together with a set of properties
	def export: serviceObject as: type with: clo {
		def attributes := object: clo;
		exportServiceObject(serviceObject, type, attributes);
	};

  // override export:as: to include a property object
	def export: serviceObject as: type {
		export: serviceObject as: type with: { nil };
	};
	
	def export: svcObject with: clo {
		export: svcObject as: (ProtocolM.protocolOf: svcObject) with: clo;
	};
	
	def export: svcObject {
		export: svcObject as: (ProtocolM.protocolOf: svcObject);
	};
	
	def ambient: T {
		makeAmbientReference(T, dfltFilter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T withArity: A {
		makeAmbientReference(T, dfltFilter, A, dfltLifetime, dfltReply);
	};
	def ambient: T withLifetime: L {
		makeAmbientReference(T, dfltFilter, dfltArity, L, dfltReply);
	};
	def ambient: T withArity: A withLifetime: L {
		makeAmbientReference(T, dfltFilter, A, L, dfltReply);
	};
	def ambient: T withReply: R {
		makeAmbientReference(T, dfltFilter, dfltArity, dfltLifetime, R);
	};
	def ambient: T withArity: A withReply: R {
		makeAmbientReference(T, dfltFilter, A, dfltLifetime, R);
	};
	def ambient: T withLifetime: L withReply: R {
		makeAmbientReference(T, dfltFilter, dfltArity, L, R);
	};
	def ambient: T withArity: A withLifetime: L withReply: R {
		makeAmbientReference(T, dfltFilter, A, L, R);
	};
	def ambient: T where: filter {
		makeAmbientReference(T, filter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withArity: A {
		makeAmbientReference(T, filter, A, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withLifetime: L {
		makeAmbientReference(T, filter, dfltArity, L, dfltReply);
	};
	def ambient: T where: filter withReply: R {
		makeAmbientReference(T, filter, dfltArity, dfltLifetime, R);
	};
	def ambient: T where: F withArity: A withLifetime: L withReply: R {
		makeAmbientReference(T, F, A, L, R);
	};
	
	def snapshot: ref {
		ref<-makeSnapshot()@[FuturesModule.FutureMessage,MetaMessage];
	};
	
	def snapshot: ref after: period {
		def [f,r] := FuturesModule.makeFuture();
		when: period elapsed: {
			r.resolve(snapshot: ref);
		};
		f;
	};
	
	def AmbientRefsTest() {
		extend: /.at.unit.test.UnitTest.new("M2MIAmbientRefTest") with: {
			deftype blabla;
			deftype rARFooTest <: blabla;
			deftype rARBarTest;
			deftype ARAsyncReplyServiceTestT;
			deftype ARNonExistentTestT;
			deftype ARManyServiceTestT;

			def providerHost := actor: { deftype blabla;
				deftype rARFooTest <: blabla;
				def ARModule := /.at.m2mi.m2mi_ambientrefs;
				def service := object: {
					def testMethod(x) { x+1 };
				};
				ARModule.export: service as: rARFooTest;

				deftype rARBarTest;
				def service2 := object: {
					def testContent(x) { x*x };
				};
				def y := 42;
				ARModule.export: service2 as: rARBarTest with: { |y| def z := 5 };
				
				deftype ARAsyncReplyServiceTestT;
				def service3 := object: {
					def replyTo(f) { f<-reply(42) };
				};
				ARModule.export: service3 as: ARAsyncReplyServiceTestT;
				
				deftype ARManyServiceTestT;
				def service4 := object: {
					def serve(request) { request + 1 };
				};
				ARModule.export: service4 as: ARManyServiceTestT;			
			};
			
			def providerHost2 := actor: {
				deftype ARManyServiceTestT;
				/.at.m2mi.m2mi_ambientrefs.export: (object: {
					def serve(request) { request + 2 };
				}) as: ARManyServiceTestT;
			};
						
			def a := ambient: rARFooTest;
			def asyncReply := ambient: ARAsyncReplyServiceTestT;
			def omni := ambient: ARManyServiceTestT;

			// ONE, INSTANT, ONEWAY
			def testOneInstantOneway() {
				when: seconds(3) elapsed: {
					self.assertEquals(nil, (a<-testMethod(5)@[One,Instant,Oneway]).future);
				}
			};

      // ONE, SUSTAIN, FUTURE
			def testAsyncOneSustainFuture() {
				FuturesModule.when: (a<-testMethod(5)@[One,Sustain,Reply]).future becomes: { |v|
					self.assertEquals(6,v);
				};
			};

			// ONE, TRANSIENT, FUTURE
			def testAsyncOneTransientFuture() {
				FuturesModule.when: (a<-testMethod(5)@[One,Transient(seconds(20)),Reply]).future becomes: { |v|
					self.assertEquals(6,v);
				} catch: { |e|
					self.fail("subject should have been found");
				};
			};

			// ONE, EXPIRES
			def testAsyncOneExpirable() {
				def blackHole := ambient: ARNonExistentTestT;
				FuturesModule.when: (blackHole<-testMethod(5)@[One,Expires(seconds(10))]).future becomes: { |v|
					self.fail("method should have never been processed");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};

			// ONE, SUSTAIN, ONEWAY
			def testOneSustainOneway() {
				def handle := a<-testMethod(5)@[One,Sustain,Oneway];
				self.assertEquals(nil, handle.future);
			};
			
			// ONE, INSTANT, ONEWAY
			def testAsyncOneInstantOnewayNotDropped() {
				FuturesModule.future: { |return|				
					// FIXME: currently, we're just waiting long enough and hoping
					// that the actor is up in time, but this is otherwise a very
					// unsafe unit test! (semantically the message may get lost)
					when: seconds(10) elapsed: {// asyncReply discovered: { |ref|
						asyncReply<-replyTo(object: {
							def reply(x) {
								return(x);
							}
						})@[One,Instant,Oneway];	
					}
				}
			};
			
			// ALL, TRANSIENT, DUE
			def testAsyncAllTransientDue() {
				def handle := omni<-serve(0)@[All,Transient(seconds(10)),Due(seconds(5))];
				MFuturesModule.whenAll: handle.future resolved: { |vals|
					self.assertEquals(2, vals.length);
					self.assertTrue(vals.contains(1));
					self.assertTrue(vals.contains(2));
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};
			
			// ALL, TRANSIENT, REPLY
			def testAsyncAllTransientFuture() {
				FuturesModule.future: { |reply|
					def count := 0;
					def handle := omni<-serve(0)@[All,Transient(seconds(20)),Reply];
					MFuturesModule.whenEach: handle.future becomes: { |val|
					  self.assertTrue((val == 1).or: { val == 2 });
					  count := count + 1;
					  if: (count == 2) then: {
						  reply(true);
					  };
				  };
				};
			};
			
			// ALL, EXPIRES
			def testAsyncAllExpires() {
				MFuturesModule.whenAll: (omni<-serve(0)@[All,Expires(seconds(15))]).future resolved: { |vals|
					self.assertEquals(2, vals.length);
					self.assertTrue(vals.contains(1));
					self.assertTrue(vals.contains(2));
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};
			
			// ALL, SUSTAIN, ONEWAY
			def testAsyncAllSustainOneway() {
				FuturesModule.future: { |return|
					def handle := asyncReply<-replyTo(object: {
						def reply(x) {
							return(x);
							handle.cancel(); // stop sending the message
						}
					})@[All,Sustain,Oneway];	
				}
			};
			
			def testAsyncMatchingWhere() {
				def a := ambient: rARBarTest where: (isolatelambda: { |props| props.y > 40 } scoped: {});
				FuturesModule.when: (a<-testContent(5)@[One,Sustain,Reply]).future becomes: { |v|
					self.assertEquals(25,v);
				} catch: { |e| raise: e };
			};
			
			def testAsyncNonMatchingWhere() {
				def a := ambient: rARBarTest where: (isolatelambda: { |props| props.z == 6 } scoped: {});
				FuturesModule.when: (a<-testContent(5)@[One,Expires(seconds(10)),Reply]).future becomes: { |v|
					// should not happen!
					self.fail("discovered a non-matching ambient reference");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};
			
			def testAsyncParamPassing() {
				def act := actor: { def rcv(ar) { ar } };
				FuturesModule.when: act<-rcv(a)@FuturesModule.FutureMessage becomes: { |newAR|
					// after this, there will be 2 copies of a, one created upon parameter passing
					// and one created upon method return
					self.assertTrue(is: newAR taggedAs: AmbientRef);
					self.assertFalse(is: newAR taggedAs: /.at.types.FarReference);
					self.assertFalse(a == newAR);
				};
			};

			// this unit test implements the simple voting example between proximate
			// players in a multiplayer game
			def testAsyncVoting() {
				deftype VotePlayerTest;
				
				def spawnPlayers(max) {
				  1.to: max+1 do: { |i|
						actor: { |i|
							deftype VotePlayerTest;
							/.at.m2mi.m2mi_ambientrefs.export: (object: {
								def askToVote(poll) { i }
							}) as: VotePlayerTest with: {
								def team := "blue";
							};
						}
				  }	
				};
				
				def MAX := 3;
				spawnPlayers(MAX);
				
				def maxVoteTime := seconds(15);
				def proximateTeamPlayers := ambient: VotePlayerTest
				                            where: (isolatelambda: { |p| p.team == "blue" } scoped: {});

        def handle := proximateTeamPlayers<-askToVote("poll")@[All,Expires(maxVoteTime)];					
				MFuturesModule.whenAll: handle.future resolved: { |votes|
					//(voteMultiFuture<-sender())<-voteResult(votes)@Oneway;
					self.assertEquals(MAX, votes.length);
					1.to: MAX+1 do: { |i|
						self.assertTrue(votes.contains(i));
					}
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};

			def protocolExporterPeer := actor: {
				import /.at.m2mi.m2mi_ambientrefs;
				export: (object: {
					def protocolAmbientRefTestMethod() { `ok }
				}) with: {
					def x := 42;
				};
			};
			def protocolAmbientRef := ambient: (/.at.lang.structuraltypes.protocol: {
				def protocolAmbientRefTestMethod()
			});
			def protocolWhereAmbientRef := ambient: (/.at.lang.structuraltypes.protocol: {
				def protocolAmbientRefTestMethod()
			}) where: (isolatelambda: { |props| props.x > 10 } scoped: {});

			def testAsyncProtocolAmbientRef() {
				def handle := protocolAmbientRef<-protocolAmbientRefTestMethod()@[One,Sustain,Reply];
				FuturesModule.when: handle.future becomes: { |val|
					self.assertEquals(`ok, val);
				}
			};
			
			def testAsyncProtocolsAndWhere() {
				def handle := protocolWhereAmbientRef<-protocolAmbientRefTestMethod()@[One,Sustain,Reply];
				FuturesModule.when: handle.future becomes: { |val|
					self.assertEquals(`ok, val);
				}
			};
			
			def testAsyncSnapshot() {
				FuturesModule.when: (snapshot: omni after: seconds(5)) becomes: { |snapshot|
					self.assertEquals(2, snapshot.length);
				}
			};

			// TODO: deal with dropped messages, currently not explicitly trapped
			// so, @Instant + @Reply is currently a bad combination because the future
			// never times out, even if no message was ever sent
			/*def testAsyncOneInstantFuture() {
				FuturesModule.when: a<-testMethod(5)@[One,Instant,Reply] becomes: { |v|
					self.assertEquals(6,v);
				} catch: { |e|
					self.assertTrue(is: e taggedAs: MessageDropped);
				};
			};*/
			
			// TODO: defaults + futures don't work! Because of the default, the traits are not
			// applied at message creation time, hence, no future is attached to the message!
			// ONE, SUSTAIN [as default], FUTURE [as default]
			/*def testAsyncOneDefaultSustainDefaultFuture() {
				def defaultSustainFuture := ambient: rARFooTest withLifetime: Sustain withReply: Reply;
				FuturesModule.when: defaultSustainFuture<-testMethod(5)@[One,Reply] becomes: { |v|
					self.assertEquals(6,v);
				};
			};*/
		};
		
	}; // end AmbientRefsTest
	
}; // end AmbientRefModule