/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* 
 * Yet another implementation of ambient references, this time using
 * pure M2MI communication and exploiting omnihandles to efficiently
 * implement one-to-many message passing.
 *
 * This module implements revised ambient references where message delivery
 * policies are expressed at the messaging level rather than at the
 * reference level.
 *
 * An ambient reference is a time, synchronisation and space-decoupled reference.
 * It extends far references with anonymous and group communication.
 *  
 * An ambient reference does not refer to one specific object, but rather
 * to a set of objects, known as its reach. The reach can be described
 * by means of a type tag or protocol (and optionally a filter).
 * The filter MUST be serialisable, as it is sent to remote clients for remote evaluation!
 *
 * Messages can be sent to one or all objects in range.
 * Messages can be buffered such that they can be sent to objects
 * that enter the ambient reference's range at a later point in time.
 * Such buffered messages can be annotated with an expiration period
 * such that they can be eventually removed.
 *
 * An ambient reference can be considered a little publish/subscribe
 * engine of its own. The reference can be used by objects to
 * publish messages into the environment. In order to receive such
 * messages, objects must register themselves by declaring themselves
 * to be 'in range' of the appropriate ambient reference.
 *
 * An Ambient Reference denotes an abstract set of proximate objects.
 *
 * It supports different kinds of messaging strategies:
 * - message arity:
 *  - @One: choose a single receiver from the set, returns future [default]
 *  - @All: broadcast msg to all receivers in set, returns multifuture
 * - message lifetime:
 *  - @Instant: potential receivers are the current principals only,
 *     if no match message is lost.
 *  - @Transient(timeout): potential receivers are current principals +
 *     all principals in scope between now and the timeout period.
 *     If no match, buffer message until timeout.
 *  - @Sustain: potential receivers are the current principals or any other principal
 *     joining later. Message can be retracted explicitly via its future. [default]
 * - message reply destination:
 *  - @Future: attaches a future to the message to consume result(s) [default]
 *  - @Oneway: no return values are required
 *  - @Due(timeout): attaches a future to the message which, after it has been sent
 *    to one or more receivers, may time out. Note that the timeout period only starts
 *    when the message has an actual receiver, not when it is sent to the AR itself.
 *
 *  - @Expires(timeout): a combination of @Transient(timeout) and @Due(timeout)
 *    But not the same as just combining these. It sets the timeout period of each outgoing
 *    message to (timeout - (time_transmitted - time_sent)), meaning that the longer it
 *    took to discover a receiver, the less time the future gets to wait for the reply.
 *
 * Defaults can be changed at the reference level.
 *
 * Useful operations:
 * - snapshot: AR -> table of far refs
 *
 * Objects are exported:
 * - by Type or protocol
 * - by Type or protocol with properties
 *
 * To be investigated:
 * - dealing with 'dropped' or 'lost' messages: e.g. @Instant + @Future and no one in range -> ?
 * - for @One messaging, consider a ranking policy to determine the most 'suitable' service in range.
 * - a 'metaobject protocol' to enable custom attributes (or just a more open implementation)
 *
 * Implementation-wise:
 * Important optimization: change the MOP of createMessage to return a residual function
 * Then, using partial evaluation, we can construct an optimized message constructor
 * that attaches the different types as indices into a table for quick dispatch
 * ('virtual function tables' for AR messages via partial evaluation!)
 * => would also be useful for futures! @Due,@Oneway,@FutureMessage processing
 *
 * - every message send must have an associated 'delivery handle'
 *   => has at least one method: cancel(), to retract the message
 *   In case of @oneway, return val is the handle
 *   In the case of @future, handle is retrieved via the
 *   method handleOf: <future>. Problem: handle only constructed
 *   at message reception time, not creation time => use explicit future to sync?
 *
 * @author tvcutsem
 */

def FuturesModule := /.at.lang.futures;
def MFuturesModule := /.at.lang.multifutures;
def Vector := /.at.collections.vector.Vector;
def Util := /.at.support.util;
def ProtocolM := /.at.lang.structuraltypes;
def OneWayMessage := FuturesModule.OneWayMessage;
import /.at.support.timer;
import /.at.lang.firstclassrefs;
import /.at.m2mi.api;

FuturesModule.enableFutures(false); // enable futures for explicitly tagged messages

def log := /.at.support.logger.makeLogger("[m2mi_ambientrefs.at]", /.at.support.logger.DEBUG);
def debug(text) {
	log(text, /.at.support.logger.DEBUG)
};

def makeAnnotation(Type) {
	extend: Type with: {
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype ARAnnotation;

deftype MsgArity <: ARAnnotation;
deftype OneT <: MsgArity;
deftype AllT <: MsgArity;


def OneA := makeAnnotation(OneT);
def OneA.arityHandler := {OneArity};
def OneA.createFuture := { FuturesModule.makeFuture() };

def AllA := makeAnnotation(AllT);
def AllA.arityHandler := {AllArity};
def AllA.createFuture := { MFuturesModule.makeMultiFuture() };

deftype MsgLifetime <: ARAnnotation;
deftype InstantT <: MsgLifetime;
deftype TransientT <: MsgLifetime;
deftype SustainT <: MsgLifetime;

def InstantA := makeAnnotation(InstantT);
def InstantA.lifetimeHandler := {InstantLifetime};

def TransientA(period) {
	def a := makeAnnotation(TransientT);
	def a.lifetimeHandler := { TransientLifetime(period) };
	a
};
def SustainA := makeAnnotation(SustainT);
def SustainA.lifetimeHandler := { SustainLifetime };

deftype MsgReplyAddress <: ARAnnotation;
deftype FutureReturningT <: MsgReplyAddress;
deftype FutureT <: FutureReturningT;
deftype DueT <: FutureReturningT;
deftype OnewayT <: MsgReplyAddress;

def FutureA := makeAnnotation(FutureT);
def FutureA.replyHandler := { FutureReply };

def DueA(timeout) {
	def a := makeAnnotation(DueT);
	def a.replyHandler := { DueReply(timeout) };
	a
};
def OnewayA := makeAnnotation(OnewayT);
def OnewayA.replyHandler := { OnewayReply };

deftype Expirable <: TransientT, DueT;
def ExpiresA(timeout) {
	def a := makeAnnotation(Expirable);
	def a.lifetimeHandler := { ExpireLifetime(timeout) };
	def a.replyHandler := { object: { } };
	a
};

deftype AmbientRef;

def RECALL_PERIOD := seconds(5);
def DISCOVERY_RATE := seconds(2);
def ANYCAST_TIMEOUT := millisec(500);

/* Ambient references with a HOM API:

def makeAmbientReference(ScopeDescriptor) {
	def reach := omnihandle: ScopeDescriptor.Type;

	def trampoline: clo bounce: hdl {
		object: clo mirroredBy: (mirror: {
			def receive(msg) {
				hdl(msg)
			}
		})
	};
	
	object: {
		def toAll := trampoline: {
			def expires(timeout) {
				trampoline: { } bounce: { |msg| sendAllExpires(timeout, msg) };
			};
			def instant := trampoline: {
				def oneway := trampoline: { } bounce: { |msg| sendAllInstantOneway(msg) };
				def future := trampoline: { } bounce: { |msg| sendAllInstantFuture(msg) };
				def due(ctimeout) := trampoline: { } bounce: { |msg| sendAllInstantDue(ctimeout, msg) };
			} bounce: { |msg| sendAllInstantDefault(msg) };
			
			def transient(timeout) {
				trampoline: {
					def oneway;
					def future;
					def due(ctimeout);
				} bounce: { |msg| };	
			};
			def sustain := trampoline: {
				def oneway;
				def future;
				def due(ctimeout);
			} bounce: { };
		} bounce: { |msg| sendAllDefault(msg) };
		
		def toOne := trampoline: {
			def expires(timeout) {
				trampoline: { } bounce: { |msg| sendOneExpires(timeout, msg) };
			};
			def instant := trampoline: {
				def oneway := trampoline: { } bounce: { |msg| sendOneInstantOneway(msg) };
				def future := trampoline: { } bounce: { |msg| sendOneInstantFuture(msg) };
				def due(ctimeout) := trampoline: { } bounce: { |msg| sendOneInstantDue(ctimeout, msg) };
			} bounce: { |msg| sendOneInstantDefault(msg) };
			
			def transient(timeout) {
				trampoline: {
					def oneway;
					def future;
					def due(ctimeout);
				} bounce: { |msg| };	
			};
			def sustain := trampoline: {
				def oneway;
				def future;
				def due(ctimeout);
			} bounce: { };
		} bounce: { |msg| sendOneDefault(msg) };
	}
};*/

deftype ProtocolAmbientRefType;

def makeAmbientReference(TypeOrProtocol,
	                       filter,
	                       defaultArity,
	                       defaultLifetime,
	                       defaultReply) {
	object: { } taggedAs: [ AmbientRef ] mirroredBy: (mirror: {
    import TFarRef;

    def reach;
    def scope;

    if: (is: TypeOrProtocol taggedAs: /.at.types.TypeTag) then: {
	    // convert type tag directly into Java interface
	    reach := omnireference: TypeOrProtocol;
	    scope := filter;
    } else: {	
	    // use a dummy type tag and test protocol conformance at discovery time
	    reach := omnireference: ProtocolAmbientRefType;
	    scope := isolatelambda: { |service|
		    (/.at.lang.structuraltypes.does: service.protocol
			                             match: TypeOrProtocol).and: { filter(service) };
		  } scoped: {|TypeOrProtocol,filter|};
    };


    // TODO: implement these
    def makeSnapshot();
    def addDiscoveryObserver(obs);
    def addLossObserver(obs);

    // == required methods for TFarRef trait ==

    def intercept(message) {			
			def ArityT := {defaultArity};
			def LifetimeT := {defaultLifetime};
			def ReplyT := {defaultReply};
			if: (is: message taggedAs: MsgArity) then: {
				ArityT := Util.getAnnotationOfType(message, MsgArity).arityHandler;
			};
			if: (is: message taggedAs: MsgLifetime) then: {
				LifetimeT := Util.getAnnotationOfType(message, MsgLifetime).lifetimeHandler;
			};
			if: (is: message taggedAs: MsgReplyAddress) then: {
				ReplyT := Util.getAnnotationOfType(message, MsgReplyAddress).replyHandler;
			};
						
			def handler := object: {
				import ArityT();
				import LifetimeT();
				import ReplyT();
			};
			
			handler.send(self, message);
		};

		def toString() {
		  "ambient:"+TypeOrProtocol.typeName;
		};
	
		def transportStrategy := { |TypeOrProtocol,filter,defaultArity,defaultLifetime,defaultReply|
			// when arriving at the remote host, create a new local ambient reference
			/.at.m2mi.m2mi_ambientrefs.ambient: TypeOrProtocol
															   where: filter
															   withArity: defaultArity
															   withLifetime: defaultLifetime
															   withReply: defaultReply;															
		};

  });
};

def makeLeasedIdEntry(id,ttl) {
	object: {
		def timeToLive := ttl;
	  def id := id;
	  def lapse(duration) { timeToLive := timeToLive - duration };
	  def renew(duration) { timeToLive := timeToLive + duration };
	  def expired() { timeToLive < seconds(0) };
	} 
};

deftype AmbientMessageHandler;

def exportServiceObject(obj, TypeOrProtocol, attributes) {
	def attributes.protocol := ProtocolM.protocolOf: obj;
	
	def alreadyReceivedMessages := Vector.new();
	def leaseRevoker := whenever: RECALL_PERIOD elapsed: {
		alreadyReceivedMessages.removeAll: { |entry|
			entry.lapse(RECALL_PERIOD);
			entry.expired(); // if true, the entry will be removed
			// system.println("SCANNING: ("+obj+"): "+entry.id+" - "+entry.timeToLive+" drop? " + res);
		};
	};

	def unicastMessageHandler := unireference: AmbientMessageHandler for: (object: {
		def acceptOne(msg) { obj <+ msg };
	});
	
	def broadcastMessageHandler := object: {
		def anycast(scope, replyHandler) {
			if: scope(attributes) then: {
			  replyHandler<-reply(unicastMessageHandler);
			}
		};
		def acceptAll(scope, msg, id, ttl) {
			if: scope(attributes) then: {
				if: !alreadyReceivedMessages.contains(id, { |elt,entry| elt == entry.id }) then: {
					if: !(ttl == 0) then: {
						alreadyReceivedMessages.add(makeLeasedIdEntry(id, ttl));
					};
					obj <+ msg;
				} else: {
					// msg already previously received, update lease time
					// to make sure we don't hear it twice
					def idx := (alreadyReceivedMessages.find: { |entry| entry.id == id });
					alreadyReceivedMessages.at(idx).renew(ttl);
				}
			}
		};
	};
	
	def pub := export: broadcastMessageHandler asTypeTag:
	  ((is: TypeOrProtocol taggedAs: /.at.types.TypeTag).ifTrue: {
		  TypeOrProtocol;
		} ifFalse: {
		  ProtocolAmbientRefType;
		});
	
	object: {
		def unexport() {
			pub.unexport();
			detachUniRef: unicastMessageHandler;
			leaseRevoker.cancel();
		}
	}
};

// Trait Hierarchy for message handlers
// 4 dimensions: arity, discovery lifetime, reply destination, comm. lifetime
// = 4 points on which to dispatch

// 1st dispatch on arity
// 2nd dispatch on discovery lifetime
// 3rd dispatch on reply destination
// 4th dispatch on comm. lifetime

/*def DiscoveryLifetimeTrait() {
	object: {
		def sendTime := nil;
	}
};*/
def InstantLifetime := object: {
	//import DiscoveryLifetimeTrait();
	def timeLeft(forMsg) { seconds(0) };
	def stillValid(msg) { false };
};
def TransientLifetime(timeout) {
	//import DiscoveryLifetimeTrait();
	object: {
		def transientPeriod := timeout;
	  def timeLeft(forMsg) { (forMsg.sendTime + timeout) - now() };
		def stillValid(msg) { self.timeLeft(msg) > seconds(0) };
  }
};
def SustainLifetime := object: {
	//import DiscoveryLifetimeTrait();
	// RECALL_PERIOD is the maximum amount of time receiver wants to recall the message
	def timeLeft(forMsg) { RECALL_PERIOD };
	def stillValid(msg) { true };
};

def ExpireLifetime(timeout) {
	object: {
		import TransientLifetime(timeout);
		import DueReply(timeout) exclude duePeriod;
		
		def duePeriod(forMsg) {
			self.transientPeriod - (now() - forMsg.sendTime);
		};
	}
};

def ArityTrait := object: {
	def keepSending: msg to: ar while: body {
		// set the message send time of the discovery lifetime trait
		//self.sendTime := now();
		
		def sendOnce() {		
			FuturesModule.when: body() becomes: { |continue|
				if: continue then: {
					when: DISCOVERY_RATE elapsed: {
						if: self.stillValid(msg) then: { // DISPATCH to Discovery Lifetime
							sendOnce();
					  } else: {
						  // stop sending
							self.allMessagesSent(msg); // DISPATCH to Reply Destination
					  }
					}
				} else: {
					// stop searching
					self.allMessagesSent(msg); // DISPATCH to Reply Destination
				}
			}
		};
	  sendOnce();
	
	  object: {
		  def cancel() {
			  // TODO: need to stop the above discovery
		  }
	  }
	};
};

deftype ReplyHandlerT;

def OneArity := object: {
	import ArityTrait;
	//def makeFuture() { FuturesModule.makeFuture() };
	def send(ar, msg) {
		self.keepSending: msg to: ar while: {
			def replies := [];
			def replyhandler := unireference: ReplyHandlerT for: (object: {
				def reply(receiver) { replies := replies + [receiver] };
			});
			(ar.reach)<-anycast(ar.scope, replyhandler);
			
			FuturesModule.future: { |signal|
				when: ANYCAST_TIMEOUT elapsed: {
					if: (replies.length > 0) then: {
						self.unicastMessage(replies[1], msg); // DISPATCH to Reply Destination
						detachUniRef: replyhandler;
						signal(false); // stop searching
					} else: {
						signal(true); // keep on searching for receivers
					}
				}
			}
		};
		
		// set the message send time of the discovery lifetime trait
		/*self.sendTime := now();
		
		def sendOnce() {			
			def replies := [];
			def replyhandler := unihandle: ReplyHandlerT for: (object: {
				def reply(receiver) { replies := replies + [receiver] };
			});
			ar.reach<-anycast(ar.scope, replyhandler);
			
			when: ANYCAST_TIMEOUT elapsed: {
				if: (replies.length > 0) then: {
					self.replyDestination.unicastMessage(replies[0], msg);
					replyhandler.detach();
					self.replyDestination.allMessagesSent();
				} else: {
					self.pauseAndIfStillValidDo: sendOnce;
				}
			}
		};
	  sendOnce();
	
	  object: {
		  def cancel() {
			  // need to stop the above discovery
		  }
	  }*/
	};
};

def [trueFuture,resolver] := FuturesModule.makeFuture();
resolver.resolve(true);

def AllArity := object: {
	import ArityTrait;
	//def makeFuture() { MFuturesModule.makeMultiFuture() };
	def send(ar, msg) {
		def id := (print: msg.selector) + now().intValue;
		self.keepSending: msg to: ar while: {
			def ttl := self.timeLeft(msg); // DISPATCH to Discovery Lifetime
			self.broadcastMessage(ar, msg, id, ttl); // DISPATCH to Reply Destination
			trueFuture; // can always deliver a one-to-many message to more receivers
		}
		/*self.sendTime := now();
		def id := now(); //generateUID;
		
		def sendOnce() {		
			def ttl := self.discoveryLifetime.timeLeft();
			self.replyDestination.broadcastMessage(ar, msg, id, ttl);
			self.pauseAndIfStillValidDo: sendOnce;
		};
	  sendOnce();
	
	  object: {
		  def cancel() {
			  // need to stop the above discovery
		  }
	  }*/
	
	};
};

def OnewayFutureReplyTrait := object: {
	def allMessagesSent(msg) { /* do nothing */ };
};

def OnewayReply := object: {
	import OnewayFutureReplyTrait;
	//def future := nil;
	def unicastMessage(unihandle, msg) {
		unihandle<-acceptOne(msg);
	};
	def broadcastMessage(ar, msg, id, ttl) {
	  ar.reach<-acceptAll(ar.scope, msg, id, ttl);
	};
};

def FutureDueReplyTrait() {
	object: {
		//def future := self.makeFuture();
		def unicastMessage(unihandle, msg) {
	  	unihandle<-acceptOne(msg); //FuturesModule.futurize(msg, self.future));
	  };
	  def broadcastMessage(ar, msg, id, ttl) {
	    ar.reach<-acceptAll(ar.scope, msg, id, ttl); //FuturesModule.futurize(msg, self.future), id, ttl);
	  };	
	}
};

def FutureReply() {
	object: {
		import OnewayFutureReplyTrait;
		import FutureDueReplyTrait;
  }
};

def DueReply(timeout) {
	object: {
		import FutureDueReplyTrait;		
		def duePeriod(forMsg) { timeout };
	  def allMessagesSent(msg) {
		  when: self.duePeriod(msg) elapsed: {
		    (msg.future)<-becomeResolved()@[OneWayMessage,MetaMessage];
	    };
	  }
  };
};

deftype Nothing;
def dfltType := Nothing;
def dfltFilter := isolatelambda: { |o| true } scoped: {};
def dfltArity := OneArity;
def dfltLifetime := SustainLifetime;
def dfltReply := OnewayReply;

deftype ARModule;
def enableAmbientRefs() {
	if: !(is: actor taggedAs: ARModule) then: {
		actor.install: (extend: actor with: {
			def createMessage(sel, args, types) {
				def msg := super^createMessage(sel, args, types);
				if: (is: msg taggedAs: FutureReturningT) then: {
					def [fut,res] := Util.getAnnotationOfType(msg, MsgArity).createFuture();
					FuturesModule.futurize(msg, fut);
				} else: {
					msg
				}
			}; // end createMessage
			
			def send(receiver, msg) {
				def result := super^send(receiver,
					// if sent to an ambient ref, capture the current send time
					if: (is: receiver taggedAs: AmbientRef) then: {
					  def sendTime := now();
					  extend: msg with: { |sendTime| };
				  } else: {
					  msg
				  });
				if: (does: msg respondTo: `future) then: {
					msg.future
				} else: {
					result
				}
			};
		} taggedAs: [ ARModule ]);	
	}
};

enableAmbientRefs();

def AmbientRefModule := object: {
		
  def One() { OneA() };
  def All() { AllA() };

  def Instant() { InstantA() };
	def Transient(t) { TransientA(t) };
	def Sustain() { SustainA() };

	def Future() { FutureA() };	
  def Due(t) { DueA(t) };
	def Oneway() { OnewayA() };

	def Expires(t) { ExpiresA(t) };
	
	// language constructs for connection awareness
	
	def whenever: ambientRef discovered: code {
		if: (is: ambientRef taggedAs: AmbientRef) then: {
			(reflect: ambientRef).addDiscoveryObserver(code);
		} else: {
			DiscoveryModule.whenever: ambientRef discovered: code;
		}
	};
	
	def when: ambientRef discovered: code {
		def pub := whenever: ambientRef discovered: { |ref|
			pub.cancel();
			code(ref);
		};
	};
	
	def whenever: ambientRef lost: code {
		if: (is: ambientRef taggedAs: AmbientRef) then: {
		  (reflect: ambientRef).addLossObserver(code);
		} else: {
			DiscoveryModule.whenever: ambientRef lost: code;
		}
	};
	
	def when: ambientRef lost: code {
		def pub := whenever: ambientRef lost: { |ref|
			pub.cancel();
			code(ref);
		};
	};
	
	// allow exporting an object together with a set of properties
	def export: serviceObject as: type with: clo {
		def attributes := isolate: clo;
		exportServiceObject(serviceObject, type, attributes);
	};

  // override export:as: to include a property object
	def export: serviceObject as: type {
		export: serviceObject as: type with: { nil };
	};
	
	def export: svcObject with: clo {
		export: svcObject as: (ProtocolM.protocolOf: svcObject) with: clo;
	};
	
	def export: svcObject {
		export: svcObject as: (ProtocolM.protocolOf: svcObject);
	};
	
	def ambient: T {
		makeAmbientReference(T, dfltFilter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T withArity: A {
		makeAmbientReference(T, dfltFilter, A, dfltLifetime, dfltReply);
	};
	def ambient: T withLifetime: L {
		makeAmbientReference(T, dfltFilter, dfltArity, L, dfltReply);
	};
	def ambient: T withArity: A withLifetime: L {
		makeAmbientReference(T, dfltFilter, A, L, dfltReply);
	};
	def ambient: T withReply: R {
		makeAmbientReference(T, dfltFilter, dfltArity, dfltLifetime, R);
	};
	def ambient: T withArity: A withReply: R {
		makeAmbientReference(T, dfltFilter, A, dfltLifetime, R);
	};
	def ambient: T withLifetime: L withReply: R {
		makeAmbientReference(T, dfltFilter, dfltArity, L, R);
	};
	def ambient: T withArity: A withLifetime: L withReply: R {
		makeAmbientReference(T, dfltFilter, A, L, R);
	};
	def ambient: T where: filter {
		makeAmbientReference(T, filter, dfltArity, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withArity: A {
		makeAmbientReference(T, filter, A, dfltLifetime, dfltReply);
	};
	def ambient: T where: filter withLifetime: L {
		makeAmbientReference(T, filter, dfltArity, L, dfltReply);
	};
	def ambient: T where: filter withReply: R {
		makeAmbientReference(T, filter, dfltArity, dfltLifetime, R);
	};
	def ambient: T where: F withArity: A withLifetime: L withReply: R {
		makeAmbientReference(T, F, A, L, R);
	};
	
	def snapshot: ref {
		ref<-makeSnapshot()@[FuturesModule.FutureMessage,MetaMessage];
	};
	
	def snapshot: ref after: period {
		def [f,r] := FuturesModule.makeFuture();
		when: period elapsed: {
			r.resolve(snapshot: ref);
		};
		f;
	};
	
	def AmbientRefsTest() {
		extend: /.at.unit.test.UnitTest.new("M2MIAmbientRefTest") with: {
			deftype rARFooTest;
			deftype rARBarTest;
			deftype ARAsyncReplyServiceTestT;
			deftype ARNonExistentTestT;
			deftype ARManyServiceTestT;

			def providerHost := actor: {
				deftype rARFooTest;
				def ARModule := /.at.m2mi.m2mi_ambientrefs;
				def service := object: {
					def testMethod(x) { x+1 };
				};
				ARModule.export: service as: rARFooTest;

				deftype rARBarTest;
				def service2 := object: {
					def testContent(x) { x*x };
				};
				def y := 42;
				ARModule.export: service2 as: rARBarTest with: { |y| def z := 5 };
				
				deftype ARAsyncReplyServiceTestT;
				def service3 := object: {
					def replyTo(f) { f<-reply(42) };
				};
				ARModule.export: service3 as: ARAsyncReplyServiceTestT;
				
				deftype ARManyServiceTestT;
				def service4 := object: {
					def serve(request) { request + 1 };
				};
				ARModule.export: service4 as: ARManyServiceTestT;			
			};
			
			def providerHost2 := actor: {
				deftype ARManyServiceTestT;
				/.at.m2mi.m2mi_ambientrefs.export: (object: {
					def serve(request) { request + 2 };
				}) as: ARManyServiceTestT;
			};
						
			def a := ambient: rARFooTest;
			def asyncReply := ambient: ARAsyncReplyServiceTestT;
			def omni := ambient: ARManyServiceTestT;

			// ONE, INSTANT, ONEWAY
			def testOneInstantOneway() {
				when: seconds(3) elapsed: {
					self.assertEquals(nil, a<-testMethod(5)@[One,Instant,Oneway]);					
				}
			};

      // ONE, SUSTAIN, FUTURE
			def testAsyncOneSustainFuture() {
				FuturesModule.when: a<-testMethod(5)@[One,Sustain,Future] becomes: { |v|
					self.assertEquals(6,v);
				};
			};

			// ONE, TRANSIENT, FUTURE
			def testAsyncOneTransientFuture() {
				FuturesModule.when: a<-testMethod(5)@[One,Transient(seconds(12)),Future] becomes: { |v|
					self.assertEquals(6,v);
				} catch: { |e|
					self.fail("subject should have been found");
				};
			};

			// ONE, EXPIRES
			def testAsyncOneExpirable() {
				def blackHole := ambient: ARNonExistentTestT;
				FuturesModule.when: blackHole<-testMethod(5)@[One,Expires(seconds(5))] becomes: { |v|
					self.fail("method should have never been processed");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};

			// ONE, SUSTAIN, ONEWAY
			def testOneSustainOneway() {
				self.assertEquals(nil, a<-testMethod(5)@[One,Sustain,Oneway]);
			};
			
			// ONE, INSTANT, ONEWAY
			def testAsyncOneInstantOnewayNotDropped() {
				FuturesModule.future: { |return|				
					// FIXME: currently, we're just waiting long enough and hoping
					// that the actor is up in time, but this is otherwise a very
					// unsafe unit test! (semantically the message may get lost)
					when: seconds(6) elapsed: {// asyncReply discovered: { |ref|
						self.assertEquals(nil, asyncReply<-replyTo(object: {
							def reply(x) {
								return(x);
							}
						})@[One,Instant,Oneway]);	
					}
				}
			};
			
			// ALL, TRANSIENT, DUE
			def testAsyncAllTransientDue() {
				MFuturesModule.whenAll: omni<-serve(0)@[All,Transient(seconds(8)),Due(seconds(5))] resolved: { |vals|
					self.assertEquals(2, vals.length);
					self.assertTrue(vals.contains(1));
					self.assertTrue(vals.contains(2));
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};
			
			// ALL, TRANSIENT, FUTURE
			def testAsyncAllTransientFuture() {
				FuturesModule.future: { |reply|
					def count := 0;
					MFuturesModule.whenEach: omni<-serve(0)@[All,Transient(seconds(10)),Future] becomes: { |val|
					  self.assertTrue((val == 1).or: { val == 2 });
					  count := count + 1;
					  if: (count == 2) then: {
						  reply(true);
					  };
				  };
				};
			};
			
			// ALL, EXPIRES
			def testAsyncAllExpires() {
				MFuturesModule.whenAll: omni<-serve(0)@[All,Expires(seconds(10))] resolved: { |vals|
					self.assertEquals(2, vals.length);
					self.assertTrue(vals.contains(1));
					self.assertTrue(vals.contains(2));
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};
			
			// ALL, SUSTAIN, ONEWAY
			def testAsyncAllSustainOneway() {
				FuturesModule.future: { |return|
					self.assertEquals(nil, asyncReply<-replyTo(object: {
						def reply(x) {
							return(x);
						}
					})@[All,Sustain,Oneway]);	
				}
			};
			
			def testAsyncMatchingWhere() {
				def a := ambient: rARBarTest where: (isolatelambda: { |props| props.y > 40 } scoped: {});
				FuturesModule.when: a<-testContent(5)@[One,Sustain,Future] becomes: { |v|
					self.assertEquals(25,v);
				} catch: { |e| raise: e };
			};
			
			def testAsyncNonMatchingWhere() {
				def a := ambient: rARBarTest where: (isolatelambda: { |props| props.z == 6 } scoped: {});
				FuturesModule.when: a<-testContent(5)@[One,Expires(seconds(10)),Future] becomes: { |v|
					// should not happen!
					self.fail("discovered a non-matching ambient reference");
				} catch: { |e|
					self.assertTrue(is: e taggedAs: FuturesModule.TimeoutException);
				};
			};
			
			def testAsyncParamPassing() {
				def act := actor: { def rcv(ar) { ar } };
				FuturesModule.when: act<-rcv(a)@FuturesModule.FutureMessage becomes: { |newAR|
					// after this, there will be 2 copies of a, one created upon parameter passing
					// and one created upon method return
					self.assertTrue(is: newAR taggedAs: AmbientRef);
					self.assertFalse(is: newAR taggedAs: /.at.types.FarReference);
					self.assertFalse(a == newAR);
				};
			};

			// this unit test implements the simple voting example between proximate
			// players in a multiplayer game
			def testAsyncVoting() {
				deftype VotePlayerTest;
				
				def spawnPlayers(max) {
				  1.to: max+1 do: { |i|
						actor: { |i|
							deftype VotePlayerTest;
							/.at.m2mi.m2mi_ambientrefs.export: (object: {
								def askToVote(poll) { i }
							}) as: VotePlayerTest with: {
								def team := "blue";
							};
						}
				  }	
				};
				
				def MAX := 5;
				spawnPlayers(MAX);
				
				def maxVoteTime := seconds(10);
				def proximateTeamPlayers := ambient: VotePlayerTest
				                            where: (isolatelambda: { |p| p.team == "blue" } scoped: {});
				
				def voteMultiFuture := proximateTeamPlayers<-askToVote("poll")@[All,Expires(maxVoteTime)];
				
				MFuturesModule.whenAll: voteMultiFuture resolved: { |votes|
					//(voteMultiFuture<-sender())<-voteResult(votes)@Oneway;
					self.assertEquals(MAX, votes.length);
					1.to: MAX+1 do: { |i|
						self.assertTrue(votes.contains(i));
					}
				} ruined: { |excs|
					self.fail("unexpected exceptions: " + excs);
				};
			};

			def protocolExporterPeer := actor: {
				import /.at.m2mi.m2mi_ambientrefs;
				export: (object: {
					def protocolAmbientRefTestMethod() { `ok }
				}) with: {
					def x := 42;
				};
			};
			def protocolAmbientRef := ambient: (/.at.lang.structuraltypes.protocol: {
				def protocolAmbientRefTestMethod()
			});
			def protocolWhereAmbientRef := ambient: (/.at.lang.structuraltypes.protocol: {
				def protocolAmbientRefTestMethod()
			}) where: (isolatelambda: { |props| props.x > 10 } scoped: {});

			def testAsyncProtocolAmbientRef() {
				FuturesModule.when: protocolAmbientRef<-protocolAmbientRefTestMethod()
				    @[One,Transient(seconds(10)),Future] becomes: { |val|
					self.assertEquals(`ok, val);
				}
			};
			
			def testAsyncProtocolsAndWhere() {
				FuturesModule.when: protocolWhereAmbientRef<-protocolAmbientRefTestMethod()
				    @[One,Transient(seconds(10)),Future] becomes: { |val|
					self.assertEquals(`ok, val);
				}
			};
	
			// TODO: deal with dropped messages, currently not explicitly trapped
			// so, @Instant + @Future is currently a bad combination because the future
			// never times out, even if no message was ever sent
			/*def testAsyncOneInstantFuture() {
				FuturesModule.when: a<-testMethod(5)@[One,Instant,Future] becomes: { |v|
					self.assertEquals(6,v);
				} catch: { |e|
					self.assertTrue(is: e taggedAs: MessageDropped);
				};
			};*/
			
			// TODO: defaults + futures don't work! Because of the default, the traits are not
			// applied at message creation time, hence, no future is attached to the message!
			// ONE, SUSTAIN [as default], FUTURE [as default]
			/*def testAsyncOneDefaultSustainDefaultFuture() {
				def defaultSustainFuture := ambient: rARFooTest withLifetime: Sustain withReply: Future;
				FuturesModule.when: defaultSustainFuture<-testMethod(5)@[One,Future] becomes: { |v|
					self.assertEquals(6,v);
				};
			};*/
		};
		
	}; // end AmbientRefsTest
	
	// auto-enable ambient reference behaviour upon loading
	// enableAmbientRefs();
	
}; // end AmbientRefModule