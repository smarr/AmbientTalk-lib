/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* 
 * Yet another implementation of ambient references, this time using
 * pure M2MI communication and exploiting omnihandles to efficiently
 * implement one-to-many message passing.
 *
 * This module implements revised ambient references where message delivery
 * policies are expressed at the messaging level rather than at the
 * reference level.
 *
 * An ambient reference is a time, synchronisation and space-decoupled reference.
 * It extends far references with anonymous and group communication.
 *  
 * An ambient reference does not refer to one specific object, but rather
 * to a set of objects, known as its reach. The reach can be described
 * by means of a type tag or protocol (and optionally a filter).
 * The filter MUST be serialisable, as it is sent to remote clients for remote evaluation!
 *
 * Messages can be sent to one or all objects in range.
 * Messages can be buffered such that they can be sent to objects
 * that enter the ambient reference's range at a later point in time.
 * Such buffered messages can be annotated with an expiration period
 * such that they can be eventually removed.
 *
 * An ambient reference can be considered a little publish/subscribe
 * engine of its own. The reference can be used by objects to
 * publish messages into the environment. In order to receive such
 * messages, objects must register themselves by declaring themselves
 * to be 'in range' of the appropriate ambient reference.
 *
 * An Ambient Reference denotes an abstract set of proximate objects.
 *
 * It supports different kinds of messaging strategies:
 * - message arity:
 *  - @One: choose a single receiver from the set, returns future [default]
 *  - @All: broadcast msg to all receivers in set, returns multifuture
 * - message lifetime:
 *  - @Instant: potential receivers are the current principals only,
 *     if no match message is lost.
 *  - @Transient(timeout): potential receivers are current principals +
 *     all principals in scope between now and the timeout period.
 *     If no match, buffer message until timeout.
 *  - @Sustain: potential receivers are the current principals or any other principal
 *     joining later. Message can be retracted explicitly via its future. [default]
 * - message reply destination:
 *  - @Future: attaches a future to the message to consume result(s) [default]
 *  - @Oneway: no return values are required
 *  - @Due(timeout): attaches a future to the message which, after it has been sent
 *    to one or more receivers, may time out. Note that the timeout period only starts
 *    when the message has an actual receiver, not when it is sent to the AR itself.
 *
 *  - @Expires(timeout): a combination of @Transient(timeout) and @Due(timeout)
 *    But not the same as just combining these. It sets the timeout period of each outgoing
 *    message to (timeout - (time_transmitted - time_sent)), meaning that the longer it
 *    took to discover a receiver, the less time the future gets to wait for the reply.
 *
 * Defaults can be changed at the reference level.
 *
 * Useful operations:
 * - snapshot: AR -> table of far refs
 *
 * Objects are exported:
 * - by Type or protocol
 * - by Type or protocol with properties
 *
 * To be investigated:
 * - dealing with 'dropped' or 'lost' messages: e.g. @Instant + @Future and no one in range -> ?
 * - for @One messaging, consider a ranking policy to determine the most 'suitable' service in range.
 * - a 'metaobject protocol' to enable custom attributes (or just a more open implementation)
 *
 * Implementation-wise:
 * Important optimization: change the MOP of createMessage to return a residual function
 * Then, using partial evaluation, we can construct an optimized message constructor
 * that attaches the different types as indices into a table for quick dispatch
 * ('virtual function tables' for AR messages via partial evaluation!)
 * => would also be useful for futures! @Due,@Oneway,@FutureMessage processing
 *
 * - every message send must have an associated 'delivery handle'
 *   => has at least one method: cancel(), to retract the message
 *   In case of @oneway, return val is the handle
 *   In the case of @future, handle is retrieved via the
 *   method handleOf: <future>. Problem: handle only constructed
 *   at message reception time, not creation time => use explicit future to sync?
 *
 * @author tvcutsem
 */

def FuturesModule := /.at.lang.futures;
def MFuturesModule := /.at.lang.multifutures;
def Vector := /.at.collections.vector.Vector;
def Util := /.at.support.util;
def OneWayMessage := FuturesModule.OneWayMessage;

import /.at.support.timer;
import /.at.lang.firstclassrefs;
import /.at.m2mi.api;

FuturesModule.enableFutures(false); // enable futures for explicitly tagged messages

def log := /.at.support.logger.makeLogger("[m2mi_ambientrefs.at]", /.at.support.logger.DEBUG);
def debug(text) {
	log(text, /.at.support.logger.DEBUG)
};

deftype ARAnnotation;

deftype MsgArity <: ARAnnotation;
deftype One <: MsgArity;
deftype All <: MsgArity;

deftype MsgLifetime <: ARAnnotation;
deftype Instant <: MsgLifetime;
deftype TransientT <: MsgLifetime;
deftype Sustain <: MsgLifetime;

def Transient(period) {
	extend: TransientT with: { |period|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype MsgReplyAddress <: ARAnnotation;
deftype Future <: MsgReplyAddress;
deftype DueT <: MsgReplyAddress;
deftype Oneway <: MsgReplyAddress;

def Due(timeout) {
	extend: DueT with: { |timeout|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype Expirable <: TransientT, DueT;
def Expires(timeout) {
	extend: Expirable with: { |timeout|
		def ==(other) { super == other };
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

deftype AmbientRef;

def RECALL_PERIOD := seconds(5);
def DISCOVERY_RATE := seconds(2);

/* Ambient references with a HOM API:

def makeAmbientReference(ScopeDescriptor) {
	def reach := omnihandle: ScopeDescriptor.Type;

	def trampoline: clo bounce: hdl {
		object: clo mirroredBy: (mirror: {
			def receive(msg) {
				hdl(msg)
			}
		})
	};
	
	object: {
		def toAll := trampoline: {
			def expires(timeout) {
				trampoline: { } bounce: { |msg| sendAllExpires(timeout, msg) };
			};
			def instant := trampoline: {
				def oneway := trampoline: { } bounce: { |msg| sendAllInstantOneway(msg) };
				def future := trampoline: { } bounce: { |msg| sendAllInstantFuture(msg) };
				def due(ctimeout) := trampoline: { } bounce: { |msg| sendAllInstantDue(ctimeout, msg) };
			} bounce: { |msg| sendAllInstantDefault(msg) };
			
			def transient(timeout) {
				trampoline: {
					def oneway;
					def future;
					def due(ctimeout);
				} bounce: { |msg| };	
			};
			def sustain := trampoline: {
				def oneway;
				def future;
				def due(ctimeout);
			} bounce: { };
		} bounce: { |msg| sendAllDefault(msg) };
		
		def toOne := trampoline: {
			def expires(timeout) {
				trampoline: { } bounce: { |msg| sendOneExpires(timeout, msg) };
			};
			def instant := trampoline: {
				def oneway := trampoline: { } bounce: { |msg| sendOneInstantOneway(msg) };
				def future := trampoline: { } bounce: { |msg| sendOneInstantFuture(msg) };
				def due(ctimeout) := trampoline: { } bounce: { |msg| sendOneInstantDue(ctimeout, msg) };
			} bounce: { |msg| sendOneInstantDefault(msg) };
			
			def transient(timeout) {
				trampoline: {
					def oneway;
					def future;
					def due(ctimeout);
				} bounce: { |msg| };	
			};
			def sustain := trampoline: {
				def oneway;
				def future;
				def due(ctimeout);
			} bounce: { };
		} bounce: { |msg| sendOneDefault(msg) };
	}
};*/

def makeLeasedIdEntry(id,ttl) {
	def timeToLive := ttl;
	object: {
	  def id := id;
	  def lapse(duration) { timeToLive := timeToLive - duration };
	  def renew(duration) { timeToLive := timeToLive + duration };
	  def expired() { timeToLive < 0 };
	} 
};

def exportServiceObject(obj, Type, attributes) {
	
	def alreadyReceivedMessages := Vector.new();
	def leaseRevoker := whenever: RECALL_PERIOD elapsed: {
		alreadyReceivedMessages.removeAll: { |entry|
			entry.lapse(RECALL_PERIOD);
			entry.expired(); // if true, the entry will be removed
		};
	};

	def unicastMessageHandler := unihandle: (object: {
		def acceptOne(msg) { obj <+ msg };
	}) for: Type;
	
	def broadcastMessageHandler := object: {
		def anycast(scope, replyHandler) {
			if: scope(attributes) then: {
			  replyHandler<-reply(unicastMessageHandler);
			}
		};
		def acceptAll(scope, msg, id, ttl) {
			if: scope(attributes) then: {
				if: !alreadyReceivedMessages.contains(id) then: {
					if: !(ttl == 0) then: {
						alreadyReceivedMessages.add(makeLeasedIdEntry(id, ttl));
					};
					obj <+ msg;
				} else: {
					// msg already previously received, update lease time
					// to make sure we don't hear it twice
					(alreadyReceivedMessages.find: { |entry| entry.id == id }).renew(ttl);
				}
			}
		};
	};
	
	def pub := m2mi.export: broadcastMessageHandler as: Type;
	
	object: {
		def unexport() {
			pub.unexport();
			unicastMessageHandler.detach();
			leaseRevoker.cancel();
		}
	}
};

// Trait Hierarchy for message handlers
// 4 dimensions: arity, discovery lifetime, reply destination, comm. lifetime
// = 4 points on which to dispatch

// 1st dispatch on arity
// 2nd dispatch on discovery lifetime
// 3rd dispatch on reply destination
// 4th dispatch on comm. lifetime


def DiscoveryLifetimeTrait() {
	object: {
		def sendTime;
	}
};

def InstantLifetime := object: {
	import DiscoveryLifetimeTrait();
	def timeLeft() { seconds(0) };
	def stillValid() { false };
};
def TransientLifetime(timeout) {
	import DiscoveryLifetimeTrait();
	object: {
		def transientPeriod := timeout;
	  def timeLeft() { (self.sendTime + timeout) - now() };
		def stillValid() { self.timeLeft(self.sendTime) > 0 };
  }
};
def SustainLifetime := object: {
	import DiscoveryLifetimeTrait();
	// RECALL_PERIOD is the maximum amount of time receiver wants to recall the message
	def timeLeft() { RECALL_PERIOD };
	def stillValid() { true };
};

def ExpireLifetime(timeout) {
	object: {
		import TransientLifetime(timeout);
		import DueReply(timeout) exclude duePeriod;
		
		def duePeriod() {
			def to := self.transientPeriod - (now() - self.sendTime);
			debug("[duePeriod (EXPIRES)]: calculated due time = "+to);
			to;
		};
	}
};

def ArityTrait := object: {
	def keepSending: msg to: ar while: body {
		// set the message send time of the discovery lifetime trait
		self.sendTime := now();
		
		def sendOnce() {		
			when: body() becomes: { |continue|
				if: continue then: {
					when: DISCOVERY_RATE elapsed: {
						if: self.discoveryLifetime.stillValid() then: {
							sendOnce();
					  } else: {
						  // stop sending
							self.replyDestination.allMessagesSent();
					  }
					}
				} else: {
					// stop searching
					self.replyDestination.allMessagesSent();
				}
			}
		};
	  sendOnce();
	
	  object: {
		  def cancel() {
			  // need to stop the above discovery
		  }
	  }
	};
};

def OneArity := object: {
	import ArityTrait;
	def makeFuture() { /.at.lang.futures.makeFuture() };
	def send(ar, msg) {
		keepSending: msg to: ar while: {
			def replies := [];
			def replyhandler := unihandle: ReplyHandlerT for: (object: {
				def reply(receiver) { replies := replies + [receiver] };
			});
			ar.reach<-anycast(ar.scope, replyhandler);
			
			future: { |signal|
				when: ANYCAST_TIMEOUT elapsed: {
					if: (replies.length > 0) then: {
						self.replyDestination.unicastMessage(replies[0], msg);
						replyhandler.detach();
						signal(false); // stop searching
					} else: {
						signal(true); // keep on searching for receivers
					}
				}
			}
		}
		
		// set the message send time of the discovery lifetime trait
		/*self.sendTime := now();
		
		def sendOnce() {			
			def replies := [];
			def replyhandler := unihandle: ReplyHandlerT for: (object: {
				def reply(receiver) { replies := replies + [receiver] };
			});
			ar.reach<-anycast(ar.scope, replyhandler);
			
			when: ANYCAST_TIMEOUT elapsed: {
				if: (replies.length > 0) then: {
					self.replyDestination.unicastMessage(replies[0], msg);
					replyhandler.detach();
					self.replyDestination.allMessagesSent();
				} else: {
					self.pauseAndIfStillValidDo: sendOnce;
				}
			}
		};
	  sendOnce();
	
	  object: {
		  def cancel() {
			  // need to stop the above discovery
		  }
	  }*/
	};
};

def AllArity := object: {
	import ArityTrait;
	def makeFuture() { /.at.lang.multifutures.makeMultiFuture() };
	def send(ar, msg) {
		def id := (print: msg) + now();
		keepSending: msg to: ar while: {
			def ttl := self.discoveryLifetime.timeLeft();
			self.replyDestination.broadcastMessage(ar, msg, id, ttl);
			true; // can always deliver a one-to-many message to more receivers
		}
		/*self.sendTime := now();
		def id := now(); //generateUID;
		
		def sendOnce() {		
			def ttl := self.discoveryLifetime.timeLeft();
			self.replyDestination.broadcastMessage(ar, msg, id, ttl);
			self.pauseAndIfStillValidDo: sendOnce;
		};
	  sendOnce();
	
	  object: {
		  def cancel() {
			  // need to stop the above discovery
		  }
	  }*/
	
	};
};

def OnewayFutureReplyTrait := object: {
	def allMessagesSent() { /* do nothing */ };
};

def OnewayReply := object: {
	import OnewayFutureReplyTrait;
	def future := nil;
	def unicastMessage(unihandle, msg) {
		unihandle<-acceptOne(msg);
	};
	def broadcastMessage(ar, msg, id, ttl) {
	  ar.reach<-acceptAll(ar.scope, msg, id, ttl);
	};
};

def FutureDueReplyTrait() {
	object: {
		def future := self.arity.makeFuture();
		def unicastMessage(unihandle, msg) {
	  	unihandle<-acceptOne(FuturesModule.futurize(msg, self.future));
	    self.future
	  };
	  def broadcastMessage(ar, msg, id, ttl) {
	    ar.reach<-acceptAll(ar.scope, FuturesModule.futurize(msg, self.future), id, ttl);
	    self.future;
	  };	
	}
};

def FutureReply() {
	object: {
		import OnewayFutureReplyTrait;
		import FutureDueReplyTrait;
  }
};

def DueReply(timeout) {
	object: {
		import FutureDueReplyTrait;		
		def duePeriod := timeout;
	  def allMessagesSent() {
		  when: self.duePeriod elapsed: {
		    future<-becomeResolved()@[OnewayMessage,MetaMessage];
	    };
	  }
  };
};