import /.at.lang.futures;
import /.at.lang.multifutures;
enableFutures(false);
network.online();

deftype Pattern;
deftype Service;
deftype Table;
deftype SyncPattern <: Pattern;
deftype MultiPattern <: Pattern;
deftype Act;

def id := 0;

def Environment := object: {
	def dict := [];
	def id;
	
	def insert(name, value) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			dict := dict + [[name, value]];
		} else: {
			def curVal := dict[idx];
			if: ! (curVal[2] == value) then: {
				if: (is: curVal[2] taggedAs: Table) then: {
					def vals := curVal[2].find: {|v| (v == value)}; 
					if: (vals == nil)  then: {
						curVal[2] := curVal[2] + [value];
					};
				} else: { curVal[2] := [curVal[2], value] };
			};
		};
	};
	
	def delete(name) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx != nil then: {
			dict[idx] := [];
		};
	};
	
	def find(name) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			false;
		} else: {
			dict[idx];
		};
	};
	
	def bind(arguments) {
		arguments.map: { |arg| if: arg.freeVariables() != [] then: { find(arg)[2]; } else: { arg; }; };
	};
	
	def isEmpty() {
		dict.isEmpty();
	};
	
	def merge(envs) {
		envs.each: { |env| env.dict.each: { |pair| insert(pair[1], pair[2]); }; };
	};
	
	def print() {
		system.println(dict);
	};
};



def WorkflowPattern := object: {
	
	def createAsyncMsg(selector, args) {
		def msg := "<-" + selector.text()+"(";
		def sep := "";
		args.each: { |arg| msg := msg + sep + arg; sep := "," };
		msg := msg + ")@FutureMessage";
		msg;
	};
	
	def createTimeoutMsg(selector, args, timeout) {
		def msg := "<-" + selector.text()+"(";
		def sep := "";
		args.each: { |arg| msg := msg + sep + arg; sep := "," };
		msg := msg + ")@Due(seconds(" + timeout + "))";
		msg;
	};
	
	def executeActivity(activity, env) {
		def serviceWrapper := activity.getService();
		def selector := activity.getSelector();
		def args := activity.getArguments();
		def output := activity.getOutput();
		def msg := createAsyncMsg(selector, env.bind(args));
		def aMsg := eval: (read: msg) in: self;
		when: serviceWrapper.getTag() discovered: { |service|
			when: service<+aMsg becomes: { |reply| 
				// TODO: check if length of reply is the same as output
				def index := 1;
				while: { index <= reply.length() } do: {
					env.insert(output[index], reply[index]);
					index := index+1;
				};
				reply;
			};
		};
	};
	
	def executeActivityAndContinue(idx, activity, env) {
		def serviceWrapper := activity.getService();
		def selector := activity.getSelector();
		def args := activity.getArguments();
		def output := activity.getOutput();
		def msg := createAsyncMsg(selector, env.bind(args));
		def aMsg := eval: (read: msg) in: self;
		when: serviceWrapper.getTag() discovered: { |service|
			when: service<+aMsg becomes: { |reply| 
				// TODO: check if length of reply is the same as output
				def index := 1;
				while: { index <= reply.length() } do: {
					env.insert(output[index], reply[index]);
					index := index+1;
				};
				self.execute(idx+1, env);
			};
		};
	};
};



def Sequence := object: {
    def componentTable;
    def result;
	def resolver;
	def multi := 1;
	def started := 0;
	def addedFutures := 0;

	def init(cmpTable) {
    	componentTable := cmpTable;
        [result, resolver] := makeMultiFuture(multi);    
	};
	
	def start(env) {
		if: !(started == multi) then: {
			started := started + 1;
			execute(1, env);
		};
		result;
	};
	
	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		componentTable.each: { |cmp| if: (is: cmp taggedAs: Pattern) then: { cmp.addFuture(multi); }; };
		[result, resolver] := makeMultiFuture(multi);
	};
		
	def execute(idx, env) {	
		if: (idx < componentTable.length()) then: {
			def component := componentTable[idx];
			if: (is: component taggedAs: Act) then: {
				WorkflowPattern^executeActivityAndContinue(idx, component, env);
       		} else: { // component is a pattern
				when: component.start(env) becomes: { |reply|
					execute(idx+1, env);
				};
			};
		} else: {
			def component := componentTable[idx];
			if: (is: component taggedAs: Act) then: {
				resolver.resolve(WorkflowPattern^executeActivity(component, env));
       		} else: { // component is a pattern
				when: component.start(env) becomes: { |reply|
					resolver.resolve(reply);
				};
			};
		};
	};
} taggedAs: [Pattern];



def ParallelSplit := object: {
	def multi := 1;
	def started := 0;
    def componentTable;
	def futureTable;
	def result;
	def resolver;
	def addedFutures := 0;
	
    def init(bTable) {
		def i := 0;
		// convert the "pairs" [service, synchronize] in the component table to sequences
		def b[bTable.length()] { i := i+1; if: (is: bTable[i] taggedAs: Table) then: { Sequence.new(bTable[i]) } else: { bTable[i] }};
    	componentTable := b;

		// make a table to hold all the unresolved futures of the different branches
		def f[bTable.length()] { makeMultiFuture(multi); };
		futureTable := f;
		[result, resolver] := makeMultiFuture(multi);
		result;
    };

	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		componentTable.each: { |cmp| if: (is: cmp taggedAs: Pattern) then: { cmp.addFuture(multi); }; };
		def f[componentTable.length()] { makeMultiFuture(multi); };
		futureTable := f;
		[result, resolver] := makeMultiFuture(multi);
	};
  
	def start(env) {
		if: !(started == multi) then: {
			started := started + 1;
			execute(1, env);
			//when all components have been started, the parallelSplit is said to be "done"
			//and the result Future is resolved as usual (with the future table as value ...)
			def i := 0;
			def f[futureTable.length()] { i := i+1; futureTable[i][1]; };
			resolver.resolve(f);
		};
		result;   // TODO result teruggeven?
	};	
		
	def execute(idx, env) {
		def clonedEnv := Environment.new();
		clonedEnv.merge([env]);
		if: (idx <= componentTable.length()) then: {
			def component := componentTable[idx];	 
			// component is either an activity or a pattern    	
			if: (is: component taggedAs: Act) then: {
				futureTable[idx][2].resolve(WorkflowPattern^executeActivity(component, clonedEnv));
       		} else: { // component is a pattern
				when: component.start(clonedEnv) becomes: { |reply|
					futureTable[idx][2].resolve(reply);
				};
        	};
			execute(idx+1, env);
		};
	};
} taggedAs: [Pattern]; 



def Connection := object: {
	def result;
    def resolver;
    def sync := false;
   	def syncF;
    def syncResolver;
    def started := 0;
    def component;
	def multi := 1;
	def addedFutures := 0;
 
    def init(cmp) {
        component := cmp;
        // make a future for the result of the component
        [result, resolver] := makeMultiFuture(multi);
        if: (is: cmp taggedAs: SyncPattern) then: {
        	sync := true;
            [syncF, syncResolver] := makeMultiFuture(3); //TODO multi
            cmp.addSync(syncF);
        };
		if: (is: cmp taggedAs: MultiPattern) then: {
			cmp.addFuture(1);
		};
    };
 
    def start(env) {
   		// only start the component once
       	if: !(started == multi) then: {
         	started := started + 1;
        	execute(env);
       	};
     	result;
	};
	
	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: component taggedAs: Pattern) then: {
			component.addFuture(multi);
		};
	};
	
 
 	def execute(env) {
     	if: (is: component taggedAs: Pattern) then: {
       		// if we have a connection to a SyncPattern, notify it
         	if: sync then: {
            	syncResolver.resolve(env);
      		};
        	// start the component and resolve with its reply as usual
         	when: component.start(env) becomes: { |reply|
				resolver.resolve(reply);
           	};                       
     	} else: {
       		system.println("error: Connection made to non-pattern component.");
     	};
   	};     
} taggedAs: [Pattern];



// also Structured Synchronizing Merge
def Synchronize := object: {
    def syncTable := [];
    def nextComponent;
	def result := nil;
	def resolver;
	def started := false;
	def multi := 1;
	def nEnv := Environment.new();
	def addedFutures := 0;

    def init(cmp) {
    	nextComponent := cmp;
		[result, resolver] := makeMultiFuture(multi);  
    };

	def addSync(fut) {
		syncTable := syncTable + [[fut, 0, []]];
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: nextComponent taggedAs: Pattern) then: {
			nextComponent.addFuture(multi);
		};
	};

	def start(env) {
		// only start the component once (even with multifutures, is taken care of in execute method)
		if: !started then: {
			started := true;
			execute();
		};
		result;
	};
	
	def resolve(branch) {
		whenEach: branch[1] becomes: { |env| 
			branch[3] := branch[3] + [env];
			branch[2] := branch[2] + 1;
			checkSynchronization(env.id);   //TODO id too simple
		};
	};
	
	def checkSynchronization(idValue) {
		def envs := [];
		syncTable.each: { |branch| envs := envs + branch[3].filter:{ |env| env.id == idValue; }; };
		if: (envs.length() == syncTable.length()) then: {
			nEnv.merge(envs);
			if: (is: nextComponent taggedAs: Act) then: {
             	resolver.resolve(WorkflowPattern^executeActivity(nextComponent, nEnv));
  			} else: { // component is a pattern
          		when: nextComponent.start(nEnv) becomes: { |reply|
               		resolver.resolve(reply);
             	};
            };
		};
	};
	
	def execute() {
     	syncTable.each: { |branch| resolve(branch); };
    };
} taggedAs: [SyncPattern];



def ExclusiveChoice := object: {
        def test;
		def consequence;
		def alternative;
        def result;
        def resolver;
        def started := false;
 
    def init(block, then, else) {
        test := block;
		consequence := then;
		alternative := else;
        [result, resolver] := makeFuture();
        // if a component in the actionrules is a SyncPattern,
        // add the exclusiveChoice to its syncTable 
       // TODO: only for the one branch ?!?
        /*conditionActionRules.each: { |rule| 
			if: (is: rule[2] taggedAs: SyncPattern) then: {
        		rule[2].addSync(result);
        	};
        };*/
    };
 
  	def start(env) {
     	if: !started then: {
       		started := true;
        	execute(env);
    	};
      	result;
	};
 
  	def execute(env) {
		def method := test.method();
		def bindings := env.bind(method.parameters()); 
		if: (test.apply(bindings)) then: {
			if: (is: consequence taggedAs: Act) then: {
				resolver.resolve(WorkflowPattern^executeActivity(consequence, env));
       		} else: { // component is a pattern
				when: consequence.start(env) becomes: { |reply|
					resolver.resolve(reply);
				};
			};
		} else: { // alternative branch
			if: (is: alternative taggedAs: Act) then: {
				resolver.resolve(WorkflowPattern^executeActivity(alternative, env));
	       	} else: { // component is a pattern
				when: alternative.start(env) becomes: { |reply|
					resolver.resolve(reply);
				};
			};
		};
		//TODO: meer dan 2 branches                    
  	};
} taggedAs: [Pattern];



def SimpleMerge := object: {
	def branches := 0;
    def component;
	def result := nil;
	def resolver;

    def init(cmp) {
    	component := cmp;
        [result, resolver] := makeMultiFuture(branches);    
	};

	def addFuture(nbr) {
		branches := branches + 1;
		[result, resolver] := makeMultiFuture(branches);
		if: (is: component taggedAs: Pattern) then: {
			component.addFuture(branches);
		};
	};

	def start(env) {
		id := id  + 1;
		def clonedEnv := Environment.new();
		def clonedEnv.merge(env);
		clonedEnv.id := id;
		execute(clonedEnv);
		result;
	};
	
	def execute(env) {
     	if: (is: component taggedAs: Act) then: {
			resolver.resolve(WorkflowPattern^executeActivity(component, env));
  		} else: { // component is a pattern
       		when: component.start(env) becomes: { |reply|
				resolver.resolve(reply);
           	};
       	};
    };
} taggedAs: [MultiPattern];



def MultiChoice := object: {
	def multi := 1;
	def started := 0;
    def componentTable;
	def futureTable;
	def result;
	def resolver;
	def addedFutures := 0;
	def conditionActions;
	
    def init(bTable) {
		def i := 0;
		// convert the "pairs" [service, synchronize] in the component table to sequences
	//	def b[bTable.length()] { i := i+1; if: (is: bTable[i] taggedAs: Table) then: { Sequence.new(bTable[i]) } else: { bTable[i] }};
    	componentTable := bTable;

		// make a table to hold all the unresolved futures of the different branches
		[result, resolver] := makeMultiFuture(multi);
    };

	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		componentTable.each: { |cmp| if: (is: cmp[2] taggedAs: Pattern) then: { cmp[2].addFuture(multi); }; };
		[result, resolver] := makeMultiFuture(multi);
	};
  
	def start(env) {
		conditionActions := componentTable.filter: { |car| 
														def rule := car[1];
														def method := rule.method();
														def bindings := env.bind(method.parameters()); 
														rule.apply(bindings); };
		def f[conditionActions.length()] { makeMultiFuture(multi); };
		futureTable := f;
		if: (conditionActions.isEmpty()) then: {
			raise: XNoCondition.new("No matching condition found");
		} else: {
			if: !(started == multi) then: {
				started := started + 1;
				execute(1, env);
				//when all components have been started, the parallelSplit is said to be "done"
				//and the result Future is resolved as usual (with the future table as value ...)
				def i := 0;
				def f[futureTable.length()] { i := i+1; futureTable[i][1]; };
				resolver.resolve(f);
			};
		};
		result;
	};	
		
	def execute(idx, env) {
		def clonedEnv := clone: env;	
		if: (idx <= conditionActions.length()) then: {
			def component := conditionActions[idx][2];	 
			// component is either an activity or a pattern    	
			if: (is: component taggedAs: Act) then: {
				futureTable[idx][2].resolve(WorkflowPattern^executeActivity(component, clonedEnv));
       		} else: { // component is a pattern
				when: component.start(clonedEnv) becomes: { |reply|
					futureTable[idx][2].resolve(reply);
				};
        	};
			execute(idx+1, env);
		};
	};
} taggedAs: [Pattern];



def StructuredDiscriminator := object: {
    def syncTable := [];
    def nextComponent;
	def result := nil;
	def resolver;
	def started := false;
	def multi := 1;
	def addedFutures := 0;

    def init(cmp) {
    	nextComponent := cmp;
		[result, resolver] := makeFuture();   // TODO: MultiFuture
    };

	def addSync(fut) {
		syncTable := syncTable + [[fut, 0, []]];
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: nextComponent taggedAs: Pattern) then: {
			nextComponent.addFuture(multi);
		};
	};

	def start(env) {
		// only start the component once (even with multifutures, is taken care of in execute method)
		if: !started then: {
			started := true;
			execute();
		};
		result;
	};
	
	def resolve(branch) {
		whenEach: branch[1] becomes: { |env| 
			branch[3] := branch[3] + [env];
			branch[2] := branch[2] + 1;
			checkSynchronization(env.id, env);   //TODO id too simple
		};
	};
	
	def checkSynchronization(idValue, env) {
		def envs := [];
		syncTable.each:{ |branch| envs := envs + branch[3].filter:{ |env| env.id == idValue; }; };
		if: (envs.length() == 1) then: {
			if: (is: nextComponent taggedAs: Act) then: {
             	resolver.resolve(WorkflowPattern^executeActivity(nextComponent, env));
  			} else: { // component is a pattern
          		when: nextComponent.start(env) becomes: { |reply|
               		resolver.resolve(reply);
             	};
            };
		};
	};
		
	def execute() {
     	syncTable.each: { |branch| resolve(branch); };
    };
} taggedAs: [SyncPattern];



def StructuredPartialJoin := object: {
    def syncTable := [];
    def nextComponent;
	def result := nil;
	def resolver;
	def started := false;
	def multi := 1;
	def addedFutures := 0;
	def n := 0;

    def init(cmp, nbr) {
		n := nbr; // TODO: verify that nbr < number of branches
    	nextComponent := cmp;
		[result, resolver] := makeFuture();   // TODO: MultiFuture
    };

	def addSync(fut) {
		syncTable := syncTable + [[fut, 0, []]];
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: nextComponent taggedAs: Pattern) then: {
			nextComponent.addFuture(multi);
		};
	};

	def start(env) {
		// only start the component once (even with multifutures, is taken care of in execute method)
		if: !started then: {
			started := true;
			execute();
		};
		result;
	};
	
	def resolve(branch) {
		whenEach: branch[1] becomes: { |env| 
			branch[3] := branch[3] + [env];
			branch[2] := branch[2] + 1;
			checkSynchronization(env.id, env);   //TODO id too simple
		};
	};
	
	def checkSynchronization(idValue, env) {
		def envs := [];
		syncTable.each:{ |branch| envs := envs + branch[3].filter:{ |env| env.id == idValue; }; };
		if: (envs.length() == n) then: {
			if: (is: nextComponent taggedAs: Act) then: {
             	resolver.resolve(WorkflowPattern^executeActivity(nextComponent, env));
  			} else: { // component is a pattern
          		when: nextComponent.start(env) becomes: { |reply|
               		resolver.resolve(reply);
             	};
            };
		};
	};
		
	def execute() {
     	syncTable.each: { |branch| resolve(branch); };
    };
} taggedAs: [SyncPattern];



def Local := object: {
	def block;
	def result;
	def resolver;
	def started := 0;
	def multi := 1;
	def addedFutures := 0;
	
	def init(blk) {
		block := blk;
		[result, resolver] := makeMultiFuture(multi);
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
	};
	
	def start(env) {
		// make sure the component is ony started once
		if: ! (multi == started) then: {
			started := started + 1;
			resolver.resolve(block(env));
		};
		result;
	};
} taggedAs: [Pattern];



// TODO: what if compensation terminates (sub)workflow?
def Failure := object: {
	def component;
	def timeout;
	def compensatingCmp;
	def result := nil;
	def resolver;
	def started := false;
	
	def init(c, timeoutAndCmps) {
		[result, resolver] := makeFuture();
		component := c;
		timeout := timeoutAndCmps[1];
		compensatingCmp := timeoutAndCmps[2];
	};
	
	def start(env) {
		if: !started then: {
			started := true;
			execute(env, component);
		};
		result;
	};
	
	def execute(env, cmp) {
		if: (is: cmp taggedAs: Act) then: {
			def msg := WorkflowPattern^createTimeoutMsg(cmp.getSelector(), env.bind(cmp.getArguments()), timeout);
			def aMsg := eval: (read: msg) in: self;
			when: cmp.getService().getTag() discovered: { |service|
				system.println("Discovered service");
				when: service<+aMsg becomes: { |reply| 
					system.println("Received reply :: " + reply);
					// TODO: check if length of reply is the same as output
					def index := 1;
					while: { index <= reply.length() } do: {
						env.insert(cmp.getOutput()[index], reply[index]);
						index := index+1;
					};
					resolver.resolve(reply);
				} catch: TimeoutException using: { |e|
					system.println("service timeout");
					execute(env, compensatingCmp);
				};
			};
		} else: { // component is a pattern  
			// TODO @Due
			when: cmp.start(env)@FutureMessage becomes: { |reply|
           		resolver.resolve(reply);
			} catch: TimeoutException using: { |e|
				system.println("timeout in workflow pattern");
				execute(env, compensatingCmp);
			};
		};
	};
} taggedAs: [Pattern];



def Activity := object: {
	def serviceWrapper;
	def selector;
	def arguments;
	def output;
	
	def init(sw, sel, args, outputVars) {  
		serviceWrapper := sw;
		selector := sel;
		arguments := args;
		output := outputVars;
	};
	
	def getService() {
		serviceWrapper;
	};
	
	def getSelector() {
		selector;
	};
	
	def getArguments() {
		arguments;
	};
	
	def getOutput() {
		output;
	};
} taggedAs: [Act];



def createUnderstandingMirror(baseObject) {
 	extend: defaultMirror.new(baseObject) with: {
   		def doesNotUnderstand(selector) {
  			{ |@args| 
				Activity.new(baseObject, selector, args.select(1, args.length()), args[args.length()]) }  
   		};
  	};
};


def makeServiceWrapper(tag) {
	object: {
	
		def getTag() {
			tag;
		};
	} mirroredBy: {|emptyBase| createUnderstandingMirror(emptyBase)}
};



deftype outputT;

def output := extend: outputT with: {
	def annotateMessage(method) {
    	system.println("output");
    	method;
	};
};



deftype LocationService;
deftype WeatherService;
deftype GUIService;
deftype EndService;
deftype AService;
deftype BService;
deftype CService;
deftype DService;
deftype EService;
deftype FService;
deftype GService;
deftype HService;
deftype IService;

def locationServiceWrapper := makeServiceWrapper(LocationService);
def weatherServiceWrapper := makeServiceWrapper(WeatherService);
def guiServiceWrapper := makeServiceWrapper(GUIService);
def endServiceWrapper := makeServiceWrapper(EndService);
def asw := makeServiceWrapper(AService);
def bsw := makeServiceWrapper(BService);
def csw := makeServiceWrapper(CService);
def dsw := makeServiceWrapper(DService);
def esw := makeServiceWrapper(EService);
def fsw := makeServiceWrapper(FService);
def gsw := makeServiceWrapper(GService);
def hsw := makeServiceWrapper(HService);
def isw := makeServiceWrapper(IService);


/*
// Testing simple merge
def smerge1 := SimpleMerge.new(esw.e([`e]));
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);
sequence1.start(env);
*/

/*
// Testing simple merge
def smerge1 := SimpleMerge.new(Sequence.new([ esw.e([`e]), fsw.f([`f]) ]));
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);
sequence1.start(env);
*/

/*
// Testing simple merge
def smerge := SimpleMerge.new( ParallelSplit.new([ [dsw.d([`d]), Local.new({|env| env.print()})],
                                                   [esw.e([`e]), Local.new({|env| env.print()})] ]) );
def parSplit2 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge)],
                                     [csw.c([`c]), Connection.new(smerge)] ]);
def smSeq := Sequence.new([ asw.a([`a]), parSplit2 ]);
env.id := id + 1;
id := id + 1;
smSeq.start(env);
*/

/*
// Testing simple merge
def parSplit2 := ParallelSplit.new([ [esw.e([`e])],
                                     [fsw.f([`f])] ]);
def smerge1 := SimpleMerge.new(parSplit2);
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);
sequence1.start(env);
*/

/*
// Testing simple merge
def smerge3 := SimpleMerge.new(gsw.g([`g]));
def smerge1 := SimpleMerge.new(Connection.new(smerge3));
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);


def smerge2 := SimpleMerge.new(Connection.new(smerge3));
def parSplit2 := ParallelSplit.new([ [esw.e([`e]), Connection.new(smerge2)],
                                     [fsw.f([`f]), Connection.new(smerge2)] ]);
def sequence2 := Sequence.new([ dsw.d([`d]), parSplit2 ]);

sequence1.start(env);
sequence2.start(env);
*/

/*
// Testing simple merge, parallel split, synchronize and sequence
def sync := Synchronize.new( Sequence.new([ fsw.f([`f]), Local.new({|env| env.print()}) ]) );
def smerge := SimpleMerge.new( ParallelSplit.new([ [dsw.d([`d]), Connection.new(sync)],
                                                   [esw.e([`e]), Connection.new(sync)] ]) );
def parSplit2 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge)],
                                     [csw.c([`c]), Connection.new(smerge)] ]);
def smSeq := Sequence.new([ asw.a([`a]), parSplit2 ]);
env.id := id + 1;
id := id + 1;
smSeq.start(env);
*/

/*
// Testing simple merge, followed by parallel split and synchronize
def sync := Synchronize.new( fsw.f([`f]) );
def smerge := SimpleMerge.new( ParallelSplit.new([ [dsw.d([`d]), Connection.new(sync)],
                                                   [esw.e([`e]), Connection.new(sync)] ]) );
def parSplit2 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge)],
                                     [csw.c([`c]), Connection.new(smerge)] ]);
def smSeq := Sequence.new([ asw.a([`a]), parSplit2 ]);
env.id := id + 1;
id := id + 1;
smSeq.start(env);
*/

/*
// Testing simple merge, followed by a sequence
def smerge1 := SimpleMerge.new(Sequence.new([ csw.c([`c]), dsw.d([`d]), esw.e([`e]), Local.new({|env| env.print()}) ]));
def parSplit1 := ParallelSplit.new([ [asw.a([`a]), Connection.new(smerge1)],
                                     [bsw.b([`b]), Connection.new(smerge1)] ]);
parSplit1.start(env);
*/

/*
// Testing multi choice
def mc := MultiChoice.new( [ [{|a| a < 2}, bsw.b([`b])], [ {|a| a > 100}, csw.c([`c])], [{|gps| gps > 99}, dsw.d([`d])] ] );
def mcSeq := Sequence.new([ asw.a([`a]), mc, Local.new({|env| env.print()}) ]);
mcSeq.start(env);
*/

/*
// Testing structured discriminator
def structDiscr := StructuredDiscriminator.new( dsw.d([`d]) );
def parSplit := ParallelSplit.new([ [bsw.b([`b]), Connection.new(structDiscr)],
                                     [csw.c([`c]), esw.e([`e]), fsw.f([`f]), gsw.g([`g]), Connection.new(structDiscr)] ]);
def sdSeq := Sequence.new([ asw.a([`a]), parSplit ]);
sdSeq.start(env);
*/

/*
// Testing structured partial join
def spJoin := StructuredPartialJoin.new( dsw.d([`d]), 2 );
def parSplit := ParallelSplit.new([ [bsw.b([`b]), Connection.new(spJoin)],
                                     [csw.c([`c]), esw.e([`e]), fsw.f([`f]), gsw.g([`g]), Connection.new(spJoin)],
 									 [isw.i([`i]), Connection.new(spJoin)] ]);
def sdSeq := Sequence.new([ asw.a([`a]), parSplit ]);
sdSeq.start(env);
*/

/* 
// Testing merging of environments
def sync := Synchronize.new( Sequence.new([ dsw.d([`d]), Local.new({|env| env.print()}) ]) );
def parSplit := ParallelSplit.new([ [bsw.b([`a]), Connection.new(sync)],
                                     [csw.c([`c]), esw.e([`e]), fsw.f([`f]), gsw.g([`g]), Connection.new(sync)] ]);
def sSeq := Sequence.new([ asw.a([`a]), parSplit ]);
id := id + 1;
env.id := id;
sSeq.start(env);
*/