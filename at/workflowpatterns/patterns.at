import /.at.lang.futures;
import /.at.lang.multifutures;
enableFutures(false);
network.online();


 
deftype Pattern;
deftype Service;
deftype Table;
		

def Stop := object: {
	def component;

    def init(cmp) {
    	component := cmp;
    };
	
  def start() {
	execute(component);
  };
	
 def execute(cmp) {
	if: (is: cmp taggedAs: Service) then: {
     	when: cmp.getTag() discovered: { |service|
            when: service<-start()@FutureMessage becomes: { |reply|
                reply;
            };
        };
    } else: { // component is a pattern 
		whenEach: cmp.start() becomes: { |resultcmp|
			// resultcmp is the last component (service, pattern or table) that still must be executed
			if: (is: resultcmp taggedAs: Table) then: {
				// table can contain both services and patterns
				resultcmp.each: { |cmp| execute(cmp); };
			} else: { 
				if: (is: resultcmp taggedAs: Pattern) then: {
					execute(resultcmp);
				} else: { // resultcmp is a service
					when: resultcmp.getTag() discovered: { |service|
						when: service<-start()@FutureMessage becomes: { |end|
							end;
						};
					};
				};
			};
        };
	 };
  };
} taggedAs: [Pattern];




def Sequence := object: {
    def componentTable;
	def maximum := 1;
    def [result, resolver]; 

    def init(cmpTable) {
    	componentTable := cmpTable;
		foreach: { |component| 
			if: (is: component taggedAs: Pattern) then: {
				if: (component.max() > maximum) then: {
					maximum := component.max();
				};
			};
		} in: componentTable;
    };

    def max() {
		maximum;
	};

    def start() {
	    if:(result.isResolved()) then: {  //TODO
		   result;
		} else: {
			if: (result.isFuture()) then: {  //TODO
				when: result becomes: { |reply|
					reply;
				};
			} else: {
			 	[result, resolver] := makeMultiFuture(maximum); 
				execute(1, componentTable[1], result);
				result;
			};
		};
	};
		
	def executeService(idx, component, result, service) {
		when: service<-start()@Due(seconds(2)) becomes: { |reply|
        	if: (idx == (componentTable.length()) - 1) then: {
				// future is resolved with last component of the sequence
				(reflect: result)<-resolveWithValue(componentTable[componentTable.length()])@FutureMessage;
			} else: {
               	execute(idx + 1, componentTable[idx + 1], result);
            };
		}
		catch: TimeoutException using: { |e|
			system.println("service offline");
			execute(idx, component, result);
		};
	};
		
	def execute(idx, component, result) {
		// component can be either service or pattern
        if: (is: component taggedAs: Service) then: {
			system.println(" component " + component.getTag());
        	when: component.getTag() discovered: { |service|
            	executeService(idx, component, result, service);
            };
       	} else: { // component is a pattern
			whenEach: component.start() becomes: { |resultcmp|
				// resultcmp can be either a service or pattern
				execute(idx, resultcmp, result);
			};
        };
	};
} taggedAs: [Pattern];

 


def ParallelSplit := object: {
	def component;
    def componentTable;
	def maximum := 1;

    def init(cmp, cmpTable) {
		component := cmp;
    	componentTable := cmpTable;
		if: (is: component taggedAs: Pattern) then: {
			maximum := component.max();
		};
    };

	def max() {
		maximum;
	};
  
	def start() {
		def [result, resolver] := makeMultiFuture(maximum); 
		execute(component, result);
		result;
	};	
		
	def execute(component, result) {
		// component can be either service or pattern
		if: (is: component taggedAs: Service) then: {
			when: component.getTag() discovered: { |service|
				when: service<-start() becomes: { |reply|
					(reflect: result)<-resolveWithValue(componentTable);
				};
			};
		} else: { // component is a pattern
			when: component.start() becomes: { |endcmp| 
				execute(endcmp, result);
			};
		};
	};
} taggedAs: [Pattern];




def Synchronize := object: {
    def componentTable;
	def component;
	def maximum := 1;

    def init(cmpTable, cmp) {
		componentTable := cmpTable;
    	component := cmp;
		foreach: { |component| 
			if: (is: component taggedAs: Pattern) then: {
				if: (component.max() > maximum) then: {
					maximum := component.max();
				};
			};
		} in: componentTable;
    };

	def max() {
		maximum;
	};

	def start() {
		def [result, resolver] := makeMultiFuture(maximum); 
		invokeServices(1, componentTable, result, []);
		result;
	};
		
	def invokeServices(idx, table, result, replies) {
		if: (idx > table.length()) then: {
			execute(1, replies[1], result, replies);
		} else: {
			def cmp := table[idx];
			// cmp is a service or a pattern
			if: (is: cmp taggedAs: Service) then: {
				when: cmp.getTag() discovered: { |service|
					replies := replies + [service<-start()]; 
					invokeServices(idx + 1, table, result, replies); 
				};
			} else: { // cmp is a pattern
				replies := replies + [cmp.start()]; 
				invokeServices(idx + 1, table, result, replies);
			};			
		};
	};
	
	def execute(idx, ref, result, replies) {
		when: ref becomes: { |reply|
			// reply can be either a pattern, service, table or normal reply
			if: (is: reply taggedAs: Table) then: {
				invokeServices(1, reply, result, []);
				if: (idx == replies.length()) then: {
					(reflect: result)<-resolveWithValue(component);
				} else: {
					execute(idx + 1, replies[idx + 1], result, replies);
				};				
			} else: { // reply is a pattern or service
				if: (is: reply taggedAs: Pattern) then: {
					when: reply.start() becomes: { |endcmp|
						execute(idx, endcmp, result, replies); 
						if: (idx == replies.length()) then: { //deze check moet gedaan worde voor ge execute oproept denk ik
							(reflect: result)<-resolveWithValue(component);
						} else: {
							execute(idx + 1, replies[idx + 1], result, replies);   
						};
					};
				} else: { // reply is either a service or a reply (of a service)
					if: (is: reply taggedAs: Service) then: {
						when: reply.getTag() discovered: { |service|
							when: service<-start() becomes: { |reply|
								if: (idx == replies.length()) then: {
									(reflect: result)<-resolveWithValue(component);
								} else: {
									execute(idx + 1, replies[idx + 1], result, replies);
								};
							};
						};
					} else: { // reply is a reply (of a service)
						if: (idx == replies.length()) then: {
							(reflect: result)<-resolveWithValue(component);
						} else: {
							execute(idx + 1, replies[idx + 1], result, replies);
						};
					};
				};
			};
		};
	};
} taggedAs: [Pattern];




def ExclusiveChoice := object: {
	def component;
	def conditionActionRules;
	def maximum := 1;

    def init(cmp, car) {
		component := cmp;
    	conditionActionRules := car;
		if: (is: component taggedAs: Pattern) then: {
			maximum := component.max();
		};
    };
  
	def max() {
		maximum;
	};

	def start() {
		def [result, resolver] := makeMultiFuture(maximum); 
		execute(component, result);
		result;
	};
		
	def execute(cmp, result) {
		// cmp can be either a service or a pattern
		if: (is: cmp taggedAs: Service) then: {
           	when: cmp.getTag() discovered: { |service|
               	when: service<-start() becomes: { |reply|
					def conditionActions := conditionActionRules.filter: { |rule| rule[1](reply) };
					if: (conditionActions.isEmpty()) then: {
						raise: XNoCondition.new("No matching condition found");
					} else: {
						(reflect: result)<-resolveWithValue(conditionActions[1][2]);
					};
				};
			};
		} else: { // cmp is a pattern
			when: component.start() becomes: { |endcmp|
				// endcmp can be either a service or a pattern
				execute(endcmp, result); 
			};
		}; 			
	};
} taggedAs: [Pattern];



/*
def SimpleMerge := object: {
	def serviceTag;
	def serviceTypeTable;
	def maximum := 1;

    def init(stt, st) {
		serviceTag := st;
    	serviceTypeTable := stt;
		foreach: { |component| 
			if: (is: component taggedAs: MultiPattern) then: {
				maximum := maximum + component.max();
			} else: {
				maximum := maximum + 1;
			};
			} in: serviceTypeTable;
    };

	def max() {
		maximum;
	};
  
	def start() {
		def [result, resolver] := makeMultiFuture(maximum);
		def execute(idx) {
			def component := serviceTypeTable[idx];
			if: (is: component taggedAs: Service) then: {
				when: component.getTag() discovered: { |service|
					when: service<-start() becomes: { |reply|
						(reflect: result)<-resolveWithValue(serviceTag);
					};
				};
				if: (idx < serviceTypeTable.length()) then: {
		            execute(idx + 1);
		        };
			} else: {
				if: (is: component taggedAs: MultiPattern) then: {
					whenEach: component.start() becomes: { |reply|
						when: reply.getTag() discovered: { |service|
							when: service<-start() becomes: { |end|
								(reflect: result)<-resolveWithValue(serviceTag);
							};
						};
					};
					if: (idx < (serviceTypeTable.length())) then: {  
						execute(idx + 1);
					};
				} else: {
					when: serviceTag.start() becomes: { |serviceWrapper| 
						when: serviceWrapper.getTag() discovered: { |end|
							when: end<-start() becomes: { |reply|
								(reflect: result)<-resolveWithValue(serviceTag);
							};
						};
					};
					if: (idx < serviceTypeTable.length()) then: {
		        		execute(idx + 1);
					};
				};
			};
		};
		execute(1);
		result;
	};
} taggedAs: [Pattern];
*/



def MultiChoice := object: {
	def serviceTag;
	def conditionActionRules;

    def init(st, car) {
		serviceTag := st;
    	conditionActionRules := car;
    };
  
	def start() {
		def result := makeFuture()[1];
		if: (is: serviceTag taggedAs: Service) then: {
           	when: serviceTag.getTag() discovered: { |service|
				when: service<-start() becomes: { |reply|
					def conditionActions := conditionActionRules.filter: { |rule| rule[1](reply) };
					if: (conditionActions.isEmpty()) then: {
						raise: XNoCondition.new("No matching condition found");
					} else: {
						(reflect: result)<-resolveWithValue(conditionActions.map: { |rule| rule[2] });
					};
				};
			};
		} else: {
			when: serviceTag.start() becomes: { |serviceWrapper| 
				when: serviceWrapper.getTag() discovered: { |end|
					when: end<-start() becomes: { |reply|
						def conditionActions := conditionActionRules.filter: { |rule| rule[1](reply) };
						if: (conditionActions.isEmpty()) then: {
							raise: XNoCondition.new("No matching condition found");
						} else: {
							(reflect: result)<-resolveWithValue(conditionActions.map: { |rule| rule[2] });
						};
					};
				};
			};
		};
		result;
	};
} taggedAs: [Pattern];




def StructuredDiscriminator := object: {
	def serviceTag;
	def serviceTypeTable;

    def init(stt, st) {
		serviceTag := st;
    	serviceTypeTable := stt;
    };
  
	def start() {
		def future := makeFuture()[1];
		def flag := true;
		def execute(idx) {
			def component := serviceTypeTable[idx];
			if: (is: component taggedAs: Service) then: {
				when: component.getTag() discovered: { |service|
					when: service<-start() becomes: { |reply|
						if: flag then: {
							flag := false;
							(reflect: future).resolveWithValue(serviceTag);
						}
					};
				};
			} else: { 
				when: component.start() becomes: { |serviceWrapper|
					when: serviceWrapper.getTag() discovered: { |service|
						when: service<-start() becomes: { |reply|
							if: flag then: {
								 flag := false;
				                 (reflect: future).resolveWithValue(serviceTag);
							 };
						};
					};
				};
			};
		    if: (idx < serviceTypeTable.length()) then: {
		        execute(idx + 1);
		    };
		};
		execute(1);
		future;
	};
} taggedAs: [Pattern];




def StructuredPartialJoin := object: {
	def serviceTag;
	def number;
	def serviceTypeTable;

    def init(nbr, stt, st) {
		serviceTag := st; 
    	serviceTypeTable := stt;
		number := nbr;
    };
  
	def start() {
		def future := makeFuture()[1];
		def nr := 0;
		def execute(idx) {
			def component := serviceTypeTable[idx];
			if: (is: component taggedAs: Service) then: {
				when: component.getTag() discovered: { |service|
					when: service<-start() becomes: { |reply|
						if: (nr <= number) then: {
							 nr := nr + 1;
		                     (reflect: future).resolveWithValue(serviceTag);
						};
					};
				};
				if: (idx < serviceTypeTable.length()) then: {
		            execute(idx + 1);
		        };
			} else: {
				when: component.start() becomes: { |serviceWrapper|
					when: serviceWrapper.getTag() discovered: { |service| 
						when: service<-start() becomes: { |reply|
							if: (nr <= number) then: {
								 nr := nr + 1;
			                     (reflect: future).resolveWithValue(serviceTag);
							};
						};
					};
				};
				if: (idx < serviceTypeTable.length()) then: {
		            execute(idx + 1);
		        };
			};
		};
		execute(1);
		future;
	};
} taggedAs: [Pattern];





def ServiceWrapper := object: {
    def serviceTag;
      
    def init(tag) {
    	serviceTag := tag;
    };

    def getTag() {
    	serviceTag;
   	};
} taggedAs: [Service];




deftype Service1;
deftype Service2;
deftype Service3;
deftype Service4;
deftype Service5;
deftype Service6;
deftype Service7;
deftype Service8;
deftype Service9;
deftype Service10;
deftype Service11;


def s1 := ServiceWrapper.new(Service1);
def s2 := ServiceWrapper.new(Service2);
def s3 := ServiceWrapper.new(Service3);
def s4 := ServiceWrapper.new(Service4);
def s5 := ServiceWrapper.new(Service5);
def s6 := ServiceWrapper.new(Service6);
def s7 := ServiceWrapper.new(Service7);
def s8 := ServiceWrapper.new(Service8);
def s9 := ServiceWrapper.new(Service9);
def s10 := ServiceWrapper.new(Service10);
def s11 := ServiceWrapper.new(Service11);


def seq0 := Sequence.new([ s2, s2, s2 ]);
def seq1 := Sequence.new([ s3, seq0, s3]);
def seq2 := Sequence.new([ s2, s3, s3, seq0]);
def seq3 := Sequence.new([ s2, s3, s11, s10, s4 ]);


/*
def stop := Stop.new(seq0);
stop.start();
*/

/*
def stop := Stop.new(seq1);
stop.start();
*/

/*
def stop := Stop.new(seq2);
stop.start();
*/


def stop := Stop.new(seq3);
stop.start();



def par1 := ParallelSplit.new(seq3, [s5, s6]);
def par2 := ParallelSplit.new(seq3, [seq0, s5]);

/*
def stop := Stop.new(par1);
stop.start();
*/

/*
def stop := Stop.new(par2);
stop.start();
*/

def sync1 := Synchronize.new([s4, s2, s2, s3], s6);
def sync2 := Synchronize.new([par1], s10);

/*
def stop := Stop.new(sync1);
stop.start();
*/

/*
def stop := Stop.new(sync2);
stop.start();
*/

def seq4 := Sequence.new([s2, s3, s7]);
def exc1 := ExclusiveChoice.new(seq4, [ [ { |reply| reply }, s5 ], [ { |reply| !reply }, s6 ]]);

/*
def stop := Stop.new(exc1);
stop.start();
*/
/*
def sm1 := SimpleMerge.new([s2, s3], s4);
def seq5 := Sequence.new([sm1, s9, s10]);
def sm2 := SimpleMerge.new([sm1, s9], s10);
*/
/*
def stop := Stop.new(sm1);
stop.start();
*/

/*
def stop := Stop.new(seq5);
stop.start();
*/

/*
def stop := Stop.new(sm2);
stop.start();
*/

def mc1 := MultiChoice.new(s7, [ [ { |reply| reply }, s5 ], [ { |reply| !reply }, s6 ], [ { |reply| reply }, s4 ] ]);
def mc2 := MultiChoice.new(s7, [ [ { |reply| reply }, seq1 ], [ { |reply| !reply }, s6 ], [ { |reply| reply }, s4 ] ]);

/*
def stop := Stop.new(mc1);
stop.start();
*/

/*
def stop := Stop.new(mc2);
stop.start();
*/

def sd1 := StructuredDiscriminator.new([s3, s4, s5], s2);

/*
def stop := Stop.new(sd1);
stop.start();
*/

def spj1 := StructuredPartialJoin.new(2, [s2, s6, s4], s3);

/*
def stop := Stop.new(spj1);
stop.start();
*/


