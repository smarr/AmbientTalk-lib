/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2012
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
**/

/** 
 * Implementation of local debugger manager module of the AmbientTalk debugger called REME-D (read remedy). 
 * More information about REME-D at AmbientTalk's google code site.
 * @author egonzale
**/
deftype DebuggerActor;
deftype LocalManagerModule;
deftype Debug <: /.at.lang.types.AsyncMessage;
def ExternalMessage := /.at.lang.types.ExternalMessage;

//create DebuggerException used to notify cases which shouldn't not happen.
deftype DebuggerException <: /.at.lang.types.Exception;
def XDebuggerException := /.at.lang.exceptions.createException(DebuggerException);

def HashMap :=  jlobby.java.util.HashMap;
def atHashMap :=  /.at.collections.java.hashMap.HashMap;
// local manager life cycle constants.
// all messages arrived in INITIAL 
//correspond to initialization code, so we let them pass
def INITIAL := 0; 
// RUNNING is initially set when debuggerActor 
// calls start() on the local manager
def RUNNING := 1;
// PAUSE is set due to a message breakpoint (implicit activation)  
// or a pause command is received (explicit activation).
def PAUSED := 2;
// to distinguish between the two paused states:
def COMMAND := 3;
def BREAKPOINT := 4;
def STEPINTO := 5;
def STEPOVER := 6;
def STEPRETURN := 7;

def debuggerUtilModule := /.at.support.debugger.util;
 	
/* Not possible to use annotateMessage //system because 
line number get screwed up and we need it for breakpoints*/
deftype Pause <: /.at.lang.types.AsyncMessage;
def extendWithPauseBhv(msg, actorId, debuggerActor) {
  if: (	is: msg taggedAs: Pause ) then:{
    msg;  // do not wrap it again.
  } else:{	
    extend: msg with: { |actorId, debuggerActor|
      def alreadyPaused := false;
      def process(rcv) {
        def actor := reflectOnActor();
        if: !(is: actor taggedAs: /.at.support.debugger.localManager.LocalManagerModule) then: {
          if: ((reflect: actor).respondsTo(`debuggeable)) then:{
 	         /.at.support.debugger.localManager.enableLocalManager(true, false, debuggerActor);
 	         rcv <+ self;
		  } else:{
		     raise: /.at.support.debugger.localManager.XDebuggerException.new("cannot infect an non-debuggeable actor");
		  };
	    } else: {
	      //already enabled.
	      super^process(rcv);
	    };
	  };
	  def getLocationLine(){super^getLocationLine() };
	  def getLocationFilename(){super^getLocationFilename()};
	  def getSenderActorId(){actorId}; 
    } taggedAs: [Pause, /.at.lang.types.Isolate];
  };
};

def makeLocalManager(actor, debuggingSession, debuggerActorFarRef){
  extend: actor with: {
	def debuggingState := INITIAL; 
	def pausedState := INITIAL;
	def debuggerActor := nil;
	def disconnectedFromDebuggerActor := false;
	def actorId := debuggerUtilModule.generateId();
	def inbox := []; // stores base-level messages that cannot be process because actor is paused.
	def codeBreakpoints := atHashMap.new();
	def conditionalBreakpoints := atHashMap.new(); // as hashmap for removals.
	// helper methods
	def isStarted() { (debuggingState != INITIAL) };
	def isPaused(){ (debuggingState == PAUSED) };
	def isPausedByBreakpoint(){ (pausedState == BREAKPOINT) };
	def isInStepInto(){ (pausedState == STEPINTO) };
	def isInStepOver(){ (pausedState == STEPOVER) };
	def isInStepReturn() {(pausedState == STEPRETURN) };
	def getActorId() { actorId };
	def actorMirror := self;
	//def debuggeable := true;
	def filename := nil;
	def setFilename(f) { filename := f};
	def sourceLocation := /.at.support.util.getSourceLocation(self.behaviour);
	
	def matchesConditionalBreakpoint(rcv,msg) {
		{ |return|
			conditionalBreakpoints.each: { |bId, breakpoint| 
				if: breakpoint.matches(rcv,msg) then: { return(true) };
			};
			false;
		}.escape();
	};
	
	def matchesCodeBreakpoint(filename, lineNumber, rcv,msg) {
		def res := false;
	    def b := debuggerUtilModule.codeBreakpoint.new(filename, lineNumber);
		def bres := codeBreakpoints.get(b.getBreakpointId);
		if: (nil != bres) then:{
			res := bres.matches(rcv,msg);
		};
		res;
	};
	
	def matchesCodeMethodBreakpoint(rcv,msg){
		def rcvMethods := (reflect: rcv).listMethods();
		{ |return|
			rcvMethods.each:{ |method| 
				def sourceLocation := /.at.support.util.getSourceLocation(method);
				if: nil != sourceLocation then: {
				 	if: matchesCodeBreakpoint(sourceLocation.fileName, sourceLocation.line, rcv,msg) then: {return(true)};
				};
			};
			false;
		}.escape();
	};
		
	def isBreakpointedReception(rcv,msg){
		def res := false;
		if: (is: msg taggedAs: Pause) then: {
			// if it carries the Pause tag = the async. message send was breakpointed.
	    	res := !(msg.alreadyPaused); 
	    } else:{
	    	// check whether the message invokes a method with the name that matches a code method breakpoints.
			// or the <rcv, message> pair matches a condition breakpoint.
 			res := (matchesCodeMethodBreakpoint(rcv,msg).or:{
	      		matchesConditionalBreakpoint(rcv,msg)
	      	});
		};
		res;
	};
	
	def isBreakpointedSend(rcv,msg) {
	  def lineNumber := msg.getLocationLine();
	  def filename := msg.getLocationFilename();
	  def res;	   
	  if: ((nil != lineNumber).and: { nil != filename }) then:{
	    if: (is: msg taggedAs: Pause) then: {
	      res := !(msg.alreadyPaused); 
	    } else:{
	    // check whether the message send matches a message breakpoint. 
			res := matchesCodeBreakpoint(filename, lineNumber, rcv, msg);
	    };
	  } else:{
	    res := ((is: msg taggedAs: Pause).and:{ !(msg.alreadyPaused)});
	  };
	  res;
	
	};
	
	def getFields(obj){			
		def fields := (reflect: obj).listFields();
		//def state :=  debuggerUtilModule.createActorState(fields.length());
		def actorState := debuggerUtilModule.actorState.new();
		fields.each: { |field| 
			/*def val := field.readField();
			def convertVal := /.at.lang.firstclassrefs.eventualref: {|rcv, msg| 
				if:(msg.selector.text() == "_unWrap") then:{ val };
			} to: val;
			actorState.addField(field.name.text(),  convertVal); */
			actorState.put(field.name.text(), (print: field.readField()));
	     };	      	
	     actorState;
	};
		
	def getActorState() {			
		getFields(self.behaviour);
	};
	    
	def pauseAndBuffer(rcv,msg, state := INITIAL){ 
	  inbox := inbox + [[msg, rcv]];
      if: isStarted() then: {        
        debuggerActor<-updateInbox(getActorId(),msg)@Debug; 
        // if it was not already paused then inform the debugger actor
        if: !isPaused() then: { 
        	debuggerActor<-actorPaused(getActorId(),getActorState())@Debug;
        };
        debuggingState := PAUSED;
      };
      pausedState := state;
	};
	def scheduleAllMessagesFromInbox(start := true){
	  inbox.each: { |letter|
	    def msg := letter[1]; 
	    def rcv := letter[2];
		if: ( start.and: {is: msg taggedAs: Pause}) then:{
		  // if the message to re-schedule was a pause one, it means this time it needs to be executed.
		  msg.alreadyPaused := true;
		};
		//if: start then: {
        self<-schedule(rcv,msg)@Debug; //needs to be async to be evaluated in next turn!
		//} else: { self.schedule(rcv,msg)};
        //debuggerActor<-updateInbox(actorId, msg, false)@Debug;
	  };
	  inbox := [];
	};
	// rememver you can re-schedule a message which is not breakpointed 
    // but it is paused because of an explicit pause command!
	def scheduleOneMessageFromInbox() {
	  def length := inbox.length();
	  if: (length > 0 ) then:{
	    def msg := (inbox[1])[1]; //[msg,rcv]
        def rcv := (inbox[1])[2];
        if: (is: msg taggedAs: Pause) then:{ 
          // if the message to re-schedule was a pause one, it means this time it needs to be executed.
		   msg.alreadyPaused := true;
	    };
        // check on the length of the inbox, maybe it was the last message.
        if: (length > 1) then: {
	      inbox := inbox.select(2, length); 
	    } else:{ 
	      inbox := [];
	    };
        self.schedule(rcv,msg); 
   	  // TODO: This message needs to be sent if we would like the UI to build the causal links.
      //  debuggerActor<-updateInbox(actorId, msg, false)@Debug;
      };
    };
	
	
	// Overriding serve() to call the leave(msg) method 
    // as AmbientTalk does not provide this meta hook natively.
	def serve() {
	  def inboxLetters := self.listIncomingLetters();
	  if: (inboxLetters.length() > 0) then: {
	    def letter := inboxLetters[1];
	    def msg := letter.message();
	    def res := super^serve();
	    leave(msg);
	    res;
	  } 
	};
	
	// leave(msg) will put back the pausedState to initial 
    // in the case we are stepping into a breakpointed message
	// so that send() stops marking outgoing messages as breakpointed
    // when the turn executing a breakpointed message is ended.
	def leave(msg) {
	/*	if: (!(is: msg taggedAs: Debug).and:{!(is: msg taggedAs: ExternalMessage)}) then: {
	  		debuggerActor<-updateInbox(actorId, msg, false)@Debug;
	  	};*/
	  	if: ((is: msg taggedAs: Pause)) then: {
	    	if: isInStepInto() then:{
	    		pausedState := INITIAL;
	    	} else: {
	    		if: (isInStepReturn().or:{isInStepOver()}) then:{
	    			pausedState := INITIAL;
	    			debuggingState := RUNNING;
	        		debuggerActor<-actorResumed(getActorId())@Debug;
	        		if: isInStepOver()	then: { futureBreakpoint := nil };	
	    		};
	  		};
	  	};
	};
	
	def futureBreakpoint := nil;
	
	// meta actor protocol methods
	def schedule(rcv, msg){
	  // is base-level or debug-level message?
	 if: (is: msg taggedAs: Debug) then:{
		super^schedule(rcv,msg);			
	  } else: {
		if: isStarted() then:{		  
		  // a base-level message gets buffered if the actor is paused
		  // Note that a @Pause message gets also buffered, so that it pauses later the actor!
	      if: isPaused() then: { 
	        if: ((isInStepInto()).or:{isInStepOver()}) then:{
	          // This means we got the message breakpointed that needs to be executed
			  // or that we are paused in a message, and the user click on step over
			  debuggerActor<-updateInbox(actorId, msg, false)@Debug;
	          super^schedule(rcv,msg);
	        } else: {
	          	if: isInStepReturn() then: {
	          		debuggerActor<-updateInbox(actorId, msg, false)@Debug;
	          		def res := super^schedule(rcv,msg);
	          		// means we got a futurized message that needs to be executed with a conditional breakpoint.
					def closure := {|receiver, message| (receiver == (reflect: msg).invokeField(msg, `future)).and:{ (message.selector == `resolveWithValue).or:{message.selector == `ruinWithValue} } };
					futureBreakpoint := debuggerUtilModule.conditionalBreakpoint.new(closure);
	          		res;
	          	} else:{
	   				//here for all messages arriving to a paused actor
	            	pauseAndBuffer(rcv, msg, pausedState); 
				}
		    };
		  } else: { //else-isPaused
		    //actor running
		    //check whether the msg has a breakpoint.
            if: isBreakpointedReception(rcv,msg) then:{
              pauseAndBuffer(rcv,extendWithPauseBhv(msg, actorId, debuggerActor), BREAKPOINT);
            } else: {
              // while running it doesn't have to notify the debuggerActor.
		      super^schedule(rcv,msg); 
		    }; //if-isBreakpointed
	      };//if-isPaused
        } else: { // else-isStarted. 
		  // actor not started
          if: (is: msg taggedAs: ExternalMessage) then: {
           // base-level message generated by the interpreter, e.g. to apply when:discovered listeners
		  // arrived when the localManager is not started yet should be processed.
            super^schedule(rcv,msg);
          } else:{
		  // application base-level messages are paused and buffered till the localManager gets synchronized with the debuggerActor.
	      pauseAndBuffer(rcv,msg);
	      }
	    }; //if-isStarted
	  }; //-ifDebug
	};
	
	// We cannot attach the Pause annotation with def createMessage(sel, args, types) and annotateMessage(msg)
    // because the lineNumbers get messed up. We intercept send where the msg is already well-formed.
	def send(rcv, msg){
	//  if: isStarted() then:{ 
      def types := tagsOf: msg;
      if: (nil != (types.find: { |type| type.isSubtypeOf(Debug) })) then: {
        //sending a debug-level message
      	if: (disconnectedFromDebuggerActor) then: {
  	      //while disconnected, @Debug messages toward the debuggerActor are thrown away.
  		} else: {
  		  //let the @Debug messages be sent to the debuggerActor even if the actor is paused.
 		  super^send(rcv,msg);
  		}
      } else: {
         // sending an application-level message.
      	if: ((isBreakpointedSend(rcv,msg)).or:{(isInStepInto()).or:{isInStepReturn()}}) then: {
      	  // a breakpointed msg infects other actors if they were not part of the debugging session.
		  //If the actor is stepping into because then we need to mark 
          // all outgoing messages as breakpointed to infect other actors 
		  // If the actor is stepping return then we just need to mark the resolution/ruining of the future messages.
      	  def extendMsg := true;
  		  if: isInStepReturn() then:{
 		  	 if: !futureBreakpoint.matches(rcv,msg) then: {
 		  		extendMsg := false; 	
 		  	 };
 		  };
 		  def newMsg := msg;
		  if: extendMsg then: {
		  	newMsg := extendWithPauseBhv(msg, actorId, debuggerActor);
		  };
		  def result := super^send(rcv,newMsg);
      	  // check if we are sending now the message because stepInto command 
 		  if: isInStepInto() then: { 
 		    debuggerActor<-updateMessageSent(actorId, msg)@Debug;
 		  };
		  result;
  		} else:{
  		    super^send(rcv,msg);
	  	};
      };
	};
	
	// remote interface with debuggerActor
	def interfaceDebuggerActor := object: {
	  
	  	def evaluateCode(){
		 	if: (nil != filename) then:{ 
				debuggerUtilModule.loadMainCodeFromFile(filename, actorMirror.behaviour);
			} else:{
				raise: XDebuggerException.new("cannot evaluate code on a local manager created without a boostrapping file");
			};
	 	};
				
	  def startInDebugMode(tableCodeBreakpoints, tableConditionalBreakpoints := []){
	  	debuggingState := RUNNING;
	   	tableCodeBreakpoints.each: { |codebkpt| addBreakpoint(codebkpt)};
	   	tableConditionalBreakpoints.each: { |condbkpt| addConditionalBreakpoint(condbkpt)};
	   	scheduleAllMessagesFromInbox(false);
	  };
	  
	  def pause(){
        debuggingState := PAUSED;
        pausedState := COMMAND;
        debuggerActor<-actorPaused(getActorId(),getActorState())@Debug;
	  };
	  
	  def resume(){
	  	debuggingState := RUNNING;
	    pausedState := INITIAL;
	    scheduleAllMessagesFromInbox();
	    debuggerActor<-actorResumed(getActorId())@Debug;			  
	  };
	  
	  def stepInto(){
	  	if: isPaused() then:{
	      pausedState := STEPINTO;
	      scheduleOneMessageFromInbox();
        };
	  };
	  
	  def stepReturn() {
	  	if: isPausedByBreakpoint() then: { 
	  		//check that the message is futurized
			def futurized := false;
	  		def length := inbox.length();
	  		if: (length > 0 ) then:{
	    		def msg := (inbox[1])[1]; //[msg,rcv]
        		def rcv := (inbox[1])[2];
        		if: (is: msg taggedAs: /.at.lang.futures.FutureMessage) then:{
        			futurized := true;
        		}
        	};
        	if: futurized then: {
        		pausedState := STEPRETURN;
        		scheduleOneMessageFromInbox();
        	};
        };
	  };
	  
	  def stepOver(){
	    if: isPaused() then:{
	      pausedState := STEPOVER;
	      scheduleOneMessageFromInbox();
	    };
	  };
	  
	  def addBreakpoint(breakpoint) {
	    codeBreakpoints.put(breakpoint.getBreakpointId, breakpoint);   
	  };
	  	  
	  def removeBreakpoint(breakpoint){
	    codeBreakpoints.remove(breakpoint.getBreakpointId);
	  };
	  
	  def addConditionalBreakpoint(breakpoint) {
		conditionalBreakpoints.put(breakpoint.getBreakpointId, breakpoint);
	  };
	  def removeConditionalBreakpoint(breakpoint) {
		conditionalBreakpoints.remove(breakpoint.getBreakpointId);
	  };
	};
	
	def whenDiscoveryActorDiscovered(da) {
	  // TODO: 'Temporary' code to get the sourceLocation of the behaviour 
	  //  while it is not added to the reflective layer.
	  sourceLocation := /.at.support.util.getSourceLocation(self.behaviour);
      debuggerActor<-actorStarted(actorId, sourceLocation, interfaceDebuggerActor)@Debug;
	  disconnectedFromDebuggerActor := false;
	  // when disconnected from debugger actor, message @Debug are lost 
      // so that we don't update him with old info upon reconnection.		
	  whenever: da disconnected: { 
	    disconnectedFromDebuggerActor := true;
	    if: (!debuggingSession) then:{
	      //desinfect this actor because it was not part of the original debugging session.
	      /.at.support.debugger.localManager.enableLocalManager(false);
	    };
	  };
	  whenever: da reconnected: {
	    disconnectedFromDebuggerActor := false;
	    debuggerActor<-actorStarted(actorId, sourceLocation, interfaceDebuggerActor)@Debug;
	  };
	};
	
	// bound a given debuggerActor or start service discovery to search for a session otherwise.
	if: (debuggerActorFarRef == nil) then: {
	  // start discovery of DebuggerActor
	  when: DebuggerActor discovered: { |da|
	    debuggerActor := da;
	    whenDiscoveryActorDiscovered(debuggerActor);
	  };
	} else: {
	  debuggerActor := debuggerActorFarRef;
	  whenDiscoveryActorDiscovered(debuggerActor);
	}
  } taggedAs: [ LocalManagerModule ];
};

object:{
  def LocalManagerModule := LocalManagerModule;
  def XDebuggerException := XDebuggerException;

  def enableLocalManager(enable, debuggingSession := true, debuggerActor := nil) { 
  // debuggingSession boolean denotes if an actor was part or not of the original debugging session, to be able to desinfect it if not.
	def actor := reflectOnActor();
	  if: (enable) then: {
		// do not load the local manager module twice!
		if: (!(is: actor taggedAs: LocalManagerModule)) then: {
	  	    def newProtocol := makeLocalManager(actor, debuggingSession, debuggerActor);
		    // the futures protocol by default extends the currently active protocol
			actor.becomeMirroredBy: newProtocol;
			system.println("[localManager.at] enabling debugging support by default on actor " + reflectOnActor() + "with id: " + newProtocol.actorId);
			newProtocol;			
		} else: {
		  actor; // return the current actor protocol
	    };
	  } else:{
	    // desinfect an actor.
		actor.becomeMirroredBy: defaultActorMirror;
	  }
  };
  
  def bootstrapLocalManager(fn := nil){
		//[1] := fileName
		def filename := fn;
		if: (nil == filename) then:{
			if: (system.argv().length() > 0) then:{ 
				filename := system.argv()[1];
			} else:{
				raise: XDebuggerException.new("cannot enable debugging support on an actor without file name of the code it needs to debug");
			};
		};
		network.online();	
		def actor := enableLocalManager(true);
		actor.setFilename(filename);
		actor;
  	};

};