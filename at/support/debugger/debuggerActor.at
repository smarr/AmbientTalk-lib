/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2010
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
**/

/** 
 * Implementation of debugger Actor module of the AmbientTalk debugger called REME-D (read remedy). 
 * More information about REME-D at AmbientTalk's google code site.
 * @author egonzale
**/
deftype DebuggerActor;
deftype Debug <: /.at.lang.types.Message;
def ATFarReference := jlobby.edu.vub.at.actors.ATFarReference;
def Hashset := /.at.collections.java.hashset.HashSet;
def HashMap := /.at.collections.java.hashMap.HashMap;
def  breakpointsDS := /.at.support.debugger.localManager.breakpointsDS;

def getVMIDFromFarReference(farReference) {
  def impl_getObjectId := /.at.support.symbiosis.getClassInstanceMethod(ATFarReference, "impl_getObjectId", []);
  def objectId := impl_getObjectId.invoke(farReference, []);
  objectId.getVirtualMachineId().getID(); 
};

def debuggerActorBhv := object: {
  // actorId -> far reference to local manager.
  def actorList := HashMap.new();  
  // stores breakpoints active on all VMs
  def breakpointsInAllVM :=  breakpointsDS.new(); 
  // stores breakpoints active only on some VMs.
  //  VMID -> (HashMap of filenames -> lineNumbers)
  def breakpointsInVM := HashMap.new(); 
  // stores the actorsId within a VM. 
  // VMID -> (HashSet of actorIds)
  def vmIdToActorIdMap := HashMap.new(); 
  
  //helper functions
  def removeActorFromDataStructures(vmId, actorId,frLocalManager){
     actorList.remove(actorId);
     def actorIdsSet := vmIdToActorIdMap.get(vmId);
     if: (nil != actorIdsSet) then:{
       actorIdsSet.remove(frLocalManager);
     }
  };
  
  def addActorToDataStructures(vmId, actorId, frLocalManager){
  	// add it to actor hashmap
    actorList.put(actorId, frLocalManager);
    // add it to vmIdToActorIdMap
    def actorIdsSet := vmIdToActorIdMap.get(vmId);
    if: (nil == actorIdsSet ) then:{
      def newSet := Hashset.new();
      newSet.add(frLocalManager);
      vmIdToActorIdMap.put(vmId, newSet); 
    } else:{
      if: (!actorIdsSet.contains(frLocalManager)) then: {
        actorIdsSet.add(frLocalManager);
      }
    }
  };
    
  def notifyBreakpoint(breakpoint, actorIdsSet, isAddition) {
  	if: (nil != actorIdsSet) then:{
	  actorIdsSet.each:{ |frLocalManager|
	    if: (isAddition) then: {
	      frLocalManager<-addBreakpoint(breakpoint[1], breakpoint[2])@Debug;
	    } else: {
	      frLocalManager<-removeBreakpoint(breakpoint[1], breakpoint[2])@Debug;
	    }
	  }
	}
  };
  
  // Interface methods called from Eclipse plugin
  def pauseActor(actorId){
     def frLocalManager := actorList.get(actorId);
     if: (nil != frLocalManager) then:{
       frLocalManager<-pause()@Debug;
     };
  };
  
  def resumeActor(actorId){
     def frLocalManager := actorList.get(actorId);
     if: (nil != frLocalManager) then:{
       frLocalManager<-resume()@Debug;
     };
  };
  
  def stepInto(actorId){
    def frLocalManager := actorList.get(actorId);
    if: (nil != frLocalManager) then:{
      frLocalManager<-stepInto()@Debug;
    };
  };
  
  def stepOver(actorId){
    def frLocalManager := actorList.get(actorId);
    if: (nil != frLocalManager) then:{
      frLocalManager<-stepOver()@Debug;
    };
  };
  
  def setBreakpoint(filename, lineNumber){
    breakpointsInAllVM.put(filename,lineNumber);
    actorList.each: { |actorId, frLocalManager|
      frLocalManager<-addBreakpoint(filename, lineNumber)@Debug;
    };
  };
  
  def clearBreakpoint(filename, lineNumber){
    breakpointsInAllVM.put(filename,lineNumber);
    actorList.each: { |actorId, frLocalManager|
      frLocalManager<-removeBreakpoint(filename, lineNumber)@Debug;
    };
  }; 
   
  def breakpointActiveOn(filename, lineNumber, listVMIds){
    // notify the local managers already discovered.
    vmIdToActorIdMap.each: { | vmId, actorIdsSet | 
      def bkpDS := breakpointsInVM.get(vmId);
      if: (bkpDS != nil) then: {
        if: ( listVMIds.contains(vmId)) then:{
          if: (! bkpDS.contains(filename, lineNumber)) then:{
		    notifyBreakpoint([filename, lineNumber],actorIdsSet, true);
		  };
        } else: {
        // the breakpoint should not be active in this VM
        if: ( bkpDS.contains(filename, lineNumber)) then:{
	      notifyBreakpoint([filename, lineNumber],actorIdsSet, false);
		  }
        }
      } else:{
        // if the VMID is not in the data structures means that a local manager didn't
        // have time to announce his presence to the debuggerActor. 
        // Do not do anything, it will get the breakpoint in the actorStarted method.
      };
    };
     // remove from breakpointsInAllVM table if it was there.
     // since now it only belongs to a subset of VMIDs.
    def res := breakpointsInAllVM.remove(filename,lineNumber);
    // add the breakpoints to the breakpoint per VM data structure.
    // you need this data structure for new discovered local managers,
    // so that they don't think a disabled breakpoint is active on their VM.
    def it := listVMIds.iterator();
    while: {it.hasNext()} do:{
      def vmId := it.next();
      def bkpDS := breakpointsInVM.get(vmId) ;
      if: (bkpDS == nil) then:{
        bkpDS := breakpointsDS.new();
      }; 
      bkpDS.put(filename, lineNumber);
      breakpointsInVM.put(vmId, bkpDS);
    }
    
  };

  // Interface methods called from Actors which need to be propagated to Eclipse
  def actorStarted(actorId, sourceLocation, frLocalManager){
    def localManager := actorList.get(actorId);
	if: (nil == localManager) then: {
	  def vmId := getVMIDFromFarReference(frLocalManager);
	  addActorToDataStructures(vmId, actorId, frLocalManager);
	  // send active breakpoints
	  // first, get breakpoints active in all VMs
	  def breakpoints := breakpointsInAllVM.toTable(); 
	  // secondly, add breakpoints active in this VM if any.
	  def bkpDS := breakpointsInVM.get(vmId); 
	  if: (bkpDS != nil) then: {
	    breakpoints := breakpoints + bkpDS.toTable();
      };
     
      frLocalManager<-start(breakpoints)@Debug;
      // inform GUI
      if: (nil == sourceLocation) then: { // nil only if behaviour of the default actor.
        jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_startActor(actorId, vmId, "default", 0);
      } else: {
       jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_startActor(actorId, vmId, sourceLocation.fileName, sourceLocation.line);
      };
      whenever: frLocalManager disconnected: {
        removeActorFromDataStructures(vmId,actorId, frLocalManager);
        //THINK: if actor was "infected", you should remove it from GUI totally.
        // if actor was "part of the gui", just grey out it?
        jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_disconnectionActor(actorId);
      }; 
    };
  };
  
  // Interface methods called from localManager 
  def actorPaused(actorId,actorState){
     // second argument is Map <String, Object> 
     jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_suspendActor(actorId, actorState);
  };
  
  def actorResumed(actorId){
    jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_resumeActor(actorId);
  };
  
  def updateInbox(actorId, msg, addition := true) {  // TODO: it should be actorId, msg, rcv? 
     if: addition then: {
       jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_addMsgInfo(actorId, msg.selector, msg.arguments,msg);
     } else: {
       jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_removeMsgInfo(actorId, msg.selector, msg.arguments,msg);
     };
  };
  
  def updateMessageSent(actorId, msg) {
    jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_newMsgSent(actorId, msg.selector, msg.arguments,msg);
  };
  
};
export: debuggerActorBhv as: DebuggerActor;
network.online();

