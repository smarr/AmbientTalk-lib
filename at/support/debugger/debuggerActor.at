/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2010
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
**/

/** 
 * Implementation of debugger Actor module of the AmbientTalk debugger called REME-D (read remedy). 
 * More information about REME-D at AmbientTalk's google code site.
 * @author egonzale
**/
deftype DebuggerActor;
deftype Debug <: /.at.lang.types.Message;
def ATFarReference := jlobby.edu.vub.at.actors.ATFarReference;
def Hashset := /.at.collections.java.hashset.HashSet;

def getVMIDFromFarReference(farReference) {
  def impl_getObjectId := /.at.support.symbiosis.getClassInstanceMethod(ATFarReference, "impl_getObjectId", []);
  def objectId := impl_getObjectId.invoke(farReference, []);
  objectId.getVirtualMachineId().getID(); 
};

def debuggerActorBhv := object: {
  def actorList := jlobby.java.util.HashMap.new();
  def breakPoints := /.at.support.debugger.localManager.breakpointsDS.new();
  def vmIdToActorIdMap := /.at.collections.java.hashMap.HashMap.new();
  
  // helper methods.
  def actorList.each: closure {
	def valit := actorList.values().iterator();
	while: { valit.hasNext() } do: {
	  closure(valit.next());
	};
  };
  
  def removeActorFromDataStructures(vmId, actorId,frLocalManager){
     actorList.remove(actorId);
     def actorIdsSet := vmIdToActorIdMap.get(vmId);
     if: (nil != actorIdsSet) then:{
       actorIdsSet.remove(frLocalManager);
     }
  };
  
  def addActorToDataStructures(vmId, actorId, frLocalManager){
  	// add it to actor hashmap
    actorList.put(actorId, frLocalManager);
    // add it to vmIdToActorIdMap
    def actorIdsSet := vmIdToActorIdMap.get(vmId);
    if: (nil == actorIdsSet ) then:{
      def newSet := Hashset.new();
      newSet.add(frLocalManager);
      vmIdToActorIdMap.put(vmId, newSet); 
    } else:{
      if: (!actorIdsSet.contains(frLocalManager)) then: {
        actorIdsSet.add(frLocalManager);
      }
    }
  };
    
  def notifyBreakpoint(breakpoint, actorIdsSet, isAddition) {
  	if: (nil != actorIdsSet) then:{
	  actorIdsSet.each:{ |actorMirrorRef|
	    if: (isAddition) then: {
	      actorMirrorRef<-addBreakpoint(breakpoint[1], breakpoint[2])@Debug;
	    } else: {
	      actorMirrorRef<-removeBreakpoint(breakpoint[1], breakpoint[2])@Debug;
	    }
	  }
	}
  };
  
  // Interface methods called from Eclipse plugin
  def pauseActor(actorId){
     def farRefToActorMirror := actorList.get(actorId);
     if: (nil != actorId) then:{
       farRefToActorMirror<-pause()@Debug;
     };
  };
  
  def resumeActor(actorId){
     def farRefToActorMirror := actorList.get(actorId);
     if: (nil != actorId) then:{
       farRefToActorMirror<-resume()@Debug;
     };
  };
  
  def stepInto(actorId){
    def farRefToActorMirror := actorList.get(actorId);
    if: (nil != actorId) then:{
      farRefToActorMirror<-stepInto()@Debug;
    };
  };
  
  def stepOver(actorId){
    def farRefToActorMirror := actorList.get(actorId);
    if: (nil != actorId) then:{
      farRefToActorMirror<-stepOver()@Debug;
    };
  };
  
  def setBreakpoint(filename, lineNumber){
    breakPoints.put(filename, lineNumber);
    actorList.each: { |actorMirrorRef|
      actorMirrorRef<-addBreakpoint(filename, lineNumber)@Debug;
    };
  };
  
  def clearBreakpoint(filename, lineNumber){
    breakPoints.remove(filename, lineNumber);
    actorList.each: { |actorMirrorRef|
      actorMirrorRef<-removeBreakpoint(filename, lineNumber)@Debug;
    };
  }; 
   
  def breakpointActiveOn(filename, lineNumber, listVMIds){
    vmIdToActorIdMap.each: { | vmId, actorIdsSet | 
      if: ( listVMIds.contains(vmId)) then:{
        // the breakpoint should be active in this VM
		notifyBreakpoint([filename, lineNumber],actorIdsSet, true);
      } else: {
        // the breakpoint should not be active in this VM
	    notifyBreakpoint([filename, lineNumber],actorIdsSet, false);
      }
    };
  };

  // Interface methods called from Actors which need to be propagated to Eclipse
  def actorStarted(actorId, sourceLocation, frLocalManager){
    def localManager := actorList.get(actorId);
	if: (nil == localManager) then: {
	  def vmId := getVMIDFromFarReference(frLocalManager);
	  addActorToDataStructures(vmId, actorId, frLocalManager);
      frLocalManager<-start(breakPoints.toTable())@Debug;
      if: (nil == sourceLocation) then: { // nil only if behaviour of the default actor.
        jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_startActor(actorId, vmId, "default", 0);
      } else: {
       jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_startActor(actorId, vmId, sourceLocation.fileName, sourceLocation.line);
      };
      
      whenever: frLocalManager disconnected: {
        removeActorFromDataStructures(vmId,actorId, frLocalManager);
        //THINK: if actor was "infected", you should remove it from GUI totally.
        // if actor was "part of the gui", just grey out it?
        jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_disconnectionActor(actorId);
      }; 
    };
  };
  
  // Interface methods called from localManager 
  def actorPaused(actorId,actorState){
     // second argument is Map <String, Object> 
     jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_suspendActor(actorId, actorState);
  };
  
  def actorResumed(actorId){
    jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_confirm_resumeActor(actorId);
  };
  
  def updateInbox(actorId, msg, addition := true) {  // TODO: it should be actorId, msg, rcv? 
     if: addition then: {
       jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_addMsgInfo(actorId, msg.selector, msg.arguments,msg);
     } else: {
       jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_removeMsgInfo(actorId, msg.selector, msg.arguments,msg);
     };
  };
  
  def updateMessageSent(actorId, msg) {
    jlobby.edu.vub.at.debug.IAT_DEBUGGER.event_newMsgSent(actorId, msg.selector, msg.arguments,msg);
  };
  
};
export: debuggerActorBhv as: DebuggerActor;
network.online();

