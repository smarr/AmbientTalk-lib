/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2012
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
**/

def StartActorEvent := jlobby.edu.vub.at.debug.events.StartActorEvent;
def DisconnectActorEvent := jlobby.edu.vub.at.debug.events.DisconnectActorEvent;
def PauseActorEvent := jlobby.edu.vub.at.debug.events.PauseActorEvent;
def ResumeActorEvent := jlobby.edu.vub.at.debug.events.ResumeActorEvent;
def StepIntoActorEvent := jlobby.edu.vub.at.debug.events.StepIntoActorEvent;
def MessageSendFromActorEvent := jlobby.edu.vub.at.debug.events.MessageSendFromActorEvent;
def MessageAddedToActorEvent := jlobby.edu.vub.at.debug.events.MessageAddedToActorEvent;
def MessageRemovedFromActorEvent := jlobby.edu.vub.at.debug.events.MessageRemovedFromActorEvent;
def FieldUpdateEvent := jlobby.edu.vub.at.debug.events.FieldUpdateEvent;

def eclipseActorBhv := object: {
	
	// create debuggerActor 
	def debuggerActorBhv := /.at.support.debugger.debuggerActor.makeDebuggerActor();
	/*def debuggerActor := actor: {  
		def debuggerActorBhv := /.at.support.debugger.debuggerActor;

		def handShake(debuggerEventList, commandInter){
		// eclipe --> debuggeActor commands
		// set the behaviour in the eclipse plugin interface
		commandInter<-setDebuggerActorBhv(debuggerActorBhv);
		// eclipse <-- debuggeActor events
		// set the controller interface in the debuggerActor
		debuggerActorBhv.setupDebugSession(debuggerEventList);
		};
	};*/
	//--------------------------------------------------------------
	//interface with debuggerActor
	//--------------------------------------------------------------
	def debuggerEventListener := object:{
		
		def startActorEvent(actorId, vmId, fileName, line){
			sendEvent(StartActorEvent.new(actorId, vmId, fileName, line));
		};	
		def disconnectActorEvent(actorId){
			sendEvent(DisconnectActorEvent.new(actorId));
		};
		def pauseActorEvent(actorId, actorState){
			sendEvent(PauseActorEvent.new(actorId,actorState));
		};
		def resumeActorEvent(actorId){
			sendEvent(ResumeActorEvent.new(actorId));
		};
		def messageAddedToActorEvent(actorId, msg){
			sendEvent(MessageAddedToActorEvent.new(actorId, msg.selector, msg.arguments, msg));
		};
		def messageRemovedFromActorEvent(actorId, msg){ //TODO different than Patricio!
			sendEvent( MessageRemovedFromActorEvent.new(actorId));
		};
		def messageSendFromActorEvent(actorId, msg){
			sendEvent(MessageSendFromActorEvent.new(actorId, msg.selector, msg.arguments, msg));
		};
		
		def fieldUpdateEvent(actorId, name, objectId, state){
			sendEvent(FieldUpdateEvent.new(actorId, name, objectId, state));
		};
		def sendEvent(event){
			debugCoreInstance.handleEvent(event);
		};
	};
	
	///--------------------------------------------------------------
	//interface with eclipsePlugin
	//--------------------------------------------------------------
	//def commandBehaviour := /.at.support.debugger.commandBehaviour.commandBehaviour.new(debuggerActorBhv);
	 
	 def commandBehaviour := object: {
		 // StartCommand:
		def executeStartCommand(startCommand){
			startCommand.getBreakpoints().each: {|bP| 
				bP.executeCommand(self);
			};
			debuggerActorBhv.loadMainCode(startCommand.getActorId());
		};
		
		// SetBreakPointCommand:
		def executeSetBreakpointCommand(fileName, lineNumber, bpActiveOnList){
			if: (bpActiveOnList == nil) then: {
				debuggerActorBhv.setBreakpoint(fileName, lineNumber);
			} else: {
				debuggerActorBhv.breakPointActiveOn(fileName, lineNumber, bpActiveOnList );
			};
		};
		// ClearBreakPointCommand:
		def executeClearBreakpointCommand(fileName, lineNumber){
			debuggerActorBhv.clearBreakpoint(fileName, lineNumber);
		};
		// ResumeCommand:
		def executeResumeCommand(actorId){
			debuggerActorBhv.resumeActor(actorId);
		};
		// StepIntoCommand:
		def executeStepIntoCommand(actorId){
			debuggerActorBhv.stepInto(actorId);
		};
		// StepOverCommand:
		def executeStepOverCommand(actorId){
			debuggerActorBhv.stepOver(actorId);
		};
		// SuspendCommand:
		def executeSuspendCommand(actorId){
			debuggerActorBhv.pauseActor(actorId);
		};
		//TODO:
		def executeFieldUpdateCommand(actorId, name, reference){
			debuggerActorBhv.fieldUpdate(actorId, name, reference);
		};
		def executeRefreshActorCommand(actorId){
			debuggerActorBhv.refreshActor(actorId);
		};
	 
	 };
	 
	// Set interface for eclipse
	def debugCoreInstance := jlobby.edu.vub.at.debug.core.DebugCorePlugin.getDefault();
	debugCoreInstance.registerController(commandBehaviour);
	
	debuggerActorBhv.setupDebugSession(debuggerEventListener);
	 
	// debuggerActor<-handShake(eventBehaviour, commandBehaviour);

};

//eclipseActorBhv;

//def debuggerActorBhv := /.at.support.debugger.debuggerActor.makeDebuggerActor();
//debuggerActorBhv.setupDebugSession(eclipseActorBhv.debuggerEventListener);
//debuggerActorBhv.setBreakpoint("/Users/lisa/Desktop/debugger/src/testDebug.at", 23);
self;