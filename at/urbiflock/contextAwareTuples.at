/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2010
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

def crimeModule := /.at.crime.CrimeConnection;
def totamModule := /.at.urbiflock.ambientTota;
deftype ContextAwareTotam;
import crimeModule;

def makeTupleSpace() {
	extend: totamModule.makeTupleSpace("ContextAwareTotam") with:{
	  def pub; def sub; // service discovery vars
	  //every ts has a crime engine for activation/deactivation tuples
	  def crimeEngine := makeCrimeEngine();
	  def getCrimeEngine() { crimeEngine };
	
	  def goOnline() {
		  pub := export: self as: ContextAwareTotam;
		  sub := whenever: ContextAwareTotam discovered: { |ts|
				//filling in dummny descriptor to avoid a remote message to interchange descriptors
				super^notifyTSDiscovered(ts, "ContextAwareTotam"); 
		  };
	  };
	
	  def goOffline(){
		 pub.cancel(); sub.cancel();
	  };
	
		def add(tuple){
			//insert local tuples only to crime			
			if: (nil != tuple.getContent) then: {
				def table := [];
				tuple.getContent.each:{ |el| table := table + [el];}; 
				system.println("TS " + self + "CRIME ENGINE "+ crimeEngine + " insertingTuple " +table);
				crimeEngine.insertTuple(tuple.getContent);
			};
		  super^add(tuple);
		};
		def remove(tuple){
			system.println("removing " + tuple);
		};
	  //listener helper object used by when/whenever matches.
		def listener := object: {
			def unsubscribe;
			def ts; 
			def template;
			def init(lTs, tmpl, unsubs := true){
				ts := lTs; template := tmpl;
				unsubscribe := unsubs;
			};
					
	    def notifyTupleInserted(tuple) {
	      if: template.match(tuple) then: { 
					ts.removeListener(self);
				  if: unsubscribe then: { 
					//todo this won't work!!
						ts.delete(tuple);
		      } else: {
						ts.registerListener(self);
					};
		      closure(tuple);
		    };
	    };
	  };
		/* ~inp
		   places a listener on to the local TS for the addition of tuples matching a template
		   it returns a publication object to be able to unsubscribe. 
		   the publication is automatically unsubscribed after the matching of a tuple.
		   Multiple tuples may match the template but only one when:matches is applied non-deterministically.
		   The returned tuple as parameter in the closure argument is removed from the locatl TS.	
		 */
	  def when: template matches: closure {
		  super^registerListener(listener.new(self,template));
		};
		/* ~readp
		   places a listener on to the local TS for the addition of tuples matching a template
		   it returns a publication object to be able to unsubscribe. 
		   If multiple tuples may match the template, whenever:matches will get call multiple times.
		   The returned tuple as parameter in the closure argument is removed from the locatl TS.	
		 */
		def whenever: template matches: closure{
		  super^registerListener(listener.new(self,template,false));
		};
		
		//publishes a tuple into the ambient ( ~ inject in TOTA)
		//note that this just exports a tuple to the ambient
		//but it does not store in the local ts
		def inject: tuple inContext: table {
			def totamTuple;
			if: (is: tuple taggedAs: ContextAwareTotam) then:{
			  totamTuple := tuple;
			} else:{	
				system.println("TS: " + self + " aqui1 amb tuple " + tuple);
			  totamTuple := extend: tuple with: { |table|
				   def doAction(ts) {
						 def crime := ts.getCrimeEngine();
					   system.println("adding activation rule at " + ts + " CRIME ENGINE " + crime);
						 crime.when: table activated: { |args|
						//TODO!! adding now a crime tuple!
						 	  system.println("activating tuple " + self.getContent);
							  ts.add(self);
						 } deactivated: { |args|
						    ts.remove(self);	
						};
					 };
					 def decideStore(ts) {false};
			  } taggedAs: [/.at.types.Isolate, ContextAwareTotam]; 
		  };
			super^inject: totamTuple;	
		}; //end-inject-inContext
		
	};
};

def contextAwareTuplesModule := object:{
	
	def makeTemplate(@fields) {crimeModule^makeTemplate(@fields)};
	def makeTuple(@fields) {
		def tuple := crimeModule^makeTuple(@fields);
		totamModule.extendTuple: totamModule.makeTuple() with: {
		  def content := tuple;
		  def hop := 0;
		  def getContent() {content};
		  def inScope(ts) {hop < 1 };
		  def changeTupleContent(ts) {
			  hop := hop + 1;
			  self;
		  };
		  def decideStore(ts){ true };
	  };
	};
	def makeTupleSpace := &makeTupleSpace;
	
	def contextAwareTuplesTest := extend: /.at.unit.test.UnitTest.new("contextAwareTuples", false) with: {
		import /.at.lang.futures;
		enableFutures(false);
		
	  def testAsyncInject(){
		  def [fut,res] := makeFuture();
		  def myTs := makeTupleSpace();
		  myTs.goOnline;
		/*	myTs.when: makeTemplate("inRoom", var: `name) matches: { |tuple|
			   system.println("You are currently in " + tuple.get(`name));
			   res.resolve(`ok);
			  // remove(tuple);
	    };*/ /*outOfContext: {|tuple|
			  system.println("you moved out of " + tuple.get(`name));
			};*/
		  def theMeetingRoom := actor: {
			  import /.at.urbiflock.contextAwareTuples;
			  def myTs := makeTupleSpace();
			  myTs.goOnline;
			  system.println("meeting room is " + myTs);
			  def makeMeetingRoomTuple() { makeTuple("inRoom", "MeetingRoom")};
			  myTs.inject: makeMeetingRoomTuple() inContext: [ makeTemplate("GPS", 30, 30)];
			  //only activate this tuple if location is meeting room
			  //[ makeTemplate("GPS", 50, 120), makeTemplate("Today", var: `day), makeTemplate("Weekday", var: `day) ]; //&& (35< x < 45) && (100 < y < 120) 
				
		  };
  	  //Code of my gps module which simulates when: gps updated: { |coordinates| ...}
			  def coordinates := [0,0];
				def count := 0;
				/.at.support.timer.every: seconds(5) until: { count >5 } do: { 
					count := count + 1;
					coordinates[1] := coordinates[1] + 10;
					coordinates[2] := coordinates[2] + 10;
				//	def table := myTs.delete(makeTemplate("GPS"));
					//system.println("deleted " + table);
					myTs.add(makeTuple("GPS", coordinates[1], coordinates[2]));
				};
		  //};
		  fut;
	  }; //end-testInject
	};//end-contextAwareTuplesTest
}; //end-contextAwareTuplesModule
contextAwareTuplesModule;