/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2010
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

def crimeModule := /.at.crime.CrimeConnection;
def totamModule := /.at.urbiflock.ambientTota;
deftype ContextAwareTotam;
import crimeModule;

//helper functions
def makeNewClosure(variableNames, closure) {
	def newClosureStatements := `{ | #@(variableNames.map: {|e| jlobby.edu.vub.at.objects.natives.grammar.AGSymbol.jAlloc(e);}) | #@(closure.method.bodyExpression.statements) };
	eval: newClosureStatements in: closure.context.lexicalScope;
};

def removeFirst(string) {
	def charArray := string.explode;
	charArray.select(2, charArray.length+1).implode;
};
  
def varNames(template) {
	def table := [];
	template.each: { |attribute|
		if: isJavaObject(attribute) then: {
			//its a variable
			def variableName := removeFirst(attribute.toString());
			if: !(table.contains(variableName)) then: {
				table := table + [variableName];
			};
		};
	};
 	table;
};

def mapToTableValues(varMap,variableNames) {
	variableNames.map: {|n| varMap.get( jlobby.edu.vub.at.objects.natives.grammar.AGSymbol.jAlloc(n)) };
};

def installListeners(vectorFacts, listener) {
  def it := vectorFacts.iterator;
	while: { it.hasNext } do: {
		def fact := it.next;
		(fact.getItsContextRule()).add(listener);
	};
};

def removeListener(vectorFacts,listener) {
  def it := vectorFacts.iterator;
  while: { it.hasNext } do: {
  	def fact := it.next;
		(fact.getItsContextRule()).remove(listener);
	};
};

def makeTupleSpace() {
	extend: totamModule.makeTupleSpace("ContextAwareTotam") with:{
	  def pub; def sub; // service discovery vars
	  //every ts has a crime engine for activation/deactivation tuples
	  def crimeEngine := makeCrimeEngine();
	  def getCrimeEngine() { crimeEngine };
	
	  def goOnline() {
		  pub := export: self as: ContextAwareTotam;
		  sub := whenever: ContextAwareTotam discovered: { |ts|
				//filling in dummny descriptor to avoid a remote message to interchange descriptors
				super^notifyTSDiscovered(ts, "ContextAwareTotam"); 
		  };
	  };
	
	  def goOffline(){
		 pub.cancel(); sub.cancel();
	  };
	
		def add(tuple){
			crimeEngine.insertTuple(tuple.content);
		};
		
		def delete(template){
			crimeEngine.retractTuple(template.content);
		};
		
		def replace(oldTuple, newTuple){
			delete(oldTuple);
			add(newTuple);
    };

		//TODO: temporal hack because we get Crime tokens in when:activated.
	  def removeToken( vectorFacts ) {
			def it := vectorFacts.iterator;
			while: { it.hasNext } do: {
				crimeEngine.retractCrimeFact(it.next);
			};
	  };
	 		
		// TODO: not sure whether we should remove the tuple.	
		def when: templateTable matches: closure {
			when: templateTable matches: closure outOfContext: {} registration: {|r| r.cancel();};
		};
		
		def when: templateTable matches: closure outOfContext: closureOutOfContext  {
			when: templateTable matches: closure outOfContext: closureOutOfContext registration: {|r| r.cancel();};
		};
		
		def whenever: templateTable matches: closure {
			when: templateTable matches: closure outOfContext: {} registration: {|r| };
		};
		
		def whenever: templateTable matches: closure outOfContext: closureOutOfContext {
			when: templateTable matches: closure outOfContext: closureOutOfContext registration: {|r| };
		};
		
		def when: templateTable matches: closure outOfContext: closureOutOfContext registration: registrationClosure  {
			def listener;
		  def variableNames := varNames(templateTable.content);
			closure :=  makeNewClosure(variableNames, closure); //`{ | #@(variableNames.map: {|e| jlobby.edu.vub.at.objects.natives.grammar.AGSymbol.jAlloc(e);}) | #@(closure.method.bodyExpression.statements) };
			closureOutOfContext :=  makeNewClosure(variableNames, closureOutOfContext);
		  //def table := templateTable.map: { |template| template.content};
		  def registration := crimeEngine.when: [templateTable.content] activatedToken: { |vectorFacts,varMap|
			  //Cancel so it is only triggered once
			  registrationClosure(registration);
			  //Call the closure with the correct variables
			  closure(@mapToTableValues(varMap,variableNames));
			  //Remove the facts from crime
			  removeToken(vectorFacts);
			  //Install Deactivation
			  listener := { closureOutOfContext(@mapToTableValues(varMap,variableNames)); };
			  installListeners(vectorFacts,listener);
		  };	
			object: {
				def cancel() {
					registration.cancel();
					removeListener(vectorFacts,listener);
				};
			};
		};
	
		
		//publishes a tuple into the ambient ( ~ inject in TOTA)
		//note that this just exports a tuple to the ambient
		//but it does not store in the local ts
		def inject: tuple inContext: templateTable {
			def totamTuple;
			def table := templateTable.map: { |template| template.content};
			
			//add REMOVE for out of context cancel.
			def listeners := isolate: {
				def table := [];
				def add(l) { table := table + [l]; };
				def clear() {	table := [];};
				def remove(l) { table := table.filter: { |e| e != l };};
				def each: closure { table.each: closure;};
			};
			
			if: (is: tuple taggedAs: ContextAwareTotam) then:{
			  totamTuple := tuple;
			} else:{	
			  totamTuple := extend: tuple with: { |table,listeners|
				   def doAction(ts) {
						 def crime := ts.getCrimeEngine();
						 crime.when: table activated: { |args|
							  crime.insertTuple(self.content, listeners);
						 } deactivated: { |args|
							listeners.each: { |l| l(); };
							listeners.clear();
							crime.retractTuple(self.content);	
						};
					 };
					 def decideStore(ts) {false};
			  } taggedAs: [/.at.types.Isolate, ContextAwareTotam]; 
		  };
			super^inject: totamTuple;	
		}; //end-inject-inContext	
	};
};

def contextAwareTuplesModule := object:{
	
	def makeTemplate(@fields) {
		def template := crimeModule^makeTemplate(@fields);
		totamModule.extendTuple: totamModule.makeTuple() with: {
		  def content := template;
	  };
	};
	def makeTuple(@fields) {
		def tuple := crimeModule^makeTuple(@fields);
		totamModule.extendTuple: totamModule.makeTuple() with: {
		  def content := tuple;
		  def hop := 0;
		  def inScope(ts) {hop < 1 };
		  def changeTupleContent(ts) {
			  hop := hop + 1;
			  self;
		  };
		  def decideStore(ts){ true };
	  };
	};
	def makeTupleSpace := &makeTupleSpace;
	def var: symbol { crimeModule^var: symbol};
	
	def contextAwareTuplesTest := extend: /.at.unit.test.UnitTest.new("contextAwareTuples", false) with: {
		import /.at.lang.futures;
		enableFutures(false);
		
		def myTs;
		def registration;
		
		def setUp(){
			myTs := makeTupleSpace();
			myTs.goOnline;
		  //gps tuples using other code which simulates when: gps updated: { |coordinates| ..}
			def coordinates := [0,0];
			def count := 0;
			/.at.support.timer.every: seconds(1) until: { count := count + 1; count > 4 } do: {
				def oldC := coordinates; 
				coordinates := coordinates.map: {|i| i + 10};
				myTs.replace(makeTuple("GPS", oldC[1], oldC[2]), makeTuple("GPS", coordinates[1], coordinates[2]));
			};
			//day tuples
			myTs.add(makeTuple("Today", "Wednesday"));
			def workingDays := ["Monday", "Tuesday", "Wednesday", "Thrusday", "Friday"];
			workingDays.each: { |day| myTs.add(makeTuple("Weekday", day));};
		};
		
		def tearDown() {
			myTs.goOffline;
			myTs := nil;
			//TODO this fails!
			//registration.cancel();
		};
		
		// test a simple inject of a meetingRoom tuple inserted by the room itself but only active 
		// when participants are in correct location.
	  def testAsyncInjectMeetingRoom(){
		  def [fut,res] := makeFuture();
	
		  registration := myTs.when: makeTemplate("inRoom", var: `name) matches: { 
		    self.assertEquals("MeetingRoom", name);
	    } outOfContext: {|tuple|
		  	self.assertEquals("MeetingRoom", name);
		    when: theMeetingRoom<-goOffline()@FutureMessage becomes: { |ack| res.resolve(`ok)};
		  };
		  		 			
		  def theMeetingRoom := actor: {
			  import /.at.urbiflock.contextAwareTuples;
			  def myTs := makeTupleSpace();
			  myTs.goOnline;
			  def goOffline() {myTs.goOffline()};
			  def makeMeetingRoomTuple() { makeTuple("inRoom", "MeetingRoom")};
			  myTs.inject: makeMeetingRoomTuple() inContext: [ makeTemplate("GPS", 30, 30) ];
		  };
		  fut;
	  }; //end-testInject
	
		// test a inject of a meetingRoom, studentRoom tuples inserted by the rooms itself but only active 
		// when participants are in correct location.
	/*  def testAsyncInject2Rooms(){
		  def [fut,res] := makeFuture();
	
		  registration := myTs.whenever: makeTemplate("inRoom", var: `name) matches: { 
		    //self.assertEquals("MeetingRoom", name);
		system.println("in room " + name);
	    } outOfContext: {|tuple|
			system.println("out of room " + name);
		  	//self.assertEquals("MeetingRoom", name);
				deletedTable := deletedTable.filter: { |e| nil != e};
				self.assertEquals(3,deletedTable.length);
		    when: theRoomManager<-goOffline()@FutureMessage becomes: { |ack| res.resolve(`ok)};
		  };
		 			
		  def theRoomManager := actor: {
			  import /.at.urbiflock.contextAwareTuples;
			  def myTs := makeTupleSpace();
			  myTs.goOnline;
			  def goOffline() {myTs.goOffline()};
			  def makeRoomTuple(name) { makeTuple("inRoom", name)};
			// this tuple is only activate if proper location + working days.
			  myTs.inject: makeRoomTuple("MeetingRoom") inContext: [ makeTemplate("GPS", 30, 30) ];
			  // this tuple is only activate if proper location + working days.
			  myTs.inject: makeRoomTuple("StudentRoom") inContext: [ makeTemplate("GPS", 30, 30),  makeTemplate("Today", var: `day), makeTemplate("Weekday", var: `day) ];
		  };
		  fut;
	  }; //end-testInject */
	
	};//end-contextAwareTuplesTest
}; //end-contextAwareTuplesModule
contextAwareTuplesModule;