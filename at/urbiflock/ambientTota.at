/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2008
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

def Vector := /.at.collections.vector.Vector;

def rand() { 
  // we should provide something more random, e.g. IP addres + PID + now()
//	def aRandomNumber := /.at.support.symbiosis.long((print: self).length);
//  /.at.support.util.randomNumberBetween(0, (/.at.support.timer.now() + aRandomNumber).intValue); 
 /.at.support.util.randomNumberBetween(0, 555555); 
};
		
def makeTupleSpace(){	
	
	//private methods and data fields
	def localTS := Vector.new(); //contains local tuples
	def ambientTS := Vector.new(); // contains ambient tuples
	def localTSListeners := Vector.new();
	def seenTS := Vector.new(); // contains far references to seen TS.
	def currentReceiverTs := nil;
	  
	// methods to manage the registration of when:matches.
	def registerListener(l) {
	  localTSListeners.add(l); 
	  object: { 
		  def cancel() { removeListener(l)};
		};
	};
 	def removeListener(l) {
	  localTSListeners.remove(l); 
	};
	def notifyListeners(tuple){
	  localTSListeners.each: { |l| l<-notifyTupleInserted(tuple) };
	};
	//method belonging to the tuple propagation protocol
	def receiveTuple(tuple, ts){
		// tota propagation protocol (receiver side)
    tuple.doAction(ts);
    tuple := tuple.changeTupleContent(ts);
    //check if you have to insert it into your local tuple space
    if: tuple.decideStore(ts) then: { ts.add(tuple) };
	};
	
	def sendTuple(tuple, ts, toTs){
		// toThink: this method could be called twice via inject and discovery when the ts discover.
		// this is not so bad, because a receiving ts checks if it already triggered propagation protocol for this tuple via tupleId.
		currentReceiverTs := toTs;
		if: tuple.decidePropagation(ts) then:{
		  true;
		} else: {
			if: tuple.decideDie(ts) then: {
	      system.println("AmbientTota: dying young " +  tuple);
				localTS.removeAll:{|t| t == tuple};
				ambientTS.removeAll: {|t| t == tuple};
 		  };
		  false;
		}; 
	};
	
	//todo: separate the public interface between local/remote.
	// public interface
	def publicInterface := object: {
		// usual operations to manage a local ts.
		// add a tuple to the local ts
	  def add(tuple){
		system.println("AmbientTota:add " + tuple.getTupleId + " in ts " + self.owner.getUsername );
	    localTS.add(tuple);
	    notifyListeners(tuple);
	  };
	  // delete from a ts all tuples matching the template
	  // returns a table with the deleted tuples.
	  def delete(template) {
	  	system.println("AmbientTota:delete " + template);
		  def toDelete := read(template);
	    localTS.removeAll: template;
		  toDelete.asTable;
		}; 
		// returns a table with the tuples matching the template in the ts.
		def read(template) { (localTS.filter: template).asTable};
			
		// operations to manage the ambient ts.
						
		//publishes a tuple into the ambient ( ~ inject in TOTA)
		//note that this just exports a tuple to the ambient
		//but it does not store in the local ts
		def inject: tuple {
			if: !(ambientTS.contains( tuple, {|t, t1| t.getTupleId == t1.getTupleId})) then: {
			// adding the tuple to the ambient for next sync.
			ambientTS.add(tuple);
			//notify all seen ts of the addition of a new tuple.
			seenTS.each: { |ts| 
				if: (sendTuple(tuple, self, ts)) then: { ts<-receiveTuples([tuple]) };
			};
			//notify yourself in case you are in the receiver.
		//	if: (sendTuple(tuple, self, self)) then: { receiveTuple(tuple, self) };
		 };
		  //return a publication object to be able to cancel the injection.
		  object:{
		    def cancel() { ambientTS.removeAll: {|t| t == tuple} };
		  };
		};
		
		// places a listener  on to the local TS ( ~ subscribe in TOTA)
		// for the addition of tuples matching a template
		// it returns a publication object to be able to unsusbscribe 
		def when: template matches: closure {
		  def listener := object: {
		    def notifyTupleInserted(tuple) {
		      if: (template(tuple)) then: { 
			      closure(tuple);
			    };
		    };
		  };
		  registerListener(listener);
		};
		  
		// remote interface
		// methods belonging to the tuple propatation protocol
		
		// notifies the discovery of a TS	and 
		// starts the propagation protocol (sender side)
		def notifyTSDiscovered(ts){ // tsDescriptor
	  	// add ts to seenTS vector so that it can be
			// notified if I add a new tuple to the ambient.
			if: !(seenTS.contains(ts)) then:{
		    seenTS.add(ts);
		  };
      //def toSend := sendTuples(self);
			def toSend := Vector.new();
			ambientTS.each: { |tuple| if: (sendTuple(tuple, self, ts)) then: { toSend.add(tuple)}};
      if: (toSend.length > 0) then: {
	       ts<-receiveTuples(toSend.asTable);
			};
    };
		
		// iterates over all ambient tuples of the other ts 
		// and triggers the propagation protocol (receiver side)
		def receiveTuples(tuples){
		  tuples.each: { |tuple|
		    if: !(ambientTS.contains( tuple, {|t, t1| t.getTupleId == t1.getTupleId})) then: {
			    // tota propagation protocol (receiver side)
		      receiveTuple(tuple, self);
			    self.inject: tuple;
		    };
		  };
	  };
	
		def getCurrentReceiverTs() {
			currentReceiverTs;
		}; 
		
	}; // end-of-public interface
  publicInterface; 
};

def makeTuple(tupleId := nil){
	//todo: keeping this for unit testing purposes.
	if: (tupleId == nil) then: {tupleId := rand()};
	
	isolate: { |tupleId|

		def getTupleId() { tupleId };
		// TOTA API
		// default tuple behaviour = always percolate, 
		// and store itself in every hop.
    
		// called in every tuple at pass() 
		def decidePropagation(ts){ true };
		// specifies operations on the local TS
		def doAction(ts){};
		// create a new tuple resulting from operations on the tuple itself
		def changeTupleContent(ts){self};
		// if true -> note gets added to local TS
		def decideStore(ts){true};
		// if true -> tuple gets unexported and deleted from local TS.
		//new operation not in TOTA
		def decideDie(ts){false};
		
	};
};

def extendTuple(tuple, closure) {
	extend: tuple with: closure taggedAs: [/.at.types.Isolate];
};

// the module object of this file
def AmbientTotaModule := object: {
	// public stuff goes here
	def makeTupleSpace := &makeTupleSpace;
	def makeTuple := &makeTuple;
	
	def extendTuple: tuple  with: closure {
		extendTuple(tuple, closure);
	};
	
	def AmbientTotaTest := extend: /.at.unit.test.UnitTest.new("AmbientTotaTest", false) with: {
		
		import /.at.lang.futures;
		enableFutures(false);
		deftype TupleSpace;
		// todo : add network online in the setup of tests.
		
		def testAsyncDiscoveryTuple() {
			
			def [fut,res] := makeFuture();
			def myTS := /.at.urbiflock.ambientTota.makeTupleSpace();
			def s := export: myTS as: TupleSpace;
				
			myTS.when: { |tuple| tuple.getTupleId == 123 } matches: { |tuple|
				self.assertEquals(123, tuple.getTupleId);	
				s.cancel();
				a<-resolve(res); 
			};
	
			def a := actor: { |TupleSpace|
				def aTS := /.at.urbiflock.ambientTota.makeTupleSpace();
		    def aTuple := /.at.urbiflock.ambientTota.makeTuple(123);
			  def sT := aTS.inject: aTuple;
				def s := whenever: TupleSpace discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				def resolve(res) {
					s.cancel();
					sT.cancel();
					res<-resolve(`ok);
				};    		
		  };
		
			fut;
		};
		
		
		def testAsyncOneHopTuple() {
			def [fut,res] := makeFuture();
			def myTS := /.at.urbiflock.ambientTota.makeTupleSpace();
			def s := export: myTS as: TupleSpace;
				
			myTS.when: {|tuple| tuple.getTupleId == 123 } matches: { |tuple|
				self.assertEquals(123, tuple.getTupleId);	
				s.cancel();
				a<-resolve(res);
			};
	
			def a := actor: { |TupleSpace|
				def aTS := /.at.urbiflock.ambientTota.makeTupleSpace();
		    def aTuple := /.at.urbiflock.ambientTota.makeTuple(123);
				def oneHopTuple := /.at.urbiflock.ambientTota.extendTuple: aTuple with: {
					 def dying := false;
					 def decidePropagation(ts) {!dying};
					 def changeTupleContent(ts) { dying := true; self};
					 def decideDie(ts){ dying };
				};
				
		    def sT := aTS.inject: oneHopTuple;
				def s := whenever: TupleSpace discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				
				def resolve(res) {
					s.cancel();
					sT.cancel();
					res<-resolve(`ok);
				};	
		  };		
			fut;
		};
		
		
	};
};
AmbientTotaModule;
