/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2008
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

def Vector := /.at.collections.vector.Vector;

def rand() { 
  // we should provide something more random, e.g. IP addres + PID + now()
	def aRandomNumber := /.at.support.symbiosis.long((print: self).length);
  /.at.support.util.randomNumberBetween(0, (/.at.support.timer.now() - aRandomNumber).intValue); 
};
		
def makeTupleSpace(){	
	
	//private methods and data fields
	def localTS := Vector.new(); //contains local tuples
	def ambientTS := Vector.new(); // contains ambient tuples
	def localTSListeners := Vector.new();
	def seenTS := Vector.new(); // contains far references to seen TS.
	  
	// methods to manage the registration of when:matches.
	def registerListener(l) {
	  localTSListeners.add(l); 
	  object: { 
		  def cancel() { removeListener(l)};
		};
	};
 	def removeListener(l) {
	  localTSListeners.remove(l); 
	};
	def notifyListeners(tuple){
	  localTSListeners.each: { |l| l<-notifyTupleInserted(tuple) };
	};
	  
	//method belonging to the tuple propagation protocol
	def sendTuples(ts){
	  def toSend := Vector.new();
		ambientTS.each: {|tuple|
			if: tuple.decidePropagation(ts) then:{
				system.println("decidePropagation true for tuple " + tuple.getTupleId);
				toSend.add(tuple);
			} else: {
				system.println("decidePropagation false for tuple " + tuple.getTupleId);
				if: tuple.decideDie(ts) then: {
	        system.println("dying young " +  tuple);
					def ld := localTS.delete({|t| t == tuple});
					def ad := ambientTS.delete({|t| t == tuple});
				  system.println("delete local " + ld.asTable + "and delete ambient " + ad.asTable);
				};
			}; 
		};
		toSend.asTable;
	};
	
	//todo: separate the public interface between local/remote.
	// public interface
	def publicInterface := object: {
		// usual operations to manage a local ts.
		// add a tuple to the local ts
	  def add(tuple){
			system.println("add to local " + tuple.getTupleId);
	    localTS.add(tuple);
	    notifyListeners(tuple);
	  };
	  // delete from a ts all tuples matching the template
	  // returns a table with the deleted tuples.
	  def delete(template) {
	  	system.println("delete " + template);
		  def toDelete := read(template);
	    localTS.removeAll: template;
		  toDelete.asTable;
		}; 
		// returns a table with the tuples matching the template in the ts.
		def read(template) { (localTS.filter: template).asTable};
			
		// operations to manage the ambient ts.
						
		//publishes a tuple into the ambient ( ~ inject in TOTA)
		//note that this just exports a tuple to the ambient
		//but it does not store in the local ts
		def inject: tuple {
			system.println("add to ambient " + tuple.getTupleId );
		  ambientTS.add(tuple);
			//notify all seen ts of the addition of a new tuple.
			//todo first time, could receiveTuples be triggered twice? 
		  seenTS.each: { |ts| ts<-receiveTuples([tuple]) };
		  //return a publication object to be able to cancel the injection.
		  object:{
		    def cancel() { ambientTS.removeAll: {|t| t == tuple} };
		  };
		};
		
		// places a listener  on to the local TS ( ~ subscribe in TOTA)
		// for the addition of tuples matching a template
		// it returns a publication object to be able to unsusbscribe 
		def when: template matches: closure {
		  def listener := object: {
		    def notifyTupleInserted(tuple) {
		      if: (template(tuple)) then: { 
			      closure(tuple);
			    };
		    };
		  };
		  registerListener(listener);
		};
		  
		// remote interface
		// methods belonging to the tuple propatation protocol
		
		// notifies the discovery of a TS	and 
		// starts the propagation protocol (sender side)
		def notifyTSDiscovered(ts){
	  	// add ts to seenTS vector so that it can be
			// notified if I add a new tuple to the ambient.
			if: !(seenTS.contains(ts)) then:{
		    seenTS.add(ts);
		  };
      def toSend := sendTuples(self);
      if: (toSend.length > 0) then: {
				 system.println("notifyTSDiscovered: sending tuples to " + ts);
	       ts<-receiveTuples(toSend);
			};
    };
		
		// iterates over all ambient tuples of the other ts 
		// and triggers the propagation protocol (receiver side)
		def receiveTuples(tuples){
		  tuples.each: { |tuple|
		    if: !(ambientTS.contains( tuple, {|t, t1| t.getTupleId == t1.getTupleId})) then: {
			system.println("receivingTuple " + tuple.getTupleId);
		      // tota propagation protocol (receiver side)
		      tuple.doAction(self);
			    tuple := tuple.changeTupleContent(self);
			    //check if you have to insert it into your local tuple space
			    if: tuple.decideStore(self) then: { add(tuple) };
			    //todo: optimization to inject all tuples at once.
			    inject: tuple;
		    };
		  };
	  }; 
		
	}; // end-of-public interface
  publicInterface; 
};

def makeTuple(tupleId := nil){
	//keeping this for unit testing purposes.
	if: (tupleId == nil) then: {tupleId := rand()};
	
	isolate: { |tupleId|

		def getTupleId() { tupleId };
		// TOTA API
		// default tuple behaviour = always percolate, 
		// and store itself in every hop.
    
		// called in every tuple at pass() 
		def decidePropagation(ts){ true };
		// specifies operations on the local TS
		def doAction(ts){};
		// create a new tuple resulting from operations on the tuple itself
		def changeTupleContent(ts){self};
		// if true -> note gets added to local TS
		def decideStore(ts){true};
		// if true -> tuple gets unexported and deleted from local TS.
		//new operation not in TOTA
		def decideDie(ts){false};
		
	};
};

def extendTuple(tuple, closure) {
	extend: tuple with: closure taggedAs: [/.at.types.Isolate];
};

// the module object of this file
def AmbientTotaModule := object: {
	// public stuff goes here
	def makeTupleSpace := &makeTupleSpace;
	def makeTuple := &makeTuple;
	
	def extendTuple: tuple  with: closure {
		extendTuple(tuple, closure);
	};
	
	def AmbientTotaTest := extend: /.at.unit.test.UnitTest.new("AmbientTotaTest", false) with: {
		
		import /.at.lang.futures;
		enableFutures(false);
		deftype TupleSpace;
		
		def testAsyncDiscoveryTuple() {
			
			def [fut,res] := makeFuture();
			def myTS := /.at.urbiflock.ambientTota.makeTupleSpace();
			def s := export: myTS as: TupleSpace;
				
			myTS.when: { |tuple| tuple.getTupleId == 123 } matches: { |tuple|
				self.assertEquals(123, tuple.getTupleId);	
				s.cancel();
				a<-resolve(res); 
			};
	
			def a := actor: { |TupleSpace|
				def aTS := /.at.urbiflock.ambientTota.makeTupleSpace();
		    def aTuple := /.at.urbiflock.ambientTota.makeTuple(123);
			  def sT := aTS.inject: aTuple;
				def s := whenever: TupleSpace discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				def resolve(res) {
					s.cancel();
					sT.cancel();
					res<-resolve(`ok);
				};    		
		  };
		
			fut;
		};
		
		
		def testAsyncOneHopTuple() {
			def [fut,res] := makeFuture();
			def myTS := /.at.urbiflock.ambientTota.makeTupleSpace();
			def s := export: myTS as: TupleSpace;
				
			myTS.when: {|tuple| tuple.getTupleId == 123 } matches: { |tuple|
				self.assertEquals(123, tuple.getTupleId);	
				s.cancel();
				a<-resolve(res);
			};
	
			def a := actor: { |TupleSpace|
				def aTS := /.at.urbiflock.ambientTota.makeTupleSpace();
		    def aTuple := /.at.urbiflock.ambientTota.makeTuple(123);
				def oneHopTuple := /.at.urbiflock.ambientTota.extendTuple: aTuple with: {
					 def dying := false;
					 def decidePropagation(ts) {!dying};
					 def changeTupleContent(ts) { dying := true; self};
					 def decideDie(ts){ dying };
				};
				
		    def sT := aTS.inject: oneHopTuple;
				def s := whenever: TupleSpace discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				
				def resolve(res) {
					s.cancel();
					sT.cancel();
					res<-resolve(`ok);
				};	
		  };		
			fut;
		};
		
		
	};
};
network.online();
AmbientTotaModule;
