/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2010
 * Authors: Soft Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
/* Flikken: a mobile Game implemented with context-aware tuples inspired in the Target 
 * See technical report at http://soft.vub.ac.be/Publications/2010/vub-tr-soft-10-03.pdf for further info.
 * 
 * Players are organized two teams: policemen and gangsters
 * The gangster escaped from prison and are committing crimes around the city.
 * The gangster knows the location of places with high quantities of money (e.g. casinos, jewleries, banks, ..)  
 * he needs to collect objects around the city (i.e knifes, detonators, ..) to be able to commit crimes.
 * At start of game policemen are in their HQ and gangster choses a HQ. When the gangsters leaves his HQ and the chase starts.
 * Game ends when the policemen have killed all gangsters or gangsters earn 1 milion euro in crimes.
 * Each team can see the positions of other team members, they can also send messages amongst team members.
 * Every 6 minutes they can see the position of the opposite team members.
 * Policemen and gangsters can shoot at ecah other. Each member gets 3 bullets at start game.
 * If policemen doesn't have more bullets, he can reload them at th HQ.
 * Gangster get 4 additional virtual items at the begining of the game for his defense:
 * -mine: kills somebody who steps on it (even if it is a gangster)
 * -gas bomb: kills people for X time X radius. After drop it, a gangster has 3 minutes to run before it becomes active.
 * -radio jammer: disrupts satelit connectivity.  Policemen cannot see gangster positions for 5 minutes, and the position of the policemen won't be displayed either!. 
 * -bullenproof vest: protects a gangster for 5 minutes against one single shot.
 * If a policemen memeber gets killed, the whole team has to go back to the HQ to start again. 
 * Gangsters can pick up the object to commit crimes when they are nearby the item.
 * To commit a crime in a certain place, a number of objects is required. 
 * When the gangster is nearby a crime place, he can commit the crime by pressing the button if he has the necessary objects. 
 * He loses the items but gets the reward (i.e. money stolen in the crime place).
 * When a gangster commits a crime, the policemen will be told (they know location and money stolen). 
 */
def catModule := /.at.urbiflock.contextAwareTuples;
import catModule;
def timerModule := /.at.support.timer;
def gameGUI := jlobby.at.urbiflock.game.LocalizerGUI;
def randomNumberBetween := /.at.support.util.&randomNumberBetween;
def RED := "gangster";
def BLUE := "policeman";
deftype EXPLOSIVES;
deftype ROPE_LADDER;
deftype LASER_JAMMER;
deftype KNIFE;
deftype SWISS_ARMY_KNIFE;
deftype GLASS_BREAKER;
deftype WIG;
deftype MASK;
deftype GUN;
def virtualObjects := [EXPLOSIVES, ROPE_LADDER,LASER_JAMMER,KNIFE,SWISS_ARMY_KNIFE,GLASS_BREAKER,WIG,MASK,GUN];
def OPPOSITE_TEAM_POSITION_TIMEOUT := 20.seconds();
def TEAM_POSITION_TIMEOUT := 5.seconds();
 
def typeToString(type){
  type.typeName.text.toLowerCase;
};

def makeGameServer() {
//	import /.at.urbiflock.contextAwareTuples;
	def ts := makeTupleSpace(RED);
	ts.activateDescriptors();
  ts.goOnline();	

  def addInRangeConstraints(coordinates, sX, sY) {
		  [var: sX lessOrEqualTo: (coordinates[1] + 10), 
			var: sX greaterOrEqualTo: (coordinates[1] - 10),
			var: sY lessOrEqualTo: (coordinates[2] + 10), 
			var: sY greaterOrEqualTo: (coordinates[2] - 10)];
	};

	def addCrimeTarget(name, coordinates, value, @objects){
		 // information about a crime location should be only received by gangsters
		 def template := [ makeTemplate("TeamInfo", var: `u, RED)]; 
		 ts.inject: makeTuple("CrimeTarget", name, coordinates) inContext: template;
		 // To be able to commit the crime, there are extra constraints:
		// + the player in range is the (local) player where the tuples are.
		 template := template + [makeTemplate("PlayerInfo", var: `u, RED, [var: `x, var: `y])];
		 // + inRange constraints, currently a rectangle.
		 template := template + addInRangeConstraints(coordinates, `x, `y);
		 // + which have the necessary virtual objects to commit this crime
		 def nameVo := [];
		 objects.each: { |item| 
			def name := typeToString(item);
			template := template + [makeTemplate("VirtualObject", name)];
		  nameVo := nameVo + [name]; 
		 };
		 def tuple := makeTuple("CommitCrime", name, coordinates, value, nameVo);
		system.println("SERVER: " + tuple.content.toString + " inContext " + templateTableToString(template));
		 ts.inject: tuple inContext: template;
	};

	def addVirtualObjects(name, coordinates){
	  def template := [ makeTemplate("TeamInfo", var: `u, RED),
	  makeTemplate("PlayerInfo", var: `u, RED, [var: `x, var: `y])];
	  template := template + addInRangeConstraints(coordinates, `x, `y);
	  system.println("SERVER: " + name + " inContext " + templateTableToString(template));
	  ts.inject: makeTuple("VirtualObject", name) inContext: template;	
	};
	
	def addDropableVirtualObjects(){
		//addVirtualObjects("mine", [50,60]);
		ts.inject: makeTuple("VirtualObject", "mine");
	};
	
  object:{
   def initializeMap() {
	   //add crime targets and virtual objects for gangsters.
	   addCrimeTarget("Bank", [30, 50], 100000, EXPLOSIVES, ROPE_LADDER);
	   addCrimeTarget("Bank", [10, 190], 200000,EXPLOSIVES, LASER_JAMMER);
     addCrimeTarget("Jewlery", [100, 210], 300000, KNIFE, MASK);
     addCrimeTarget("Casino", [90, 50], 500000, GUN);
     addCrimeTarget("Jewlery", [180, 90], 800000, SWISS_ARMY_KNIFE, GLASS_BREAKER);
	   10.doTimes: { |i| 
	    addVirtualObjects(typeToString(virtualObjects[randomNumberBetween(1, virtualObjects.length)]) ,[randomNumberBetween(0, 250), randomNumberBetween(0, 270)])
	   };
	   addVirtualObjects(typeToString(GUN), [100,100]);
	   system.println("Server initialized!");
	 };
	};	
};

// added for debug purposes
def templateTableToString(t){
	def ret := [];
  t.each: { |part| 
	  if: /.at.crime.CrimeConnection.isJavaObject(part) then: {
		  ret := ret + [part];  // it is a constrain. 
		} else:{
			ret := ret + [part.content.toString];
		};	
	};
	ret;
};

def makePlayer(username, team) {
system.println("makePlayer " +username);
  def myTs := makeTupleSpace(team);
  def teamPlayers := jlobby.java.util.HashMap.new();
	def location := [0,0];
	def totalReward := 0;
	
  def localFacade :=  object:{
	  def updatePlayerLocation(newLocation){
			location := newLocation;
			//add your own position for your self in the ts.
			//myTs.add(makeTuple("PlayerInfo", username, team, location));
		  //broadcast your own position. positionTuple is visible to your team members or nearby enemies!
		  myTs.inject: makeTuple("PlayerInfo", username, team, location) inContext: [ makeTemplate("TeamInfo", var: `u, team), var: `u notEquals: username ] withLeaseFor: TEAM_POSITION_TIMEOUT;
	  };
	  def initialize() {
			myTs.goOnline;
			myTs.add(makeTuple("TeamInfo", username, team));
			//track location of team members;
			myTs.whenever: makeTemplate("PlayerInfo", var: `u, var: `t, var: `loc) read: {
				//def loc := [x,y];
				system.println("receiving player info " + u + " team " + t + " loc " + loc + " my username " + username);
				//TODO: added because I could get triggered by my own tuples, but with the user interface I don't want that now.
			  listener.displayPlayerPosition(t, u, loc);
			  //TODO: If I receive the position of opposite team members, then I should show a timer in the GUI.
			} outOfContext:{
				//if a user do not update its coordinates, show his latest position in grey
				timerModule.when: 2.seconds() elapsed: {
				  def newPlayerInfoTuple := myTs.read(makeTemplate("PlayerInfo", u, var: `t, var: `loc));
				  if: (nil == newPlayerInfoTuple) then: {
				    listener.showOffline(u);
			    };
		    };
			};			
			// policemen and gangsters get to know when some gangster has committed a crime and its reward.
			myTs.whenever: makeTemplate("CrimeCommitted", var: `name, var: `loc, var: `reward, var: `username) read:{
				if: ( BLUE == team) then: { 
					totalReward := totalReward + reward;
					listener.display("Pas Op! Gangsters have already stolen a total value of " + totalReward);
				};
				listener.display("Gangster " + username + " committed crime for a value of " + reward );
				listener.displayCrimeTarget(name, loc, false);
			};
			//notify every 6 minutes communicate your position to the opposite team members.
			timerModule.whenever: OPPOSITE_TEAM_POSITION_TIMEOUT elapsed:{
				myTs.inject:  makeTuple("PlayerInfo", username, team, location) inContext: [ makeTemplate("TeamInfo", var: `x, var: `team), var: `team notEquals: team ];
			};
			//init specific behaviour for gangsters to commit crimes.
			if: (RED == team) then: { initGangsters()};
	  };
	  def dropVirtualObject(name){
		  inject: 
	  };
	  def initGangsters(){
			//display the crime targets known at the begining
			myTs.whenever: makeTemplate("CrimeTarget", var: `name, var: `loc) read:{
				 listener.displayCrimeTarget(name, loc, true);
			};
			//commit a crime. This tuple only gets active when you have all the necessary items and are closeby the place.
			myTs.whenever: makeTemplate("CommitCrime", var: `name, var: `loc, var: `reward, var: `items) read:{
				listener.display("You can commit a crime on " + name + ". Your reward is " + reward);
				totalReward := totalReward + reward;
				//assuming that virtual objects are local entities!!
				items.each: { |item| 
					system.println("removing virtualObject " + item);
					 if: (nil != myTs.delete(makeTuple("VirtualObject", item))) then:{
					   listener.removeVirtualObject(item);
			     };
				};
				//BETTER IF: myTs.antituple: makeTuple("CrimeTarget", name, x, y);
				myTs.inject: makeTuple("CrimeCommitted", name, loc, reward, username);
				listener.displayCrimeTarget(name, loc, false);
				// TODO: user interface should provide a yes/no button. So you shouldn't match until it says yes/no!
			};
			//notify user of the finding of a virtual object
			myTs.whenever: makeTemplate("VirtualObject", var: `itemName) read: {
				system.println("receiving a virtual object " + itemName);
				if: isDropableObject(name) then:{
					 weapons.add(name);
				};
				listener.addVirtualObject(itemName);
			};
			myTs.whenever: makeTemplate()
	  };
	};
 	def listener := gameGUI.new(localFacade, team, username);
  localFacade;	
};

network.online;
self;

