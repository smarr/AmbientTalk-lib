/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2008
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

// private stuff goes here
//import /.at.urbiflock.flockr;
def HashMap := jlobby.java.util.HashMap;
def Vector := /.at.collections.vector.Vector;


//helper function to test locally the engine.
def getId(profile) {
	profile.username;
};

def POSITIVE := true;
def NEGATIVE := false; 

def makeToken(sign, profile) { 
	object: {	
		def getSign() {
			sign;
		};
		def getFlockr() {
			profile;
		};	
	};
};

def makeFilter(predicate) {
	object: {
		def pass(RemoteInterface) {
			predicate(RemoteInterface);
		};
	};
};

def makeMemory(keyFunction) {
	object: {
	  def tokens := HashMap.new();
	
	  def insert(Object) {
		   tokens.put(keyFunction(Object),Object);
	  };
	
	  def contains(Object) {
		  tokens.containsKey(keyFunction(Object));
	  };
	
	  def remove(Object) {
		  tokens.remove(keyFunction(Object));
	  };
  };
};

def makeFilterNode(filter) {
	object: {
		def pass := {|Token| nil};
		
		def passAsToken(sign,RemoteInterface) {
			pass(makeToken(sign,RemoteInterface));
		};
		
		def insert(RemoteInterface) {
			if: filter.pass(RemoteInterface) then: {
				passAsToken(POSITIVE,RemoteInterface);
			};
		};
		
		def remove(RemoteInterface) {
			if: filter.pass(RemoteInterface) then: {
				passAsToken(NEGATIVE,RemoteInterface);
			};
		};

	};
};

def makeChangeNode(filter) {
	extend: makeFilterNode(filter) with: {
		def memory := makeMemory({|RemoteInterface| getId(RemoteInterface)});
		
		def changeEvent(RemoteInterface) {
			if: filter.pass(RemoteInterface) then: {
				if: !memory.contains(RemoteInterface) then: {
					memory.insert(RemoteInterface);
					super^passAsToken(POSITIVE,RemoteInterface);
				};
			} else: {
				if: memory.contains(RemoteInterface) then: {
					memory.remove(RemoteInterface);
					super^passAsToken(NEGATIVE,RemoteInterface);
				};
			};
		};		
	};
};

def makeOrJoinNode(fleft, fright){
  extend: makeFilterNode(makeFilter(makeFilter({|v| true}))) with: {
	  def mleft := makeMemory({|Token| getId(Token.getFlockr)});
		def mright := makeMemory({|Token| getId(Token.getFlockr)});
	  
	  def rightPass(token){
		  if: (token.getSign) then:{
			  mright.insert(token);
			  if: !mleft.contains(token) then: {
				  super^pass(token);
			  };
		  } else:{
			 if: mright.contains(token) then:{
				  mright.remove(token);
				  if: !mleft.contains(token) then:{
					  super^pass(token);
				  };
			  };
		  };
	  };
	
	  def leftPass(token){
		  if: (token.getSign) then:{
			  mleft.insert(token);
			  if: !mright.contains(token) then: {
				  super^pass(token);
			  };
		  } else:{
			 if: mleft.contains(token) then:{
				  mleft.remove(token);
				  if: !mright.contains(token) then:{
					  super^pass(token);
				  };
			  };
		  };
	  };
	
		fleft.pass := {|Token| self.leftPass(Token)};
		fright.pass := {|Token| self.rightPass(Token)};	
	
  };
};



def makeAndJoinNode(fleft, fright){
  extend: makeFilterNode(makeFilter({|v| true})) with: {
	  def mleft := makeMemory({|Token| getId(Token.getFlockr)});
		def mright := makeMemory({|Token| getId(Token.getFlockr)});
	  
	  def rightPass(token){
		  if: (token.getSign) then:{
			  mright.insert(token);
			  if: mleft.contains(token) then: {
				  super^pass(token);
			  };
		  } else:{
			 if: mright.contains(token) then:{
				  mright.remove(token);
				  if: mleft.contains(token) then:{
					  super^pass(token);
				  };
			  };
		  };
	  };
	
	  def leftPass(token){
		  if: (token.getSign) then:{
			  mleft.insert(token);
			  if: mright.contains(token) then: {
				  super^pass(token);
			  };
		  } else:{
			 if: mleft.contains(token) then:{
				  mleft.remove(token);
				  if: mright.contains(token) then:{
					  super^pass(token);
				  };
			  };
		  };
	  };
	
		fleft.pass := {|Token| self.leftPass(Token)};
		fright.pass := {|Token| self.rightPass(Token)};	
	
  };
};


def makeProximity(reteNode) {
	object: {
		def listeners := Vector.new();
	
		def register(listener) {
			listeners.add(listener);
		};
	
		def getReteNode(){ reteNode };
		
		def notifyFromNode(Token) {
				system.println("P:notifyFromNode " +Token.getSign);
				if: Token.getSign then: {
					system.println("P:listeners " + listeners);
						listeners.each: {|listener| 
							system.println("P: listener " + listener);
							listener.addFlockr(Token.getFlockr); };				
					} else: {
						listeners.each: {|listener| listener.removeFlockr(Token.getFlockr); };					 
				};
		};
		
		def connect () {
			reteNode.pass := {|Token| self.notifyFromNode(Token) };
		};	
		connect();
	};
};

def makeIsFriendProximity(flockr) {
	def isFriendProximity := extend: makeProximity(makeFilterNode(makeFilter({|RI| true}))) with: {
		//  invoked whenever a buddy was manually added to this flockr's buddy list
		def notifyBuddyAdded(profile) {
			system.println("P:notifyBuddyAdded " +profile);
			super^getReteNode().insert(profile);
		};

    //invoked whenever a buddy was manually removed from this flockr's buddy list
    def notifyBuddyRemoved(profile) {
			super^getReteNode().remove(profile);
		};
		super^connect();	
	};
	flockr.registerBuddyListListener(isFriendProximity);
	isFriendProximity;
};

def makeAndProximity(leftP, rightP) {
	makeProximity( makeAndJoinNode(leftP.getReteNode , rightP.getReteNode ) );
};

def makeOrProximity(leftP, rightP) {
	makeProximity( makeOrJoinNode(leftP.getReteNode , rightP.getReteNode ) );
};

def makeProfileChangedProximity(block) {
		def newBlockStatements := `{ |profile| #@(block.method.bodyExpression.statements) };
		def profilePredicate := eval: newBlockStatements in: block.context.lexicalScope;
		def profileChangedProximity := extend: makeProximity(makeFilterNode( makeFilter( profilePredicate ) )) with: {
			
		};
		
		profileChangedProximity;
};

// the module object of this file
object: {
	// public stuff goes here
  def makeFilter := &makeFilter;
	def makeIsFriendProximity := &makeIsFriendProximity;
	
	def ProximityTest := extend: /.at.unit.test.UnitTest.new("ProximityTest") with: {
		
		def FEMALE := 1;
		def MALE := 0;
		
		import /.at.support.timer;
				
		def testFriendsFlock(){
			def profile1 := /.at.urbiflock.profile.makeProfile();
			profile1.username := "flockr1";
			def flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);
			def profile2 := /.at.urbiflock.profile.makeProfile();
			profile2.username := "flockr2";
			flockr1.addBuddy(profile2);
			def friendFlock := flockr1.getFlock("FriendsFlock");
			
			when: seconds(5) elapsed: {
			  self.assertEquals(1, friendFlock.getFlockrList.length);	
			};			
		};
		
		def testFilterFriendFlock(){
	
			def profile1 := /.at.urbiflock.profile.makeProfile();
			profile1.username := "flockr1";
			def flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);
			def profile2 := /.at.urbiflock.profile.makeProfile();
			profile2.username := "flockr2";
			profile2.birthdate := "12/07/1985";
			profile1.sex := "MALE";
			// Adding predifined flocks
			flockr1.addFlock(makeFlock("GirlFriends", makeProfileChangedProximity({ profile.sex == FEMALE })));
			flockr1.addBuddy(profile2);
			
			
			def friendFlock := flockr1.getFlock("FriendsFlock");
			
			when: seconds(5) elapsed: {
			  self.assertEquals(1, friendFlock.getFlockrList.length);	
			};			
		};
				
		// unit tests for RETE network go here
/*		
		def testChangedFired() {
			def testChangeRemoteInterface := object: {
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNode :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			testChangeNode.pass := {|Token| fired := Token.getSign};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertTrue(fired);
			self.assertTrue(testChangeNode.memory.contains(testChangeRemoteInterface));
		};
		
		def testChangedNotFired() {
			def testChangeRemoteInterface := object: {
				def age := 23;
				def username := 5;
			};
			def fired := false;
			def testChangeNode :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			testChangeNode.pass := {|Token| fired := Token.getSign};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertFalse(fired);
			self.assertFalse(testChangeNode.memory.contains(testChangeRemoteInterface));
		};
		
		def testChangedNotFiredAndFired() {
			def testChangeRemoteInterface := object: {
				def age := 25;
				def username := 5;
			};
			def fired := false;
			def testChangeNode :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			testChangeNode.pass := {|Token| fired := Token.getSign};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertFalse(fired);
			self.assertFalse(testChangeNode.memory.contains(testChangeRemoteInterface));
			testChangeRemoteInterface.age := 27;
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertTrue(fired);
			self.assertTrue(testChangeNode.memory.contains(testChangeRemoteInterface));
		};
		
		def testChangedFiredAndNotFired() {
			def testChangeRemoteInterface := object: {
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNode :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			testChangeNode.pass := {|Token| fired := Token.getSign};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertTrue(fired);
			self.assertTrue(testChangeNode.memory.contains(testChangeRemoteInterface));
			testChangeRemoteInterface.age := 23;
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertFalse(fired);
			self.assertFalse(testChangeNode.memory.contains(testChangeRemoteInterface));
		};
		
		def testChangedFiredAndShouldNotFired() {
			def testChangeRemoteInterface := object: {
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNode :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			testChangeNode.pass := {|Token| fired := Token.getSign};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertTrue(fired);
			self.assertTrue(testChangeNode.memory.contains(testChangeRemoteInterface));
			testChangeRemoteInterface.age := 28;
			testChangeNode.pass := {|Token| fired := false};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertTrue(fired);
			self.assertTrue(testChangeNode.memory.contains(testChangeRemoteInterface));
		};
		
		def testChangedNotFiredAndShouldNotFired() {
			def testChangeRemoteInterface := object: {
				def age := 23;
				def username := 5;
			};
			def fired := false;
			def testChangeNode :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			testChangeNode.pass := {|Token| fired := Token.getSign};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertFalse(fired);
			self.assertFalse(testChangeNode.memory.contains(testChangeRemoteInterface));
			testChangeRemoteInterface.age := 24;
			testChangeNode.pass := {|Token| fired := true};
			testChangeNode.changeEvent(testChangeRemoteInterface);
			self.assertFalse(fired);
			self.assertFalse(testChangeNode.memory.contains(testChangeRemoteInterface));
		};
		
		def testAndFired(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
			testAndNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
		  // left true - right true -> fire (pass +)	
			self.assertTrue(fired);
      self.assertTrue(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testAndNotFiredL(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 25;
				def username := 5;
			};
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
			testAndNode.pass := {|Token| self.assertTrue(false)};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left false - right true -> not fire (nothing)			
      self.assertFalse(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
 		};

  	def testAndNotFiredR(){
			def testChangeRemoteInterface := object: {
	      def sex := FEMALE;
				def age := 26;
				def username := 5;
			};
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
			testAndNode.pass := {|Token| self.assertTrue(false)};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);		
			// left true - right left -> not fire (nothing)	
      self.assertTrue(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
 		}; 
 
    def testAndNotFiredLNotFiredR(){
				def testChangeRemoteInterface := object: {
		      def sex := FEMALE;
					def age := 25;
					def username := 5;
				};
				def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
				def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
				def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
				testAndNode.pass := {|Token| self.assertTrue(false)};
				testChangeNodeL.changeEvent(testChangeRemoteInterface);			
				testChangeNodeR.changeEvent(testChangeRemoteInterface);	
				// left false - right false -> not fire (nothing)		
	      self.assertFalse(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
				self.assertFalse(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
	  };
	  
		def testAndNotFiredAndShoudNotFireL(){
			def testChangeRemoteInterface := object: {
	      def sex := FEMALE;
				def age := 27;
				def username := 5;
			};
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
			testAndNode.pass := {|Token| self.assertTrue(false)};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left true - right false -> not fire (nothing)		
			self.assertTrue(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change on node left -> not fire
			testChangeRemoteInterface.age := 24;
		  testChangeNodeL.changeEvent(testChangeRemoteInterface);
			self.assertFalse(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
	  
	  def testAndNotFiredAndShoudNotFireR(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 24;
				def username := 5;
			};
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
			testAndNode.pass := {|Token| self.assertTrue(false)};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left false - right true -> not fire (nothing)		
			self.assertFalse(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change on node right -> not fire
			testChangeRemoteInterface.sex := FEMALE;
		  testChangeNodeR.changeEvent(testChangeRemoteInterface);
			self.assertFalse(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		
		def testFiredAndShoudFireNegTokenR(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
			testAndNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left true - right true -> fire (pass +)		
			self.assertTrue(fired);
			self.assertTrue(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change on node right -> not fire
			testChangeRemoteInterface.sex := FEMALE;
		  testChangeNodeR.changeEvent(testChangeRemoteInterface);
			self.assertFalse(fired);
			self.assertTrue(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testFiredAndShoudFireNegTokenL(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testAndNode := makeAndJoinNode(testChangeNodeL, testChangeNodeR);
			testAndNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left true - right true -> fire (pass +)		
			self.assertTrue(fired);
			self.assertTrue(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change on node left -> not fire
			testChangeRemoteInterface.age := 24;
		  testChangeNodeL.changeEvent(testChangeRemoteInterface);
			self.assertFalse(fired);
			self.assertFalse(testAndNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testAndNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testOrFiredLR(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testOrNode := makeOrJoinNode(testChangeNodeL, testChangeNodeR);
			testOrNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left true - right true -> fire (pass +)		
			self.assertTrue(fired);
      self.assertTrue(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testOrFiredL(){
			def testChangeRemoteInterface := object: {
	      def sex := FEMALE;
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testOrNode := makeOrJoinNode(testChangeNodeL, testChangeNodeR);
			testOrNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);		
			// left true - right false -> fire (pass +)	
			self.assertTrue(fired);
      self.assertTrue(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testOrFiredR(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 25;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testOrNode := makeOrJoinNode(testChangeNodeL, testChangeNodeR);
			testOrNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left false - right true -> fire (pass +)		
			self.assertTrue(fired);
      self.assertFalse(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testOrNotFired(){
			def testChangeRemoteInterface := object: {
	      def sex := FEMALE;
				def age := 25;
				def username := 5;
			};
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testOrNode := makeOrJoinNode(testChangeNodeL, testChangeNodeR);
			testOrNode.pass := {|Token| self.assertTrue(false)};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);	
			// left false - right false -> not fire (nothing)		
      self.assertFalse(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testOrFiredLShouldNotFire(){
			def testChangeRemoteInterface := object: {
	      def sex := FEMALE;
				def age := 26;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testOrNode := makeOrJoinNode(testChangeNodeL, testChangeNodeR);
			testOrNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);		
			// left true - right false -> fire	(pass +)
			self.assertTrue(fired);
      self.assertTrue(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change left -> not fire (nothing)
			testChangeRemoteInterface.age := 24;
		  testChangeNodeL.changeEvent(testChangeRemoteInterface);
			testOrNode.pass := {|Token| self.assertTrue(false)};
      self.assertFalse(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testOrFiredRShouldNotFire(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 25;
				def username := 5;
			};
			def fired := false;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testOrNode := makeOrJoinNode(testChangeNodeL, testChangeNodeR);
			testOrNode.pass := {|Token| fired := Token.getSign};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);			
			testChangeNodeR.changeEvent(testChangeRemoteInterface);		
			// left false - right true -> fire	(pass +)
			self.assertTrue(fired);
      self.assertFalse(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change right -> not fire (nothing)
			testChangeRemoteInterface.sex := FEMALE;
		  testChangeNodeR.changeEvent(testChangeRemoteInterface);
			testOrNode.pass := {|Token| self.assertTrue(false)};
      self.assertFalse(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		def testOrFiredRLShouldNotFire(){
			def testChangeRemoteInterface := object: {
	      def sex := MALE;
				def age := 26;
				def username := 5;
			};
			def fired := 0;
			def testChangeNodeL :=  makeChangeNode(makeFilter({|RI| RI.age > 25}));
			def testChangeNodeR :=  makeChangeNode(makeFilter({|RI| RI.sex == MALE}));			
			def testOrNode := makeOrJoinNode(testChangeNodeL, testChangeNodeR);
			testOrNode.pass := {|Token| 
				if: Token.getSign then: {fired := fired +1;}
				else: { fired := fired -1 };
			};
			testChangeNodeL.changeEvent(testChangeRemoteInterface);	
			// left true - right true -> fire	(pass +)
			self.assertEquals(1, fired); 		
			testChangeNodeR.changeEvent(testChangeRemoteInterface);		
			// checking only one pass +
			self.assertEquals(1, fired);
      self.assertTrue(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertTrue(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change right -> not fire (nothing) because false - true but you already triggered the true
			testChangeRemoteInterface.sex := FEMALE;
		  testChangeNodeR.changeEvent(testChangeRemoteInterface);
			self.assertEquals(1,fired);
      self.assertTrue(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			// change left -> not fire (pass -)
			testChangeRemoteInterface.age := 24;
		  testChangeNodeL.changeEvent(testChangeRemoteInterface);
			self.assertEquals(0,fired);
      self.assertFalse(testOrNode.mleft.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
			self.assertFalse(testOrNode.mright.contains(makeToken(POSITIVE,testChangeRemoteInterface)));
		};
		
		*/
		
	};
};