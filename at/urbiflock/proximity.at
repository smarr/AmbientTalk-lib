/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2008
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

def HashMap := jlobby.java.util.HashMap;
def Vector := /.at.collections.vector.Vector;
def Rete := /.at.urbiflock.rete.makeRete({|profile| profile.username});

// a proximity is an object wrapping a rete node 
// + the behaviour for storing and notifying observers of changes in the rete.
// In Urbiflock, flocks get registered to proximities. 
def makeProximity(reteNode) {
	//public interface of proximity
	object: {
		def listeners := Vector.new();
	
		def register(listener) { 
			listeners.add(listener);
			object: {
				def cancel() {listeners.remove(listener)};
			} 
		};	
		def getReteNode(){ reteNode };
		
		def notifyFromNode(Token) {
				if: Token.getSign then: {
						listeners.each: {|listener| 
							listener.addFlockr(Token.getFlockr); };				
					} else: {
						listeners.each: {|listener| listener.removeFlockr(Token.getFlockr); };					 
				};
		};
		def connect() {
			reteNode.pass := {|Token| self.notifyFromNode(Token) };
		};	
		connect();
	};
};

//default proximities offered by the framework
// encodes the friendship relationships based on the buddy list
def makeIsFriendProximity(flockr) {
	def isFriendProximity := extend: makeProximity(Rete.makeFilterNode(Rete.makeFilter({|RI| true}))) with: {
		//  invoked whenever a buddy was manually added to this flockr's buddy list
		def notifyBuddyAdded(profile) {
			super^getReteNode().insert(profile);
		};
    //invoked whenever a buddy was manually removed from this flockr's buddy list
    def notifyBuddyRemoved(profile) {
			super^getReteNode().remove(profile);
		};
		// COMMENT Tom: why do we call 'connect' here? The parent already connect itself
		// when it is created (in makeProximity). It could be useful if we would override
		// 'connect()' in this child object, but we don't.
		super^connect();	
	};
	flockr.registerBuddyListListener(isFriendProximity);
	isFriendProximity;
};

// encodes physical proximity function
def makeIsNearbyProximity(flockr) {
	def isNearbyProximity := extend: makeProximity(Rete.makeFilterNode(Rete.makeFilter({|RI| true}))) with: {
		//  invoked whenever a buddy comes nearby
		def notifyJoined(profile) {
			super^getReteNode().insert(profile);
		};
    //invoked whenever a flockr comes nearby
    def notifyLeft(profile) {
			super^getReteNode().remove(profile);
		};
		// COMMENT Tom: why do we call 'connect' here? The parent already connect itself
		// when it is created (in makeProximity). It could be useful if we would override
		// 'connect()' in this child object, but we don't.
		super^connect();	
	};
	flockr.registerDiscoveryListener(isNearbyProximity);
	isNearbyProximity;
};

//encodes a proximity fucntion that test an attribute of a flockr profile. 
def makeDoesProfileMatchProximity(flockr, block) {
		def newBlockStatements := `{ |profile| #@(block.method.bodyExpression.statements) };
		def profilePredicate := eval: newBlockStatements in: block.context.lexicalScope;
		def profileChangedProximity := extend: makeProximity(Rete.makeChangeNode( Rete.makeFilter( profilePredicate ) )) with: {
			def notifyProfileChanged(farref, profile) {
				super^getReteNode().changeEvent(profile);
			};
			super^connect();	
		};
		flockr.registerProfileChangedListener(profileChangedProximity);
		profileChangedProximity;
};
// encodes a proximity function implementing the and operator on two given proximities.
def makeAndProximity(leftP, rightP) {
	makeProximity( Rete.makeAndJoinNode(leftP.getReteNode , rightP.getReteNode ) );
};

// encodes a proximity function implementing the or operator on two given proximities.
def makeOrProximity(leftP, rightP) {
	makeProximity( Rete.makeOrJoinNode(leftP.getReteNode , rightP.getReteNode ) );
};

// the module object of this file
def ProximityModule := object: {
	// public stuff goes here
	def makeIsFriendProximity := &makeIsFriendProximity;
	def makeDoesProfileMatchProximity := &makeDoesProfileMatchProximity;
	def makeIsNearbyProximity := &makeIsNearbyProximity;	
	def makeAndProximity := &makeAndProximity;
	def makeOrProximity := &makeOrProximity;

	
	def ProximityTest := extend: /.at.unit.test.UnitTest.new("ProximityTest", false) with: {
		def waitTime := 2;
		import /.at.support.timer;
		import /.at.lang.futures exclude seconds, minutes, millisec;
		enableFutures(false);
				
		def testAsyncFriendsFlock(){
			def [fut,res] := makeFuture();
			def profile1 := /.at.urbiflock.profile.makeProfile();
			profile1.username := "PF1.1";
			def flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);
			def profile2 := /.at.urbiflock.profile.makeProfile();
			profile2.username := "PF1.2";
			flockr1.addBuddy(profile2);
			def friendFlock := flockr1.getFlock("FriendsFlock");
			
			when: seconds(waitTime) elapsed: {
			  self.assertEquals(1, friendFlock.getFlockrList.length);	
				flockr1.stop();
			  res.resolve(`ok);
			};	
			fut;		
		};
		
		def testAsyncFriendsOrFilterFlock(){
			def [fut,res] := makeFuture();
			def profile1 := /.at.urbiflock.profile.makeProfile();
			profile1.username := "PF2.1";
			def profile2 := /.at.urbiflock.profile.makeProfile();
			profile2.username := "PF2.2";

			def a := actor: {
				import /.at.support.timer;
				
				def profile2 := /.at.urbiflock.profile.makeProfile();
				profile2.username := "PF2.2";
				profile2.sex := "MALE";  
				def flockr22 := /.at.urbiflock.flockr.makeFlockr(profile2);
				def sexChange() {
					profile2.sex := "FEMALE";
					network.offline();
					when: seconds(waitTime) elapsed: {
						network.online();
						flockr22.stop();
						flockr22 := /.at.urbiflock.flockr.makeFlockr(profile2);
					};
					nil;
				};
				def stopFlockrs(){
					flockr22.stop();
				};
		  };

			def flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);
			def femaleProximity := makeDoesProfileMatchProximity(flockr1 , { profile.sex == "MALE" });
			def friendProximity := makeIsFriendProximity(flockr1);
			def friendAndFemaleProximity := makeOrProximity(femaleProximity, friendProximity);
			def FriendsAndFemaleFlock := /.at.urbiflock.flock.makeFlock("FriendsAndFemaleFlock", friendAndFemaleProximity);

			flockr1.addFlock(FriendsAndFemaleFlock);
			flockr1.addBuddy(profile2);

			when: seconds(waitTime) elapsed: {
			  self.assertEquals(1, FriendsAndFemaleFlock.getFlockrList.length);	
				flockr1.removeBuddy(profile2);
				when: seconds(waitTime) elapsed: {
					self.assertEquals(1, FriendsAndFemaleFlock.getFlockrList.length);
					when:	a<-sexChange()@FutureMessage becomes: { |val|
							when: seconds(waitTime*3) elapsed: {
								self.assertEquals(0, FriendsAndFemaleFlock.getFlockrList.length);
								when: a<-stopFlockrs()@FutureMessage becomes: { |ack|
									flockr1.stop();
									res.resolve(true);
								};
							};
					};
				};
			};
			fut;			
		};
		
		def testAsyncFriendsAndFilterFlock(){
			
			def [fut, res] := makeFuture();
			def profile1 := /.at.urbiflock.profile.makeProfile();
			profile1.username := "PF3.1";
			def profile2 := /.at.urbiflock.profile.makeProfile();
			profile2.username := "PF3.2";
			
			def a := actor: {
				def profile2 := /.at.urbiflock.profile.makeProfile();
				profile2.username := "PF3.2";
				profile2.sex := "MALE";  
				def flockr32 := /.at.urbiflock.flockr.makeFlockr(profile2);
				def stopFlockrs(){
					flockr32.stop();
				};
			};

			def flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);			
			def femaleProximity := makeDoesProfileMatchProximity(flockr1 , { profile.sex == "MALE" });
			def friendProximity := makeIsFriendProximity(flockr1);
			def friendAndFemaleProximity := makeAndProximity(femaleProximity, friendProximity);
			def FriendsAndFemaleFlock2 := /.at.urbiflock.flock.makeFlock("FriendsAndFemaleFlock2", friendAndFemaleProximity);
			
			flockr1.addFlock(FriendsAndFemaleFlock2);
			flockr1.addBuddy(profile2);
					
			when: seconds(waitTime*3) elapsed: {
			  self.assertEquals(1, FriendsAndFemaleFlock2.getFlockrList.length);	
				flockr1.removeBuddy(profile2);
				when: seconds(waitTime) elapsed: {
					self.assertEquals(0, FriendsAndFemaleFlock2.getFlockrList.length);
					when: a<-stopFlockrs()@FutureMessage becomes: { |ack|
						flockr1.stop();
						res.resolve(`ok);			
					};
				};
			};
			fut;			
		};
		
		def testAsyncFilterFriendFlock(){	
			def [fut,res] := makeFuture();
			def profile1 := /.at.urbiflock.profile.makeProfile();
			profile1.username := "PF4.1";
			profile1.sex := "MALE";
			def flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);
			
			def a := actor: {
				def profile2 := /.at.urbiflock.profile.makeProfile();
				profile2.username := "PF4.2";
				profile2.sex := "FEMALE";  
				def flockr42 := /.at.urbiflock.flockr.makeFlockr(profile2);
				def stopFlockrs(){
					flockr42.stop();
				};
			};
			
			def b := actor: {
				def profile3 := /.at.urbiflock.profile.makeProfile();
				profile3.username := "PF4.3";
				profile3.sex := "FEMALE";  
				def flockr43 := /.at.urbiflock.flockr.makeFlockr(profile3);
				def stopFlockrs(){
					flockr43.stop();
				};
			};
			
			// Adding predifined flocks
			def matchingProfile := /.at.urbiflock.profile.makeProfile();
			matchingProfile.sex := "FEMALE";
			flockr1.addFlock(/.at.urbiflock.flock.makeFlock("GirlFriends", makeDoesProfileMatchProximity(flockr1 , { profile.sex == matchingProfile.sex })));
			def girlFriendFlock := flockr1.getFlock("GirlFriends");
			
			when: seconds(waitTime*4) elapsed: {
			  self.assertEquals(2, girlFriendFlock.getFlockrList.length);	
			  def f := group: [a<-stopFlockrs()@FutureMessage, b<-stopFlockrs()@FutureMessage];
				when: f becomes: {|ack| 
					flockr1.stop(); 
					res.resolve(`ok); 
				}; 
			};
			fut;			
		};
		
		/*	def testAsyncNearbyFlock(){
				def [fut,res] := makeFuture();
				def profile1 := /.at.urbiflock.profile.makeProfile();
				profile1.username := "PF5.1";

				def a := actor: {
					def profile2 := /.at.urbiflock.profile.makeProfile();
					profile2.username := "PF5.2";
					def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
					def stopFlockrs(){
						flockr2.stop();
					};
				};	

				def nearbyFlock := flockr1.getFlock("NearbyFlock");
				when: seconds(waitTime) elapsed: {
				  self.assertEquals(1, nearbyFlock.getFlockrList.length);	
					when: a<-stopFlockrs()@FutureMessage becomes: { |ack|
						flockr1.stop();
				  	res.resolve(`ok);
					};
				};	
				fut;		
			};*/
			
	};
};