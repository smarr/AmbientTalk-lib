/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2008
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
def AmbientTotaModule := /.at.urbiflock.ambientTota;
def FutureModule := /.at.lang.futures;

def Vector := /.at.collections.vector.Vector;
deftype Guanotes;

def makeGuanotes(aFlockr) { 
	def subscription;
  // local interface of guanotes
  def localInterface := extend: /.at.urbiflock.application.makeApplication("Guanotes", aFlockr) with:{
	  //added for testing - to think if it should go to local interface or not.
	  def getConnectedFlockrs(){ guanotesTS.getConnectedFlockrs };
	  //helper function to flatten a flock.
	  //maybe move to flock.at?
 	  def currentFlock(flockName){
	    guanotesTS.flockr.getFlock(flockName).getFlockrList();
    };
    //installs a listener for guanotes matching the predicate
    // replaced the old listenGuanotes for this:
    def when: predicate received: block {
	    guanotesTS.when: predicate matches: { |guanote|
		    block(guanote);  
		  };
    };   
    // injects a guanote into the ambient.
    def sendGuanote(aGuanote){
		  guanotesTS.inject: aGuanote;
    }; 
    // guanote has 3 predefined fields: sender, receiver, message
    def makeGuanote(from, to, msg){
	   //generate ids on ambientTota
	    AmbientTotaModule.extendTuple: AmbientTotaModule.makeTuple()  with: {
		    def sender := from;  // fill in by at interface with gui
		    def receiver := to;  // an object which contains flock
		    def message := msg;
			system.println("making guanote " + self.tupleId + " from " + from + " msg " + msg + " to " + to.names);
		    // currently inheriting the default, i.e. a tuple that hops forever.
		    def decideStore(guanotesReceiverTS){ receiver.shouldReceive(guanotesReceiverTS.flockr.getUsername)};
        def decidePropagation(guanotesSenderTS){ 
	       { |return|
	          guanotesSenderTS.getConnectedFlockrs.each: { |username| 
		          if: receiver.shouldReceive(username) then: { system.println("propagating true for " + self.getTupleId + " to " + username);return(true) 
		          } else: { system.println("propagating false for " + self.getTupleId + " to " + username);};
		        };
		        false;
		     }.escape()
	      }; 
	    };
    };
		// helper function to extend guanotes without having to worry about isolate type tag.
		def extendGuanote: tuple  with: closure {
			extend: guanote with: closure taggedAs: [/.at.types.Isolate];
		};
    // overriding methods from application interface
		def start() {
			super^start();
		  //exporting guanotes as application
		  self.export(Guanotes);
		  //discovery other guanotes
		  subscription := self.registerApplicationListener( Guanotes, object:{
			  def notifyApplicationJoined(flockr, profile, remoteGuanotesTs){
				  guanotesTS.connectedFlockrs.add(profile.username);
				  guanotesTS.notifyTSDiscovered(remoteGuanotesTs);
			  };
			  def notifyApplicationLeft(flockr, profile, remoteGuanotesTs){
				system.println(" " + guanotesTS.getFlockrId +  " detected disconnection of " + profile.username);
				  guanotesTS.connectedFlockrs.remove(profile.username);
			  };
		  });
		};
		def stop(){
			super^stop();
			if: (subscription != nil) then: {subscription.cancel()};
		};	
  }; // end-localInterface
	// guanotesTS encapsulates the tuple space and the remote interface of guanotes
	def guanotesTS := extend: localInterface.remoteApplicationInterface with: {	
		import AmbientTotaModule.makeTupleSpace();
		// specific behaviour for guanotes
		def flockr := aFlockr;
		def connectedFlockrs := Vector.new();
		def getFlockrId(){
			 flockr.getUsername;
		 };
		def getConnectedFlockrs(){
		  connectedFlockrs.asTable();
	  };
	};
	// add application to a flockr.
	aFlockr.addApplication(self);
	// assigning guanotesTS as the remote interface.
	localInterface.remoteApplicationInterface := guanotesTS;
	
	localInterface;
}; // end-makeGuanotes

// the module object of this file
def GuanotesModule := object: {
	// public stuff goes here
	  def makeGuanotes := &makeGuanotes;
		
		def GuanotesTest := extend: /.at.unit.test.UnitTest.new("GuanotesTest", false) with: {
			//tests
			def waitTime := 2;
			import /.at.support.timer;
			import /.at.lang.futures exclude seconds, minutes, millisec;
		  enableFutures(false);
		
			def flockr1;
			def myGuanotes;
			def test := self;
			def notDown := true;
			
			def setUp() {
				// one flockr1 with 2 friends: flockr2 and flockr3.
				def profile1 := /.at.urbiflock.profile.makeProfile();
				profile1.username := "flockr1";
			  flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);
				def profile2 := /.at.urbiflock.profile.makeProfile();
				profile2.username := "flockr2";
		  	flockr1.addBuddy(profile2);
				def profile3 := /.at.urbiflock.profile.makeProfile();
				profile3.username := "flockr3";
		  	flockr1.addBuddy(profile3);
		    //setting up guanotes of flockr1
		    myGuanotes := makeGuanotes(flockr1);
		    myGuanotes.start();
			};
			
			def tearDown() {
				if: notDown then: {
					flockr1.goOffline();
				  myGuanotes.stop();
				  system.println("shutted down flockr1 and its guanotes");
				};
			};
					
			def testAsyncGuanoteToFlockr(){
				def [fut,res] := makeFuture();
				// sending a guanote to a flockr.
				def to := isolate: { 
					def names := "flockr2"; 
				//	def shouldReceive(flockr) { flockr.getProfile.username == name}; 
				  def shouldReceive(flockrId) { flockrId == names}; 
				};			
					
				def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, to, "HelloWorld");
				myGuanotes.sendGuanote(aGuanote);
		    // actor containing flockr2
				def a := actor: { |res,test|	
					def profile2 := /.at.urbiflock.profile.makeProfile();
					profile2.username := "flockr2";
				  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
			 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
			    myGuanotes.start();
				  // this should be composed via gui interface for every flock where a flockr is registered.
					myGuanotes.when: { |guanote| guanote.receiver.shouldReceive(flockr2.getUsername)} received: { |guanote|
					  //gui.popUpNote(guanote);
						test<-assertEquals("flockr1", guanote.sender);
						flockr2.goOffline();
						myGuanotes.stop();
						res<-resolve(`ok);
					};
			  };
				fut;
			}; 
			
			def testAsyncGuanoteToFlock(){
				def [fut,res] := makeFuture();
				// sending a guanote to a flatten flock, i.e. a list of flockrs.
		    def to := isolate: { 
					def names;
					def init(flockName){
							names := myGuanotes.currentFlock(flockName); 
					}; 
				 // def shouldReceive(flockr) { names.contains(flockr.getProfile.username) }; 
				  def shouldReceive(flockrId) { names.contains(flockrId) };
				}; 
				//Second option to send guanotes to a dynamic flock defined at receiver
				/*def to := object: {
				  def flock := "FriendsFlock"; 
				  def shouldReceive(flockr) { 
						(flockr.getFlock(name) != nil);
				  };
				};*/
				// waiting some time to be sure that flockr2,flockr3 belong to the flockr1 "FriendsFlock".			
				when: seconds(waitTime) elapsed: {
				  def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, to.new("FriendsFlock"), "HelloWorld");
				  myGuanotes.sendGuanote(aGuanote);
			  };
				// actor containing flockr2, which belongs to flockr1 "FriendsFlock"
				def a := actor: { |res, test|	
					def profile2 := /.at.urbiflock.profile.makeProfile();
					profile2.username := "flockr2";
				  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
			 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
			    myGuanotes.start();
       	  myGuanotes.when: { |guanote| guanote.receiver.shouldReceive(flockr2.getUsername)} received: { |guanote|
					  test<-assertEquals("flockr1", guanote.sender);
						flockr2.goOffline();
						myGuanotes.stop();
						res<-resolve(`ok);
					};
			  };
				fut;
			};	// end-testAsyncGuanoteToFlock
				
			def testAsyncGuanoteToFlockIndirectReception(){
					def [fut,res] := makeFuture();
					def [futTest,resTest] := makeFuture();
					// sending a guanote to a flatten flock, i.e. a list of flockrs.
        	def to := isolate: { 
						def names;
						def init(flockName){
							names := myGuanotes.currentFlock(flockName); 
							system.println(names);
						}; 
						// def shouldReceive(flockr) { names.contains(flockr.getProfile.username) }; 
						def shouldReceive(flockrId) { names.contains(flockrId) };
					}; 
          // waiting some time to be sure that flockr2,flockr3 belong to the flockr1 "FriendsFlock".			
					when: seconds(waitTime) elapsed: {
						def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, to.new("FriendsFlock"), "HelloWorld");
					  myGuanotes.sendGuanote(aGuanote);
				  };
				  // testing guanotes get received even if sender and receiver aren't connected at the same time.
		      // scenario: flockr3 should receive aGuanote by means of flockr2 because we will shut down flockr1.
		      def aFlockr3 := actor: { |res, test|	
						def profile3 := /.at.urbiflock.profile.makeProfile();
						profile3.username := "flockr3";
					  def flockr3 := /.at.urbiflock.flockr.makeFlockr(profile3);
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr3);
				    def goOnline() { myGuanotes.start()};
						myGuanotes.when: { |guanote| guanote.receiver.shouldReceive(flockr3.getUsername)} received: { |guanote|
							test<-assertEquals("flockr1", guanote.sender);
							flockr3.goOffline();
							myGuanotes.stop();
							res<-resolve(`ok);
						};
				  };
				  // flockr2 will get the note from flockr 1, shut it down, and then provoke the discovery of 
				  // flockr3 and pass him the note of flockr1.
					def aFlockr2 := actor: { |test, aFlockr3, waitTime|	
						import /.at.support.timer;
						def profile2 := /.at.urbiflock.profile.makeProfile();
						profile2.username := "flockr2";
					  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
				    myGuanotes.start();
				    def goOffline() {
							flockr2.goOffline();
							myGuanotes.stop();
				    };
						myGuanotes.when: { |guanote| guanote.receiver.shouldReceive(flockr2.getUsername)} received: { |guanote|
							test<-assertEquals("flockr1", guanote.sender);
							// shutting down flockr1 
							test<-tearDown();
							// set up flockr 3 after sometime has passed so that the disconnected events gets propagated.
							when: seconds(waitTime) elapsed: { aFlockr3<-goOnline()};
						};
				  };
				  // fut is resolved when flockr3 receives the guanote from flockr1.
				  when: fut becomes: { |ack|
					  when: aFlockr2<-goOffline()@FutureMessage becomes: { |ack|
						  notDown := false; 
						  resTest.resolve(`ok);
					  };
					};
					futTest;
				}; // end-testAsyncGuanoteToFlockIndirectReception
		/*		
				def testAsyncGuanoteToFlockNoReception(){
					def [fut,res] := makeFuture();
					// sending a guanote to a flatten flock, i.e. a list of flockrs.
			    def to := isolate: { 
						def names;
						def init(flockName){
								names := myGuanotes.currentFlock(flockName); 
						}; 
						def getReceivers() { names};
					  def shouldReceive(flockrId) { names.contains(flockrId) };
					}; 
					// flockr2 sends also a "Dag wereld" guanote to its friends when it gets the one of flockr1
					def aFlockr2 := actor: { |res, test|	
						def profile2 := /.at.urbiflock.profile.makeProfile();
						profile2.username := "flockr2";
					  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
						def profile4 := /.at.urbiflock.profile.makeProfile();
						profile4.username := "flockr4";
						flockr2.addBuddy(profile4); // assuming that the guanote of flockr1 arrives after the addBuddy has been proccessed.
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
				    myGuanotes.start();
	       	  myGuanotes.when: { |guanote| guanote.receiver.shouldReceive(flockr2.getUsername)} received: { |guanote|
						  test<-assertEquals("flockr1", guanote.sender);
							def to := isolate: { 
							  def names;
								def init(flockName){
									names := myGuanotes.currentFlock(flockName); 
								}; 
								def getReceivers() { names};
								def shouldReceive(flockrId) { names.contains(flockrId) };
						  };
						  def aGuanote := myGuanotes.makeGuanote(flockr2.getUsername, to.new("FriendsFlock"), "DagWereld");
							myGuanotes.sendGuanote(aGuanote);
							flockr2.goOffline();
							myGuanotes.stop();
						};
				  };
					// actor containing flockr3, which doesn't belong to flockr1 "FriendsFlock" 
					// but it will receive a guanote from flockr2 which is one of its friends.
				  def aFlockr4 := actor: { |res, test, waitTime|	
					  import /.at.support.timer;
								def profile4 := /.at.urbiflock.profile.makeProfile();
								profile4.username := "flockr4";
							  def flockr4 := /.at.urbiflock.flockr.makeFlockr(profile4);
						 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr4);
						    myGuanotes.start();
								myGuanotes.when: { |guanote| guanote.receiver.shouldReceive(flockr4.getUsername)} received: { |guanote|
									test<-assertEquals("flockr2", guanote.sender);
									test<-assertEquals("DagWereld", guanote.message);
									// leave sometime to be sure flockr2 and its guanotes disconnected.
									when: seconds(waitTime) elapsed: { 
										test<-assertEquals(1, myGuanotes.getConnectedFlockrs.length);
									  test<-assertTrue(myGuanotes.getConnectedFlockrs.contains("flockr1"));
									  flockr4.goOffline();
									  myGuanotes.stop();
									  res<-resolve(`ok);
									};
								};
						  };
							// waiting some time to be sure that flockr2,flockr4 belong to the flockr1 "FriendsFlock".			
							when: seconds(waitTime*2) elapsed: {
								test.assertTrue(myGuanotes.getConnectedFlockrs.contains("flockr4"));
							  def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, to.new("FriendsFlock"), "HelloWorld");
							  myGuanotes.sendGuanote(aGuanote);
						  };
					fut;
				};	// end-testAsyncGuanoteToFlockNoReception
		*/	 
		}; // endGuanotesTest

} // endGuanotesModule
