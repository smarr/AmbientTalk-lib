/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2008
 * Authors: PROG Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
def AmbientTotaModule := /.at.urbiflock.ambientTota;
def FutureModule := /.at.lang.futures;

def HashMap := jlobby.java.util.HashMap;
deftype Guanotes;

def makeGuanotes(aFlockr) {
	def subscription;	
	//hashmap remoteGuanoteTs - flockrId
	def connectedFlockrs := HashMap.new();
  // local interface of guanotes
  def localInterface := extend: /.at.urbiflock.application.makeApplication("Guanotes", aFlockr) with:{
		import AmbientTotaModule.makeTupleSpace();
		// gets the flockr id we are about to send guannotes
		def getReceiverFlockrId() {
			connectedFlockrs.get(self.getCurrentReceiverTs());
		};
		// gets the connected flockrs via guanotes.
		def getConnectedFlockrs(){
			connectedFlockrs.values.toArray();
		};
	  //helper function to flatten a flock.
	  //maybe move to flock.at?
 	  def currentFlock(flockName){
	    def flock := aFlockr.getFlock(flockName);
			if: flock != nil then: {
				flock.getFlockrList();
			} else: {
				[];
			};
    };

    //installs a listener for guanotes matching the predicate
    // replaced the old listenGuanotes for this:
    def when: predicate received: block {
	    self.when: predicate matches: { |guanote|
		    block(guanote);  
		  };
    };   
    // injects a guanote into the ambient.
    def sendGuanote(aGuanote){
		  self.inject: aGuanote;
    }; 
    // guanote has 3 predefined fields: sender, receiver, message
    def makeGuanote(from, to, msg){
	   //generate ids on ambientTota
	    AmbientTotaModule.extendTuple: AmbientTotaModule.makeTuple()  with: {
		    def sender := from;  // fill in by at interface with gui
		    def receiver := to;  // an object which contains flock
		    def message := msg;
	      // currently inheriting the default, i.e. a tuple that hops forever.
		    def decideStore(guanotesReceiverTS){ true };//receiver.shouldReceive(self,guanotesReceiverTS.owner.getUsername) };
        def decidePropagation(guanotesSenderTS) { 
	        def bol := receiver.shouldReceive( guanotesSenderTS );	
	        system.println("Guanotes: propagating " + bol + " guanote from " + sender + " to " +guanotesSenderTS.getReceiverFlockrId() + " msg " +msg + "tupleID " +self.getTupleId);
	        bol;
	      };
	      def getReceiverList(){ receiver.getReceiverList()}; 
	      def getSenderName(){sender};
	    };
    };
    //temporal function for Gui purposes
		//change it to do this directly from java
    def makeGuanoteFromNames(to, from, msg) {
			sendGuanote( makeGuanote(from, makeReceiver(to), msg));			
    };

		// helper function to extend guanotes without having to worry about the isolate type tag.
		def extendGuanote: tuple  with: closure {
			extend: guanote with: closure taggedAs: [/.at.types.Isolate];
		};
		
		def makeReceiver(flockrIds){
    	def receiver := isolate: { |flockrIds|
				def flockrNames := [];
				def flocks := [];
				def shouldReceive(guanotesTS) {
					if: !(flockrNames.contains(guanotesTS.getReceiverFlockrId)) then: {
						flocks.inject: false into: { |result, flock|
							  result.or: { guanotesTS.currentFlock(flock).contains(guanotesTS.getReceiverFlockrId) }
						}
					}else: { 
						true;
					}
				};
				def getReceiverList(){ flockrIds };
			};			
			flockrIds.each: {|id| 
					if: id ~= ".*Flock" then: { 
						receiver.flocks :=  receiver.flocks + [id] 
					}
			 		else: { receiver.flockrNames :=  receiver.flockrNames + [id] }  
			};
			receiver;
		};
		
		// places a listener for guanotes where the flockr owner is the receiver.
		def listenForGuanotesToOwner(listener) {
			//Think about this ! the true determines which guanotes have to be displayed.
			when: { |guanote| true} received: { |guanote|
			 listener<-guanoteReceived(guanote);
			};
		};	
		// methods for application interface
		// makes guanotes to goOnline. 
		// Behaviour not written in the start method for unit testing purposes.
		def goOnline(){
			//exporting guanotes as application
		  self.export(Guanotes);
		  //discovery other guanotes
		  subscription := self.registerApplicationListener( Guanotes, object:{
			  def notifyApplicationJoined(flockr, profile, remoteGuanotesTs){
				  connectedFlockrs.put(remoteGuanotesTs ,profile.username);
				  localInterface.notifyTSDiscovered(remoteGuanotesTs);
			  };
			  def notifyApplicationLeft(flockr, profile, remoteGuanotesTs){
					system.println("Guanotes: " + localInterface.owner.getUsername +  " detected disconnection of " + profile.username);
				  connectedFlockrs.remove(remoteGuanotesTs);
			  };
		  });
		};
		def start() {
			super^start();
			//setup the gui
			jlobby.at.urbiflock.ui.guanotes.GuanoteList.new(self);
		  self.goOnline();
		};
		def stop(){
			super^stop();
			if: (subscription != nil) then: {subscription.cancel()};
		};			
  }; // end-localInterface
	// remote interface of guanotes
	def remoteInterface := extend: localInterface.remoteApplicationInterface with: {	
		def getFlockrId(){
			aFlockr.getUsername;
		};	
		// method required since remoteInterface doesn't encapsulate guanotesTS anymore.
		def receiveTuples(tuples)	{
			localInterface.receiveTuples(tuples);
		};	
	};
	// add application to a flockr.
	aFlockr.addApplication(localInterface);
	// assigning the remote interface.
	localInterface.remoteApplicationInterface := remoteInterface;
	//return value
	localInterface;
}; // end-makeGuanotes

// the module object of this file
def GuanotesModule := object: {
	// public stuff goes here
	  def makeGuanotes := &makeGuanotes;
		
		def GuanotesTest := extend: /.at.unit.test.UnitTest.new("GuanotesTest", false) with: {
			//tests
			def waitTime := 2;
			import /.at.support.timer;
			import /.at.lang.futures exclude seconds, minutes, millisec;
		  enableFutures(false);
		
			def flockr1;
			def myGuanotes;
			def test := self;
			def notDown := true;
			
			def setUp() {
				// one flockr1 with 2 friends: flockr2 and flockr3.
				def profile1 := /.at.urbiflock.profile.makeProfile();
				profile1.username := "flockr1";
			  flockr1 := /.at.urbiflock.flockr.makeFlockr(profile1);
				def profile2 := /.at.urbiflock.profile.makeProfile();
				profile2.username := "flockr2";
		  	flockr1.addBuddy(profile2);
				def profile3 := /.at.urbiflock.profile.makeProfile();
				profile3.username := "flockr3";
		  	flockr1.addBuddy(profile3);
		    //setting up guanotes of flockr1
		    myGuanotes := makeGuanotes(flockr1);
		    myGuanotes.goOnline();
			};
			
			def tearDown() {
				if: notDown then: {
					flockr1.goOffline();
				  myGuanotes.stop();
				};
			};
			// to be able to change tearDown without crashing tests.
			def flockr1GoOffline(){		
				if: notDown then: {
					flockr1.goOffline();
				  myGuanotes.stop();
				  notDown := false;
				};
			};
					
			def testAsyncGuanoteToFlockr(){
				def [fut,res] := makeFuture();
				// sending a guanote to a flockr.	
				def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, myGuanotes.makeReceiverFlockr("flockr2"), "HelloWorld");
				myGuanotes.sendGuanote(aGuanote);
		    // actor containing flockr2
				def a := actor: { |res,test|	
					def profile2 := /.at.urbiflock.profile.makeProfile();
					profile2.username := "flockr2";
				  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
			 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
			    myGuanotes.goOnline();
				  // this should be composed via gui interface for every flock where a flockr is registered.
					myGuanotes.listenForGuanotesToOwner( object:{
					  def guanoteReceived(guanote) {
						  test<-assertEquals("flockr1", guanote.sender);
						  flockr2.goOffline();
						  myGuanotes.stop();
						  res<-resolve(`ok);
						}
					});
			  };
				fut;
			}; 
			
			def testAsyncGuanoteToFlock(){
				def [fut,res] := makeFuture();
				// sending a guanote to a flatten flock, i.e. a list of flockrs.
				// waiting some time to be sure that flockr2,flockr3 belong to the flockr1 "FriendsFlock".			
				when: seconds(waitTime) elapsed: {
				  def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, myGuanotes.makeReceiverFlock("FriendsFlock"), "HelloWorld");
				  myGuanotes.sendGuanote(aGuanote);
			  };
				// actor containing flockr2, which belongs to flockr1 "FriendsFlock"
				def a := actor: { |res, test|	
					def profile2 := /.at.urbiflock.profile.makeProfile();
					profile2.username := "flockr2";
				  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
			 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
			    myGuanotes.goOnline();
       	  myGuanotes.listenForGuanotesToOwner( object:{
					  def guanoteReceived(guanote) {
					    test<-assertEquals("flockr1", guanote.sender);
						  flockr2.goOffline();
						  myGuanotes.stop();
						  res<-resolve(`ok);
						}
					});
			  };
				fut;
			};	// end-testAsyncGuanoteToFlock
				
			def testAsyncGuanoteToFlockIndirectReception(){
					def [fut,res] := makeFuture();
					def [futTest,resTest] := makeFuture();
          // waiting some time to be sure that flockr2,flockr3 belong to the flockr1 "FriendsFlock".			
					when: seconds(waitTime) elapsed: {
						def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, myGuanotes.makeReceiverFlock("FriendsFlock"), "HelloWorld");
					  myGuanotes.sendGuanote(aGuanote);
				  };
				  // testing guanotes get received even if sender and receiver aren't connected at the same time.
		      // scenario: flockr3 should receive aGuanote by means of flockr2 because we will shut down flockr1.
		      def aFlockr3 := actor: { |res, test|	
						def profile3 := /.at.urbiflock.profile.makeProfile();
						profile3.username := "flockr3";
					  def flockr3 := /.at.urbiflock.flockr.makeFlockr(profile3);
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr3);
				    def goOnline() { myGuanotes.goOnline()};
						myGuanotes.listenForGuanotesToOwner( object:{
						  def guanoteReceived(guanote) {
							  test<-assertEquals("flockr1", guanote.sender);
							  flockr3.goOffline();
							  myGuanotes.stop();
							  res<-resolve(`ok);
							}
						});
				  };
				  // flockr2 will get the note from flockr 1, shut it down, and then provoke the discovery of 
				  // flockr3 and pass him the note of flockr1.
					def aFlockr2 := actor: { |test, aFlockr3, waitTime|	
						import /.at.support.timer;
						def profile2 := /.at.urbiflock.profile.makeProfile();
						profile2.username := "flockr2";
					  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
				    myGuanotes.goOnline();
				    def goOffline() {
							flockr2.goOffline();
							myGuanotes.stop();
				    };
						myGuanotes.listenForGuanotesToOwner( object:{
						  def guanoteReceived(guanote) {
							  test<-assertEquals("flockr1", guanote.sender);
							  // shutting down flockr1 
							  test<-flockr1GoOffline();
							  // set up flockr 3 after sometime has passed so that the disconnected events gets propagated.
							  when: seconds(waitTime) elapsed: { aFlockr3<-goOnline()};
							};
						});
				  };
				  // fut is resolved when flockr3 receives the guanote from flockr1.
				  when: fut becomes: { |ack|
					  when: aFlockr2<-goOffline()@FutureMessage becomes: { |ack|
						  resTest.resolve(`ok);
					  };
					};
					futTest;
				}; // end-testAsyncGuanoteToFlockIndirectReception
				
				def testAsyncGuanoteToFlockNoReception(){
					def [fut,res] := makeFuture();
					// flockr2 sends also a "Dag wereld" guanote to its friends when it gets the one of flockr1
					def aFlockr2 := actor: { |res, test|	
						def profile2 := /.at.urbiflock.profile.makeProfile();
						profile2.username := "flockr2";
					  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
						def profile4 := /.at.urbiflock.profile.makeProfile();
						profile4.username := "flockr4";
						flockr2.addBuddy(profile4); // assuming that the guanote of flockr1 arrives after the addBuddy has been proccessed.
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
				    myGuanotes.goOnline();
	       	  myGuanotes.listenForGuanotesToOwner( object:{
						  def guanoteReceived(guanote) {
							  test<-assertEquals("flockr1", guanote.sender);
						    def aGuanote := myGuanotes.makeGuanote(flockr2.getUsername, myGuanotes.makeReceiverFlock("FriendsFlock"), "DagWereld");
							  myGuanotes.sendGuanote(aGuanote);
							  flockr2.goOffline();
							  myGuanotes.stop();
							};
						});
				  };
					// actor containing flockr4, which doesn't belong to flockr1 "FriendsFlock" 
					// but it will receive a guanote from flockr2 which is one of its friends.
				  def aFlockr4 := actor: { |res, test, waitTime|	
					  import /.at.support.timer;
					  def profile4 := /.at.urbiflock.profile.makeProfile();
						profile4.username := "flockr4";
					  def flockr4 := /.at.urbiflock.flockr.makeFlockr(profile4);
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr4);
				    myGuanotes.goOnline();
						myGuanotes.listenForGuanotesToOwner( object:{
						  def guanoteReceived(guanote) {
								test<-assertEquals("flockr2", guanote.sender);
							  test<-assertEquals("DagWereld", guanote.message);
							  // leave sometime to be sure flockr2 and its guanotes disconnected.
							  when: seconds(waitTime) elapsed: { 
								  test<-assertEquals(1, myGuanotes.getConnectedFlockrs.length);
							    test<-assertTrue(myGuanotes.getConnectedFlockrs.contains("flockr1"));
							    flockr4.goOffline();
							    myGuanotes.stop();
							    res<-resolve(`ok);
							  };
			  			};
						});
					};
					// waiting some time to be sure that flockr2,flockr4 belong to the flockr1 "FriendsFlock".			
					when: seconds(waitTime*2) elapsed: {
						test.assertTrue(myGuanotes.getConnectedFlockrs.contains("flockr4"));
					  def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, myGuanotes.makeReceiverFlock("FriendsFlock"), "HelloWorld");
					  myGuanotes.sendGuanote(aGuanote);
				  };
			    fut;
				};	// end-testAsyncGuanoteToFlockNoReception
			
			def testAsyncGuanoteToFlockIndirectReception2(){
				def [fut,res] := makeFuture();
				def [futT, resT] := makeFuture();
				//flockr1 sends a guanote to its friends, flockr2, flockr3 and flockr 4.
	      //flockr4 is a friend of flockr1 but it is not connected when flockr1 is.
	      //flockr2 gets the note via flockr2.
				def aFlockr4 := actor: { |res, test, waitTime|	
					  import /.at.support.timer;
						import /.at.lang.futures exclude seconds, minutes, millisec;
					  def profile4 := /.at.urbiflock.profile.makeProfile();
						profile4.username := "flockr4";
					  def flockr4 := /.at.urbiflock.flockr.makeFlockr(profile4);
				 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr4);
				    def goOnline() {myGuanotes.goOnline()};
						myGuanotes.listenForGuanotesToOwner( object:{
						  def guanoteReceived(guanote) {
								test<-assertEquals("flockr1", guanote.sender);
							  test<-assertEquals("DagWereld", guanote.message);
							  // leave sometime to be sure flockr2 and its guanotes disconnected.
							  when: seconds(waitTime) elapsed: { 
								  test<-assertEquals(1, myGuanotes.getConnectedFlockrs.length);
							    test<-assertFalse(myGuanotes.getConnectedFlockrs.contains("flockr1"));
					 		    flockr4.goOffline();
							    myGuanotes.stop();
							    res<-resolve(`ok);
							  };
			  			};
						});
					};
				// flockr2 makes flockr1 goOffline and flockr4 goOnline after getting the guanote from flockr1.
				// thus the guanote should be transmitted to flockr4.
				def aFlockr2 := actor: { |res, test, aFlockr4|
					import /.at.lang.futures;	
					def profile2 := /.at.urbiflock.profile.makeProfile();
					profile2.username := "flockr2";
				  def flockr2 := /.at.urbiflock.flockr.makeFlockr(profile2);
					def profile4 := /.at.urbiflock.profile.makeProfile();
					profile4.username := "flockr4";
					flockr2.addBuddy(profile4); // assuming that the guanote of flockr1 arrives after the addBuddy has been proccessed.
			 	  def myGuanotes := /.at.urbiflock.guanotes.makeGuanotes(flockr2);
			    myGuanotes.goOnline();
       	  myGuanotes.listenForGuanotesToOwner( object:{
					  def guanoteReceived(guanote) {
						  when: test<-tearDown()@FutureMessage becomes:{ |ack|
							  test<-assertEquals("flockr1", guanote.sender);
							  test<-assertEquals("DagWereld", guanote.message);  
						    when: aFlockr4<-goOnline()@FutureMessage becomes: { |ack|
						      test<-assertFalse(myGuanotes.getConnectedFlockrs.contains("flockr1"));
						    };
						  };
						};
					});
					def goOffline(){
						flockr2.goOffline();
				    myGuanotes.stop();
				  };
			  };
        //adding flockr4 as friend of flockr1.
				def profile4 := /.at.urbiflock.profile.makeProfile();
				profile4.username := "flockr4";
		  	flockr1.addBuddy(profile4);
				// waiting some time to be sure that flockr2,flockr3, flockr4 belong to the flockr1 "FriendsFlock".			
				when: seconds(waitTime*2) elapsed: {
				  def aGuanote := myGuanotes.makeGuanote(flockr1.getUsername, myGuanotes.makeReceiverFlock("FriendsFlock"), "DagWereld");
				  myGuanotes.sendGuanote(aGuanote);
			  };
			  when: fut becomes: { |ack|
				  when: aFlockr2<-goOffline()@FutureMessage becomes: { |ack| 
					 resT.resolve(`ok);
			    };
			  };
		    futT;
			};	// end-testAsyncGuanoteToFlockIndirectReception2 
		}; // endGuanotesTest

} // endGuanotesModule
