/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The meta-level implementation of the leased references language construct.
 *
 * @author egonzale
 */

def TimerModule := /.at.support.timer;
import TimerModule;
 
def maxMethod := jlobby.java.lang.Math.&max;
def Vector := /.at.collections.vector.Vector;

// TODO: Note that these definitions should have the same value as in the server leased references. 
// Either they are passed at mirror creation time or they are factored out to a config file.
// Actually renewalcall may be ommitted (if the default is the leasetime and 
// clients can not ask for a renewal without a timeout.
def RENEWALONCALL := millisec(10); // default call time renewal 
def LEASETIME := millisec(15); // default lease time
	
def createClientLeasingMirror(remoteLease, timeout) { mirror: {	

		def expired := false;
		def timerSubscription := nil;
		def expiredObservers := Vector.new();

		def init(base){
		  	super^init(base);
			expired := false;
			expiredObservers := Vector.new();			  	
			timerSubscription := when: timeout elapsed: {
				retractMessages();
				expired := true;
				notifyExpiredObservers();
		  	};
		    //add an observer to the remoteLease to be able to detect
		    //when a remote lease expires before the client one. 
			when: remoteLease takenOffline: {
				revoke();
				notifyExpiredObservers();
			}
	    };

		 def retractMessages(){
				def messages := retract: remoteLease;
				//messages.each: { |msg| system.println(msg)};
		 };
		
		def revoke(){ 
			//if client wanna revoke the lease, this should be transmitted to server lease.
			timerSubscription.cancel();
			expired := true;
			retractMessages();
		};

		def renew(renewalTime := RENEWALONCALL) {
			//TODO: if client wanna explicitly renew the lease, the request should be forward to the server lease.
			//if ack hasn't come back in x minutes, renewal failed. 
			def interval := maxMethod(timerSubscription.getTimeRemaining(), renewalTime);
			timerSubscription.cancel();
			timerSubscription := when: interval elapsed: {
				retractMessages();
				expired := true;
				self.notifyExpiredObservers();
			};
		};

		def getTimeLeft() { timerSubscription.getTimeRemaining() };

		def addExpiredObserver(obs){
			expiredObservers.add(obs);
			//return a subscription object that can be used to remove the observer
			object: {
				def cancel() { expiredObservers.remove(obs) }
			};
		};

		def notifyExpiredObservers(){ expiredObservers.each: { |o| o<-apply([]) }};

		def receive(msg) {
		
			//all mesages received are forwarded to server lease. 
			//the base object of a leased ref is an empty object => it does not understand any async msg.
			if: !(expired) then: { 
				// clearing the receiver otherwise the client lease will be passed.
				msg.receiver := nil;
				remoteLease<-receive(msg);
			};
		};
		
		def invokeField(rcv, sel) { self.invoke(rcv, sel, []) };
		
		def invoke(rcv, sel, arg) {
			//the only legal operation on client leased references is '==' 
			if: (`(==) == sel) then: {
				super^invoke(rcv,sel,arg);
			} else: {
				raise: /.at.exceptions.XIllegalOperation.new("cannot synchronously invoke operation " +sel+ " on client leased reference "+ self.base);
			}
		};
		
		def print() {
			if: (expired) then: {
				"<expired client lease " + super^print()  + " on:" +remoteLease+ " >";
			} else: {
				"<client lease " + super^print() + " on: " +remoteLease+ ">";
			}
		}
}}; 

def createClientLeasingWithRenewalMirror(remoteLease, timeout, renewal) { extend: createClientLeasingMirror( remoteLease, timeout) with: {

	def receive(msg) {
		//all mesages received are forwarded to server lease. 
		//the base object of a leased ref is an empty object => it does not understand any async msg.
		if: !(self.expired) then: { 
			//ATENCIO: this renewal should not be transmitted to the server lease! 
			//Just renews the client lease to keep it in sync with the server lease.
			super^renew(renewal);
			// clearing the receiver otherwise the client lease will be passed.
			msg.receiver := nil;
			remoteLease<-receive(msg);
		};
	};
}};

def createLeasingWithSingleUseMirror(remoteLease, timeout, forSelectors) { extend: createClientLeasingMirror( remoteLease, timeout) with: {

	def receive(msg) {
		//all mesages received are forwarded to server lease. 
		//the base object of a leased ref is an empty object => it does not understand any async msg.
		if: !(self.expired) then: { 
			if: ( forSelectors.isEmpty().or: {forSelectors.contains(msg.selector)}) then: {
				super^revoke();
	  		} else: {
				//ATENCIO: this renewal should not be transmitted to the server lease! 
				//Just renews the client lease to keep it in sync with the server lease.
		 		super^renew();
			};
			// clearing the receiver otherwise the client lease will be passed.
			msg.receiver := nil;
			remoteLease<-receive(msg);
		};
	};
}};


self;