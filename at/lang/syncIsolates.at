deftype SyncIsolate;
def HashMap := jlobby.java.util.HashMap;


def makeSyncIsolateMirror() {
	mirror: { 
		def notifiers := [];
	
		def pass() {
			copyIsolateWithMirror(self.base, makeFrozenIsolateMirror());
		};
	
		def addChangeListener(notifier) {
			// Register change listener to the isolate
			notifiers := notifiers + [ notifier ];
		};
	
		def removeChangeListener(notifier) {
			notifiers := notifiers.filter: { |el|
				el != notifier;
			};
		};
		
		def defineField(name, value) {
			def theBase := self.base;
			def makeNotifyingField(nam, val) {
			   object: {
			     def new(newHost) { self }; // singleton pattern
			     def name := nam;
			     def readField() { val };
			     def writeField(newVal) { 
					val := newVal; 
					notifiers.each: { |notifier| notifier.notifyChanged(theBase) };
					val;
				};
				 def accessor() { readField };
				 def mutator() { writeField }
			   } taggedAs: [ /.at.types.Field ];
			 };
			 self.addField(makeNotifyingField(name, value));
			nil;
		};
	};
};


def makeFrozenIsolateMirror() {	
	extend: defaultMirror with: {
		deftype IllegalOperation;
		def XIllegalOperation := lobby.at.exceptions.createException(IllegalOperation);
		
		def addSlot(slot) { 
			raise: XIllegalOperation.new("Cannot add slots to a sealed object."); 
		};
		def removeSlot(selector){
			raise: XIllegalOperation.new("Cannot remove slots from a sealed object."); 
		};
		def defineField(name, value) {
			def theBase := self.base;
			def makeFrozenField(nam, val) {
			   object: {
			     def new(newHost) { self }; // singleton pattern
			     def name := nam;
			     def readField() { val };
			     def writeField(newVal) { 
					raise: XIllegalOperation.new("Cannot change slots of a sealed object.");
				 };
				 def accessor() { readField };
				 def mutator() { writeField }
			   } taggedAs: [ /.at.types.Field, /.at.types.Isolate ];
			 };
			 self.addField(makeFrozenField(name, value));
			nil;
		};
	} taggedAs: [ /.at.types.Isolate ];
};

def copyIsolateWithMirror(iso, mirror) {
	def result := object: {} taggedAs: [ /.at.types.Isolate ] mirroredBy: mirror;
	def fields := (reflect: iso).listFields();
	fields.each: { |field| 
	   if: !(field.name ==`super) then: {
	   	(reflect: result).defineField(field.name, field.readField); 
	   };
	};
	def methods := (reflect: iso).listMethods();
	methods.each: { |method|
		(reflect: result).addMethod(method);
	};
	result;
};



// Receiver

def typesAndObservers := HashMap.new();
def subscribersAndNotifiers := HashMap.new();

whenever: SyncIsolate discovered: { |syncIso|
	def handlers := typesAndObservers.get(syncIso.getType());
	if: (nil != handlers) then: {
		handlers.each: { |subscriber|
			subscriber.notifyDiscovered(syncIso.getIsolate());
			syncIso.getNotifier()<-addSubscriber(subscriber);
			subscribersAndNotifiers.put(subscriber, syncIso.getNotifier());
		};
	};
	when: syncIso.getNotifier() disconnected: {
		def handlers := typesAndObservers.get(syncIso.getType());
		handlers.each: { |subscriber|
			subscriber.notifyDisconnected(syncIso.getIsolate());
		};
	};
	when: syncIso.getNotifier() reconnected: {
		def handlers := typesAndObservers.get(syncIso.getType());
		handlers.each: { |subscriber|
			subscriber.notifyReconnected(syncIso.getIsolate());
		};
	};
};


def SyncIsolateModule := object: {
	def SyncIsolate := SyncIsolate;
	
	def syncIsolate: isoCode {
		object: isoCode taggedAs: [ /.at.types.Isolate ] mirroredBy: makeSyncIsolateMirror();
	};

	def publish: iso as: type {
		def notifier := object: {
			def subscribers := [];

			def cancel(subscriber) {
				subscribers := subscribers.filter: { |el|
					el != subscriber;
				};
				nil;
			};

			def notifyChanged(newIso) {
				subscribers.each: { |sub| sub<-notifyChanged(newIso) };
			};

			def addSubscriber(subscriber) {
				subscribers := subscribers + [ subscriber ];
				nil;
			};
		};
		def wrappedIsolate := isolate: { |iso, notifier, type| 
			def getIsolate() { iso };
			def getNotifier() { notifier };
			def getType() { type }
		};
		(reflect: iso).addChangeListener(notifier);
		def subs := export: wrappedIsolate as: SyncIsolate;
		object: {
			def cancel() {
				subs.cancel();
				notifier.subscribers := [];
				(reflect: iso).removeChangeListener(notifier);
			};
		};
	};
	
	// Subscriber should understand:
	// - notifyDiscovered(obj)
	// - notifyDisconnected(obj)
	// - notifyReconnected(obj)
	// - notifyChanged(obj)
	def subscribe: subscriber to: type {
		def oldSubscribers := typesAndObservers.get(type);
		if: (nil == oldSubscribers) then: {
			typesAndObservers.put(type, [ subscriber ]);
		} else: {
			typesAndObservers.put(type, oldSubscribers + [ subscriber ]);
		};
		object: {
			def cancel() {
				def subscribers := typesAndObservers.get(type).filter: { |el|
					el != subscriber
				};
				typesAndObservers.put(type, subscribers);
				subscribersAndNotifiers.remove(subscriber);
				subscribersAndNotifiers.get(subscriber)<-cancel(subscriber)@/.at.lang.futures.FutureMessage;
			}; 
		};
	};
	
	// Tests
	def SyncIsolateTest() {
	    extend: /.at.unit.test.UnitTest.new("synchronized isolates test", false) with: {
		
			def publishingActor;

			def setUp() {
			  publishingActor := actor: {
				import /.at.lang.syncIsolates;
				def iso1 := syncIsolate: { 
					def field := "iso1";
					def setField(x) {
						field := x;
					}; 
				};
				def iso2 := syncIsolate: { 
					def field := "iso2";
					def setField(x) {
						field := x;
					};
				};
				def iso3 := syncIsolate: { 
					def field := "iso3";
					def setField(x) {
						field := x;
					};
				 };
				
				def changeIso1() {
					iso1.field := "changed iso1";
				};
				def changeIso2() {
					iso2.field := "changed iso2";
				};
				def changeIso3() {
					iso3.field := "changed iso3";
				};
				
				def invokeChangeIso1() {
					iso1.setField("invoked iso1");
				};
				def invokeChangeIso2() {
					iso2.setField("invoked iso2");
				};
				def invokeChangeIso3() {
					iso3.setField("invoked iso3");
				};
				
				deftype testType1;
				deftype testType2;
				
				def publishIso1() {
					publish: iso1 as: testType1;
				};
				def publishIso2() {
					publish: iso2 as: testType1;
				};
				def publishIso3() {
					publish: iso3 as: testType2;
				};
			  };
			};

			def testSyncIsolate() {
				def changed := false;
				def syncIso := syncIsolate: {
					def foo := 1;
				};
				def theTestModule := self;
				def listener := object: {
					def notifyChanged(newIso) {
						changed := true;
						theTestModule.assertEquals(5, newIso.foo);
					};
				};
				(reflect: syncIso).addChangeListener(listener);	
				syncIso.foo := 5;
				self.assertTrue(changed);
				self.assertEquals(5, syncIso.foo);	
			};
			
			def testSyncIsolate2() {
				def changed := false;
				def syncIso := syncIsolate: {
					def foo := 1;
					def bar() {
						foo := 5;
					};
				};
				def theTestModule := self;
				def listener := object: {
					def notifyChanged(newIso) {
						changed := true;
						theTestModule.assertEquals(5, newIso.foo);
					};
				};
				(reflect: syncIso).addChangeListener(listener);	
				syncIso.bar();
				self.assertTrue(changed);
				self.assertEquals(5, syncIso.foo);	
			};
			
			def testAsyncNotifications() {
				def notifyDiscovered := nil;
				def notifyDisconnected := nil;
				def notifyReconnected := nil;
				def notifyChanged := nil;
				
				def subscriber := object: {
					def notifyDiscovered(iso) {
						notifyDiscovered := iso;
					};
					def notifyDisconnected(iso) {
						notifyDiscovered := iso;
					};
					def notifyReconnected(iso) {
						notifyReconnected := iso;
					};
					def notifyChanged(iso) {
						notifyChanged := iso;
					};
				};
				
				deftype testType1;
				deftype testType2;
				subscribe: subscriber to: testType1;
				
				def timer := /.at.support.timer;
				
				publishingActor<-publishIso1();
				timer.when: timer.seconds(5) elapsedWithFuture: {
					self.assertEquals(notifyDiscovered.field, "iso1");
					
					publishingActor<-publishIso2();
					timer.when: timer.seconds(5) elapsedWithFuture: {
						self.assertEquals(notifyDiscovered.field, "iso2");
						
						publishingActor<-publishIso3();
						timer.when: timer.seconds(5) elapsedWithFuture: {
							self.assertEquals(notifyDiscovered.field, "iso2"); // not discovered, different type tag
							
							publishingActor<-changeIso1();
							timer.when: timer.seconds(5) elapsedWithFuture: {
								self.assertEquals(notifyChanged.field, "changed iso1");
								
								publishingActor<-changeIso2();
								timer.when: timer.seconds(5) elapsedWithFuture: {
									self.assertEquals(notifyChanged.field, "changed iso2");
									
									publishingActor<-changeIso3();
									timer.when: timer.seconds(5) elapsedWithFuture: {
										self.assertEquals(notifyChanged.field, "changed iso2"); // not notified
									};
								};
							};
						};
					};
				};
			};
		
		};
	};
};

