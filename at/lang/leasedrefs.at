/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The meta-level implementation of the leased references language construct.
 *  
 * TODO: synchronization of client and server leased ref without relying on when:takenOffline.
 *
 * @author egonzale
 */
def TimerModule := /.at.support.timer;

import /.at.lang.leasedrefstrait;

def createLeasingMirror(objPrincipal, timeout := LEASETIME) { mirror: {
	
	import TLeasedRef;
	
	def init(base) {
		super^init(base);
		TLeasedRef^init(objPrincipal, timeout);
	};
	
	// implement TEventualRef's required interface
	
	def intercept(msg) {
		//all base messages received are forwarded to principal 
		//the base object of a leased ref is an empty object =>
		//it does not understand any async msg.
		if: !(expired) then: {
			delegate <+ msg
		}
	};
	
	def toString() {
		if: (expired) then: {
			"expired lease: " + super^print() + " on: " + delegate;
		} else: {
			"lease: " + super^print() + " on: " + delegate;
		};
	};

  def leaseTransportStrategy(remoteLease, timeout) {
	  { |remoteLease, timeout|
		  /.at.lang.leasedrefs.makeClientLease(remoteLease, timeout);
	  }
  };

}};	

def createLeasingWithRenewalMirror(principal, timeout := LEASETIME, renewal := timeout) {  extend: createLeasingMirror( principal, timeout) with: {

	def intercept(msg) {
		//automatically renew the lease upon mesage reception. 
		//By default, renewal time = leasetime. 
		super^renew(renewal);
		super^intercept(msg);
	};

  def leaseTransportStrategy(remoteLease, timeout) {
	  { |remoteLease, timeout, renewal|
	    /.at.lang.leasedrefs.makeClientLeaseWithRenewal(remoteLease, timeout, renewal);
	  }
  };
		
}};

def createLeasingWithSingleUseMirror(principal, timeout := LEASETIME, forSelectors := []) {  extend: createLeasingMirror(principal, timeout) with: {

	def intercept(msg){
		def res := super^intercept(msg);
		if: !(self.expired) then: {		
		  	if: ( forSelectors.isEmpty().or: {forSelectors.contains(msg.selector)}) then: {
				  super^revoke();
		  	}
		}; 
		res;
	};

  def leaseTransportStrategy(remoteLease, timeout) {
	  { |remoteLease, timeout, forSelectors|
		  /.at.lang.leasedrefs.makeClientLeaseWithSingleUse(remoteLease,timeout, forSelectors);
	  }
  };

}};

//CLIENT LEASES MIRRORS

def createClientLeasingMirror(remoteLease, timeout) {
	mirror: {	

		import TLeasedRef exclude pass;

		def init(base) {
			super^init(base);
			TLeasedRef^init(remoteLease, timeout);
		};

    // implement TEventualRef's required interface
		def pass(){
			//leased object are always passed on a <SL,CL> basis. 
			//Client leases cannot be passed, they must be adquired at the server side.
			 raise: XIllegalOperation.new("Cannot pass client lease " + self.toString);
		};
		
		def intercept(msg) {
			//all mesages received are forwarded to server lease. 
			//the base object of a leased ref is an empty object => it does not understand any async msg.
			if: !(expired) then: { 
				delegate<-intercept(msg);
			};
		};
		
		def toString() {
			if: (expired) then: {
				"expired client lease " + super^print()  + " on:" + delegate;
			} else: {
				"client lease " + super^print() + " on: " + delegate;
			}
		}
  };
};

def createClientLeasingWithRenewalMirror(remoteLease, timeout, renewal) { extend: createClientLeasingMirror( remoteLease, timeout) with: {

	def intercept(msg) {
		//all mesages received are forwarded to server lease. 
		//the base object of a leased ref is an empty object => it does not understand any async msg.
		if: !(self.expired) then: { 
			//ATENCIO: this renewal should not be transmitted to the server lease! 
			//Just renews the client lease to keep it in sync with the server lease.
			super^renew(renewal);
			self.delegate<-intercept(msg);
		};
	};
}};

def createClientLeasingWithSingleUseMirror(remoteLease, timeout, forSelectors) { extend: createClientLeasingMirror( remoteLease, timeout) with: {

	def intercept(msg) {
		//all mesages received are forwarded to server lease. 
		//the base object of a leased ref is an empty object => it does not understand any async msg.
		if: !(self.expired) then: { 
			if: ( forSelectors.isEmpty().or: {forSelectors.contains(msg.selector)}) then: {
				super^revoke();
	  	} else: {
				//ATENCIO: this renewal should not be transmitted to the server lease! 
				//Just renews the client lease to keep it in sync with the server lease.
		 		super^renew();
			};
		  self.delegate<-intercept(msg);
		};
	};
}};

//Public interface of leased object references
def LeasingModule := object: {
	
	def LeasedRef := LeasedRef;
	//Can I make it not public to everyone??
	def makeClientLease(remoteLease, timeout){
		object: { nil } taggedAs: [ClientLeasedRef] mirroredBy: createClientLeasingMirror(remoteLease, timeout);
	};

	def makeClientLeaseWithSingleUse(remoteLease, timeout, selectors){
		object: { nil } taggedAs: [ClientLeasedRef] mirroredBy: createClientLeasingWithSingleUseMirror(remoteLease, timeout, selectors);
	};
	
	def makeClientLeaseWithRenewal(remoteLease, timeout, renewal){
		object: { nil } taggedAs: [ClientLeasedRef] mirroredBy: createClientLeasingWithRenewalMirror(remoteLease, timeout, renewal);
	};
	
	//Construct a lease that lasts for a given period of time.
	def lease: timeout for: obj  {
		object: { nil } taggedAs: [LeasedRef] mirroredBy: createLeasingMirror(obj, timeout)
	};
	
	/* Construct a lease for only a single call: a lease that is alive for the given period unless
	it has processed a single message. This is a useful lease for callback objects, such as futures.
	*/
	def singleCallLease: timeout for: obj {
		object: { nil } taggedAs: [LeasedRef] mirroredBy: createLeasingWithSingleUseMirror(obj, timeout)
	};
		 
	// selectors is expected to be an array of message names (which upon reception expire the lease). 
	// An empty array has the same effect than singleCallLease construct.
	def singleCallLease: timeout revokedOn: selectors for: obj {
		object: { nil } taggedAs: [LeasedRef] mirroredBy: createLeasingWithSingleUseMirror(obj, timeout, selectors)
	};
	
	/* Lease that is prolonged with a given initial period of time each time a message is sent to the object. 
	  Hence, when an object has not been 'used' for more than the given period, its access expires. 
	  The lease can always be explicitely revoked earlier.
    */
	def renewOnCallLease: timeout for: obj {
	    object: { nil } taggedAs: [LeasedRef] mirroredBy: createLeasingWithRenewalMirror(obj, timeout)
	};
	
	// Customizable version of renewedOnCallLease where one can determine the renewal time instead of using timeout. 
	def renewOnCallLease: timeout renewedWith: renewalTime for: obj {
	    object: { nil } taggedAs: [LeasedRef] mirroredBy: createLeasingWithRenewalMirror(obj, timeout, renewalTime)
	};
			 
	// Tries to renew explicitly the lease.		
	def renew: leasedRef for: time {
	  	(reflect: leasedRef).renew(time)	
	};
	
	/* Cancels explicitly the lease without triggering when:expired: listener 
	   Canceling a lease is analogous to a natural expiration of the lease.
	   Any later message sent to the lease won't be forwarded to the server object.
	*/
	def revoke: leasedRef {
	  	(reflect: leasedRef).revoke()	
	};
	
	// Places an observer with the given code to a leased reference. 
	// The block of code is executed upon the expiration of the lease. 	
	def when: leasedRef expired: code {
		//Note that when:expired: on lease references places an observer on the server side while
		//when:expired: of remote far references on the client side.
		
		// Note: after refactoring the MOP, even leased refs are always regarded as FarReferences, this is why
		// the check for !FarRef is removed
		if: (is: leasedRef taggedAs: LeasedRef) /*.and: { !(is: leasedRef taggedAs: /.at.types.FarReference) }*/ then: {
			(reflect: leasedRef).addExpirationObserver(code) 
		} else: {
			if: (is: leasedRef taggedAs: ClientLeasedRef) then: { 
				(reflect: leasedRef).addExpirationObserver(code) 
			} else: {
			//call the native when:takenOffline: of remote far references. 
			//leased references are subject to leasing as well when passed to client objects.
			//Thus, it should never enter here when working with leased references.
			when: leasedRef takenOffline: code
			}
		}
	};
	
	// Returns a Long with the amount of time left before the lease expires
	def leaseTimeLeft: leasedRef {
		(reflect: leasedRef).getTimeLeft();
	};
	
	// Suport primitives to manipulate time intervals. 
	// Export here also so that people using leasing abstractions
	// do not need to explicitly import timer module.
 	def millisec(ms) { TimerModule^millisec(ms) };
	def seconds(s) { TimerModule^seconds(s) };
	def minutes(m) { TimerModule^minutes(m) };
  
  def LeasedRefsTest() { 
	  extend: /.at.unit.test.UnitTest.new("LeasedRefsTest") with: {
     
			import /.at.lang.futures;
		  enableFutures(false);
			
      def obj := object: {
			  def foo() { 5 }; 
      };

      def testLocalLeaseCreation() {
				//Creation of a lease
	    	def lease := lease: seconds(5) for: obj;
  			def table := (print: lease).split(":");
      	self.assertEquals("<lease", table[1]);
	    	//Creation of a renewOnCallLease
				lease := renewOnCallLease: seconds(5) for: obj;
				when: lease expired: { 
	      	table := (print: lease).split(":");
	        self.assertEquals("<expired lease", table[1])
	    	};
    	};

      def testAsynLocalMessageSend(){
				//Creation of a singleCallLease
	    	def lease := singleCallLease: seconds(5) for: obj;
				def fut := when: lease<-foo()@FutureMessage becomes: { |v|
					self.assertEquals(5,v);
				};
				fut;
			};
  	};
	};
}

