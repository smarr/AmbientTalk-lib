/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * A multifuture is a future that can be resolved multiple times,
 * optionally up to a maximum number. It accepts two additional
 * listeners:
 *
 * whenEach: multiFuture becomes: { |val| ... }
 *  => invoked whenever the future is resolved with a new value
 * whenAll: multiFuture becomes: { |table| ... }
 *  => invoked if all results have been gathered (only possible
 *     if the maximum number of results is known)
 *
 * Usage:
 *  def [multiFut, resolver] := makeMultiFuture(n);
 *
 * @author tvcutsem
 */
import /.at.support.logger;
import /.at.lang.firstclassrefs;

def log := makeLogger("[multifutures.at]", INFO);

def FuturesModule := /.at.lang.futures;

def OneWayMessage := FuturesModule.OneWayMessage;

def Exception := /.at.types.Exception;

// all future objects are marked with this type
deftype MultiFuture <: FuturesModule.Future;

// type that signifies that the multifuture expires after the given timeout
deftype GatherType <: FuturesModule.FutureMessage; 

def Gather(timeout) {
	extend: GatherType with: { |timeout|
		nil;
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};

def makeMultiFuture(maxSize := nil, timeout := nil) {
	
	// multifutures are empty objects mirrored by a multifuture mirror
	def fut := object: { } taggedAs: [ MultiFuture ] mirroredBy: (mirror: {
		
		def resolvedValues := [];
		def ruinedValues := [];

		//def state := UNRESOLVED;
		
		def inbox := [];
		def whenEachSubscribers := [];
		def whenAllSubscribers := [];

		def isFullyResolved() {
			(nil != maxSize).and: { maxSize == (resolvedValues.length + ruinedValues.length) }
		};
		
	  // a multifuture is a special kind of far reference
	  // therefore, this mirror mixes in the 'far reference' behaviour
	  // Because a future is pass-by-reference, we do not inherit the
	  // parameter-passing behaviour of the far ref trait
	  import TFarRef exclude pass;

		def resolve(value) {
			if: !isFullyResolved() then: {
				// is the future resolved by another future?
				if: (is: value taggedAs: FuturesModule.Future) then: {
					// register this future as a listener with the resolved future value
					value<-addResolutionListener(object: {
						def notifyResolved(val) {
							// re-resolve this future with the actual value
							resolve(val);
						};
						def notifyRuined(exc) {
							// ruin this future
							ruin(exc);
						}
				  // note that <-addResolutionListener is a message directed to the future's mirror
				  // and that no future return value is required
					})@[MetaMessage, OneWayMessage];
				} else: {
					resolvedValues := resolvedValues + [value];
					inbox.each: { |msg| value <+ msg };

					whenEachSubscribers.each: { |sub| sub<-notifyResolved(value)@OneWayMessage };
					if: isFullyResolved() then: {
						whenAllSubscribers.each: { |sub| sub<-notify(resolvedValues, ruinedValues)@OneWayMessage };
						finalize();
					};
				};
				nil;	
			}
		};

		def ruin(exception) {
			if: !isFullyResolved() then: {			
				ruinedValues := ruinedValues + [value];
				inbox.each: { |msg|
					// only propagate exceptions back along multifutures
					if: (is: msg taggedAs: GatherType) then: {
						msg.resolver<-ruin(exception)@OneWayMessage;
					};
				};
			
				whenEachSubscribers.each: { |sub| sub<-notifyRuined(value)@OneWayMessage };
				if: isFullyResolved() then: {
					whenAllSubscribers.each: { |sub| sub<-notify(resolvedValues, ruinedValues)@OneWayMessage };
					finalize();
				};
		  };
		};
		
		// invoked when all results have come in
		def finalize() {
			whenEachSubscribers := [];
			whenAllSubscribers := [];
			inbox := [];
		};

		// adds a whenEach listener to the future
		// @param sub a resolution listener
		def addResolutionListener(sub) {
			// notify the listener immediately for each already
			// known resolved/ruined result
			resolvedValues.each: { |val| sub<-notifyResolved(val)@OneWayMessage };
			ruinedValues.each: { |exc| sub<-notifyRuined(exc)@OneWayMessage };
			// only register the listener if there are more results to come in
			if: !(isFullyResolved()) then: {
				whenEachSubscribers := whenEachSubscribers + [sub];
			};
			nil;
		};
		
		// adds a whenAll listener to the future
		// @param sub a resolution listener
		def addWhenAllListener(sub) {
			if: (maxSize == nil) then: {
				raise: /.at.exceptions.XIllegalOperation("Cannot register whenAll listener on unbounded multifuture");
			};
			if: isFullyResolved() then: {
				sub<-notify(resolvedValues, ruinedValues);
			} else: {
				// only register the listener if there are more results to come in
				whenAllSubscribers := whenAllSubscribers + [sub];
			};
			nil;
		};

		// provide the required methods for the TFarRef trait

		def intercept(msg) {
			// forward the message to all already resolved values
			resolvedValues.each: { |val| resolvedValue <+ msg };
			// propagate the exception along a multifuture pipeline
			ruinedValues.each: { |exc|
				(is: msg taggedAs: GatherType).ifTrue: {
					msg.resolver<-ruin(exception)@OneWayMessage;
				};
			};
			// accumulate message in this future's inbox
			inbox := inbox + [msg];
			nil;
		};

		def toString() {
			if: (maxSize == nil) then: {
				"unbound multifuture"
			} else: {
				"multifuture of size " + maxSize
			}
		};

		// to satisfy the required interface of TFarRef, not really required
		def transportStrategy := { };
	});

	def resolver := object: {
		def resolve(val) { (reflect: fut).resolve(val) };
		def ruin(exc) { (reflect: fut).ruin(exc) };
		def future := fut;
	};

	// has the future been annotated with DueType?
	/*if: !(nil == timeout) then: {
		// if so, wrap resolver into a single-call lease
		resolver := LeasingModule.singleCallLease: timeout for: resolver;
		LeasingModule.when: resolver expired: {
			(reflect: fut).ruin(XTimeoutException.new(fut));
		};
	};*/

	[ fut, resolver ];
};

def MultiFutureModule := object: {
	
	// support for first-class futures: returns a pair
	// [ future, resolver]. The resolver can be used to easily resolve
	// or ruin the corresponding future
  def makeMultiFuture := &makeMultiFuture;

  // whenEach observers without catch blocks
	def whenEach: multiFuture becomes: resolvedBlock {
		whenEach: multiFuture becomes: resolvedBlock catch: Exception using: { |e|
			log("uncaught exception because no catch-clause specified: " + e, WARNING);
		}
	};

  // whenEach observers with generic catch-all block
	def whenEach: multiFuture becomes: resolvedBlock catch: excBlock {
		whenEach: multiFuture becomes: resolvedBlock catch: Exception using: excBlock
	};

	// whenEach observers with one specific catch block
	def whenEach: multiFuture becomes: resolvedBlock catch: excType using: excBlock {
		def [whenEachFuture,resolver] := FuturesModule.makeFuture();
		def notify(block, val) {
			try: {
				resolver.resolve(block(val));				
			} catch: Exception using: {|e|
				resolver.ruin(e);
			};
			nil;
		};
		multiFuture<-addResolutionListener(object: {
			def notifyResolved(val) { notify(resolvedBlock, val); };
			def notifyRuined(exc) {
				if: (is: exc taggedAs: excType) then: {
					notify(excBlock, exc);
				} else: {
					log("uncaught exception: " + exc + ". Can only cath: " + excType, WARNING);
				};
			};
		// note that <-addResolutionListener is a message directed to the future's mirror
		// and that no future return value is required
		})@[MetaMessage, OneWayMessage];
		whenEachFuture; // whenEach returns a future itself
	};

	// whenAll observers:
	// whenAll: mf resolved: { |tableOfValues| ... } ruined: { |tableOfExceptions| ... }
	// note that the resolved or ruined closures are not invoked if there are no
	// resolved values or exceptions. It is illegal to register a whenAll observer
	// on an unbounded multifuture.
	def whenAll: multiFuture resolved: resolvedBlock ruined: excBlock {
		def [futureForResolvedBlock,resolverForResolvedBlock] := FuturesModule.makeFuture();
		def [futureForExcBlock,resolverForExcBlock] := FuturesModule.makeFuture();
		def resolveWhenAllFuture(resolver, block, vals) {
			if: (vals == []) then: {
				resolver.resolve(nil)
			} else: {
				try: {
					resolver.resolve(block(vals));				
				} catch: Exception using: {|e|
					resolver.ruin(e);
				};	
			};
			nil;
		};
		multiFuture<-addWhenAllListener(object: {
			def notify(resolved, ruined) {
				resolveWhenAllFuture(resolverForResolvedBlock,resolvedBlock,resolved);
				resolveWhenAllFuture(resolverForExcBlock,excBlock,ruined);
			};
		// note that <-addWhenAllListener is a message directed to the future's mirror
		// and that no future return value is required
		})@[MetaMessage, OneWayMessage];
		// whenAll returns a pair of futures itself that will be resolved with values
		// representing the outcome of the resolved: and ruined: blocks respectively
		[futureForResolvedBlock, futureForExcBlock];
	};

  def MultiFuturesTest() {
	  extend: /.at.unit.test.UnitTest.new("MultiFuturesTest") with: {

      def testAsyncManualResolutionOfMultifuture() {
	      def [mf,resolver] := makeMultiFuture(2);
	      def [resF, ruinF] := whenAll: mf resolved: { |tbl|
		      self.assertEquals(1, tbl[1]);
		      self.assertEquals(42, tbl[2]);
		    } ruined: { |exc|
			    self.fail("unexpected exception during resolution")
			  };
	      resolver.resolve(1);
	      resolver.resolve(42);
	      resF
      };

	  };
  };

};