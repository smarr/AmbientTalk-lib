/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Implementation of the Ambient Behaviors abstractions based on
 * the Reactive version of the AmbientTalk interpreter.
 *
 * @author alombide
 */

object: {

def ambientBehaviorsModule := object: {

def AmbientRefModule := /.at.lang.ambientrefs;


deftype Lifted;
def HashMap := jlobby.java.util.HashMap;
def behaviorMirrorsHandlesMap := HashMap.new();

// Exports the behavior to all consumers whose service object matches the
// description encoded in the consumerDiscoveryClosure closure.
// This means that the values of the passed behavior are broadcasted to all
// consumers leading to an update of their ambient behavior.
def @Lifted exportBehavior: aBehavior as: type to: consumerDiscoveryClosure {
	def behaviorMirror := reflect: aBehavior;
	findAndUpdateListeningBehaviors(aBehavior, type, consumerDiscoveryClosure, behaviorMirror);
};


def @Lifted exportBehavior: aBehavior as: type {
	def behaviorMirror := reflect: aBehavior;
	findAndUpdateListeningBehaviors(aBehavior, type, nil, behaviorMirror);
};


def findAndUpdateListeningBehaviors(value, type, serviceDiscoveryClosure, behaviorMirror) {
	def oldHandle := behaviorMirrorsHandlesMap.get(behaviorMirror);
	if: (nil != oldHandle) then: {
		oldHandle.cancel();
	};
	def ar := 
		(if: (nil == serviceDiscoveryClosure) then: {
			AmbientRefModule.ambient: type;
		} else: {
			AmbientRefModule.ambient: type where: serviceDiscoveryClosure;
		});
	oldHandle := ar<-setValue(value)@[AmbientRefModule.All];
	behaviorMirrorsHandlesMap.put(behaviorMirror, oldHandle);	
};


def createBehaviorAndExportedObject() {
	def theEventSource := makeEventSource();
	def theBehavior := hold: theEventSource with: (object: {
		def updateWithValue(aValue) {
			aValue;
		};
	});
	def exportedObject := object: {
		def subscription := nil;
		def cancel() {
			subscription.unexport();
		};
		def setValue(aValue) { 
			theEventSource<-updateWithValue(aValue);
		};
	};
	[ theBehavior, exportedObject ];
};


// Listens for exported behaviors matching the passed type and service object.
// Returns two things: a behavior and a subscription object.
// The behavior is updated when the observed exported behavior is updated.
// This happens via messages over the network, so delays are to be expected.
// The subscription object understands a cancel method that can be used 
// to cancel the subscription on the exported behavior.
def ambientBehavior: type with: serviceObjectClosure {
	def [ theBehavior, exportedObject ] := createBehaviorAndExportedObject();
	def subscription := AmbientRefModule.export: exportedObject as: type with: serviceObjectClosure;
	exportedObject.subscription := subscription;
	[ theBehavior, exportedObject ];
};


def ambientBehavior: type {
	def [ theBehavior, exportedObject ] := createBehaviorAndExportedObject();
	def subscription := AmbientRefModule.export: exportedObject as: type;
	exportedObject.subscription := subscription;
	[ theBehavior, exportedObject ];
};

}}



