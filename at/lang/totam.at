/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2011
 * Authors: SOFT Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * TOTAM: Tuples on the Ambient.
 *
 * @author egonzale, cfscholl
 */
def Vector := /.at.collections.vector.Vector;
def HashMap := jlobby.java.util.HashMap;
import /.at.lang.futures;
enableFutures(false);
import /.at.lang.exceptions;
deftype TotamTuple;
deftype LeasedTuple <: TotamTuple;
deftype TotamTupleSpaceT;
def timerModule := /.at.support.timer;

//helper function to construct isolate objects overriding print method for debugging/unittesting purposes.
def isolate: closure printAs: printClosure {
	def clo := script: printClosure;
  object: closure taggedAs: [/.at.lang.types.Isolate] mirroredBy: (
		mirrorIsolate: { |clo| def print() { clo(self.base) } }
	);
};

def delayedSerializationMirror :=  mirror: {
  import /.at.lang.firstclassrefs.TEventualRef exclude pass, invoke, retractUnsentMessages;
  def connected := true;
  def inbox := [];
  def reference;

  def init(base, ref){
	  super^init(base);
	  reference := ref;
	  connected := true;
	  inbox := [];
	  //place listeners for connection maintance
		whenever: reference disconnected:{
		  connected := false;
		  def outbox := retract: reference;
		  inbox := inbox + outbox;
	  };
	  whenever: reference reconnected: {
		  connected := true;
		  //ToDo: we could cleanup expired tuples here, rather than deciding this at receiver side.
			inbox.each: { |msg| reference <+ msg };
			inbox := [];
	  };
  };
  def asFarRef(){reference};
  def intercept(msg) { 
	  if: self.connected then: { reference <+ msg } 
	  else:{ inbox := inbox + [msg] };
	};
  def toString() { "delayedSerializationRef:" + reference };		
  // def transportStrategy; // not needed: proxy is pass-by-far-reference
  def retractUnsentMessages() { 
	  def return := inbox; 
	  inbox := [];
	  return;
	};
	//override equality
	// disallow synchronous access to the object
  def invoke(slf, inv) {
	  // the only legal operation on references is '=='
	  if: (`(==) == inv.selector) then: {
			// two delayed serialization refs are equal iff the far ref encapsulate are equal.
			reference == (reflect: (inv.arguments)[1]).asFarRef();
	  } else: {
			raise: XIllegalOperation.new("Cannot synchronously invoke " + inv.selector + " on " + self.dumpContent());
	  }
	};
/*	def name := /.at.support.util.makeMutator(`==);
	def mutMethod := createMethod(name, [ `aRef ], `{ reference == (reflect: aRef).getFarRef() }, []);
	self.removeSlot(name);
	self.addSlot(createClosureMethod(self.base, mutMethod));*/
};

def delayedSerializationRef: reference {
	object: { } mirroredBy: { |base| delayedSerializationMirror.new(base, reference)};
};

def ambientTupleSpace := object: {
	 def hashMap;
	 def value := object:{
	   def tuple; def tableTsIds;
	   def init(t, tblTsIds := []) {tuple := t; tableTsIds := tblTsIds};
	   def addTs(tsId) { 
		   if: (! tableTsIds.contains(tsId)) then: {
		     tableTsIds := tableTsIds + [tsId];
		   };
		 };
	   def getTs(){tableTsIds};	 
	 };
	 def init(){
		hashMap := HashMap.new();
	 };
	 def each: clo {
		def valit := hashMap.values().iterator();
		while: { valit.hasNext() } do: {
			def value := valit.next();
			clo(value.tuple, value.tableTsIds);
		};
	 };
	 def add(tuple, tableTsId := []){
		 hashMap.put(tuple.getTupleId, value.new(tuple, tableTsId));
	 };
	 
	 def contains(tupleId){
	   { |return|
	      def comparator := { |tid| tid == tupleId};
	      def keyit := hashMap.keySet().iterator();
	      while: { keyit.hasNext() } do: {
		      def key := keyit.next();
		      if: (comparator(key)) then: {return(true) };
		    };
		    false;
	    }.escape();
	 };

	 def remove(tupleId){
		 def comparator := { |tid| tid == tupleId};
		 def keyit := hashMap.keySet().iterator();
		 def found := false;
		 def toRemove := nil;
		 while: { (keyit.hasNext()).and:{ !found} } do: {
			 def key := keyit.next();
			 if: comparator(key) then: {
				 toRemove := key; found := true;
			 };
		 };
		 if: found then: {
			hashMap.remove(toRemove);	 
		 } else: {
			 nil;
		 };
	 };
	 //application-dependent method.
	 def addTs(tuple, tsId){
		 def value := hashMap.get(tuple.getTupleId);
		 if: (nil != value ) then:{
		   value.addTs(tsId);
		 } else:{ //this shouldn't happen!	
 		   system.println("warning: trying to add tsId to a tuple not present in the tuple space" + tuple.getTupleId);
           add(tuple, [tsId]);
		 };
	 };
	 
	 def length() {
	   hashMap.size();
	 };
};

//helper functions adapted from context-aware tuples
//for when:matches: implementation
def makeNewClosure(variableNames, closure) {
	def newClosureStatements := `{ | #@(variableNames) | 
		#@(closure.method.bodyExpression.statements) };
	eval: newClosureStatements in: closure.context.lexicalScope;
};

def varNames(template) {
	def table := [];
	template.each: { |attribute|	
		if: (is: attribute taggedAs: /.at.lang.types.Symbol) then: { //its a variable
			def variableName := attribute.symbol; 
			if: !(table.contains(variableName)) then: {
				table := table + [variableName];
			};
		};
	};
 	table;
};

// given a TS near or far reference, returns its tupleSpaceId (an integer)
def tsidOf(ts) {
	/.at.support.util.getAnnotationOfType(ts, TotamTupleSpaceT).tupleSpaceId;
};

def makeTupleSpace(descriptor := nil){
    def tupleSpaceId :=  /.at.support.util.RandomNumberGenerator().nextInt(); 	
	def localTS := Vector.new(); //contains local tuples
	// contains tuples which needs to be transmitted to the ambient
	def ambientTS := ambientTupleSpace.new(); 
	def localTSListeners := Vector.new(); 
	def seenTS := HashMap.new(); // contains: key TupleSpaceId - value: [far reference, descriptor].
	def seenTS.each: clo {
		def keyit := seenTS.keySet().iterator();
		def valit := seenTS.values().iterator();
		while: { valit.hasNext() } do: {
			def value := valit.next();
			clo(keyit.next(), value[1], value[2]);
		};
	};
	def seenTS.getTsInfo(tsRef) { // returns [tupleSpaceId, remoteTs, descriptor]
		def return := nil; def found := false;
	  def keyit := seenTS.keySet().iterator();
		def valit := seenTS.values().iterator();
		while: { (valit.hasNext()).and: {!found}} do: {
			def value := valit.next(); def key := keyit.next();
			def farRef := (reflect: value[1]).asFarRef();
			if: (farRef == tsRef) then: { found := true; return := [key] + value; }
		};
		return;
	};
	def seenTS.asTable() {
		def table := [];
		seenTS.each:{ |id, ref, des| table := table + [[id, ref, des]]};
		table;
	};
	// todo gc seenTS. Only remove if ambientTs do not contain TupleSpaceId.
	
	//register listener for in or rd operations
	def registerListener(l) { 
	   localTSListeners.add(l);
	  object: { 
		  def cancel() {
			 removeListener(l)
			};
		};
	};
 	
    def removeListener(l) {
	  localTSListeners.remove(l); 
	};
	  
	def notifyListeners(tuple){
      localTSListeners.each: { |l| l<-notifyTupleInserted(tuple) }; 
	};
	
	def removeFromTS(tuple){
	  localTS.removeAll: {|t| (t.getTupleId == tuple.getTupleId)};
	  ambientTS.remove(tuple.getTupleId);
	};
	
	//method starting up the tuple propagation from discovery.
	def moveTupleInAmbientTS(localTs, remoteTupleSpaceId, remoteRefTs, remoteDescriptor){
	  def [toSend, toRemove] := [[], []];
	  def remoteTs := delayedSerializationRef: remoteRefTs;
		// add ts to seenTS vector so that it can be
	  // notified if I add a new tuple to the ambient.
		//to think: should we override info if remoteTupleSpaceId is already in the seenTS?
	  if: (!seenTS.containsKey(remoteTupleSpaceId)) then: {	
	   	seenTS.put(remoteTupleSpaceId, [remoteTs, remoteDescriptor]);
	  };
	  // fill toSend 
	  ambientTS.each: { |tuple, sentTupleSpaces| 
	      def [isDead, isInScope] := sendTuple(tuple, localTs, remoteDescriptor);
		  if: isInScope then: { toSend := toSend + [tuple] };
		  if: isDead then: { toRemove := toRemove + [tuple] };
	  };
	  if: (toSend.length > 0) then: {	
		toSend.each: { |tuple| 
		  ambientTS.addTs(tuple, remoteTupleSpaceId);
		  moveTuple(remoteTs, tuple, tupleSpaceId)
		};
   		//remoteTs<-receiveTuples(toSend, tupleSpaceId);
	  };
	  if: (toRemove.length > 0) then: {
	    toRemove.each: { |tuple| removeFromTS(tuple) };
	  };	
  };
	
	//totam propagation protocol (receiver side)
	def receiveTuple(tuple, ts){
	  if: tuple.decideEnter(ts) then: {
    	tuple.doAction(ts);
		tuple := tuple.receiveTuple();  
		if: tuple.decideStore(ts) then: { 
			ts.out(tuple); 
		};
		tuple; 
	  };
    };
	
	// totam propagation protocol (sender side - part 1 of 2)
    // returns [boolean, boolean] indicating whether the tuple needs to be removed from the tuple space, and whether the tuple is in scope or not.
	def sendTuple(tuple, ts, otherDescriptor){
	  // toThink: this method could be called twice via inject and discovery when the ts discover.
	  // this is not so bad, because a receiving ts checks if it already triggered propagation protocol for this tuple via tupleId.
	  if: tuple.decideDie(ts) then: {
		[true, false];
	  } else:{
		//only call inScope method if the tuple space had a descriptor
		if: (descriptor != nil) then: { 
		  [false, tuple.inScope(descriptor, otherDescriptor)];
		} else: {
		  [false, true]
		};
	  };
	};
	
	// totam propagation protocol (sender side - part 2 of 2)
	def moveTuple(receiverTs, tuple, senderTupleSpaceId) {
		// replace the tuple content if necessary.
        // note that doesn't modify the propagation strategy.
		tuple := tuple.sendTuple();
	    receiverTs<-receiveTuples([tuple], senderTupleSpaceId);
	};
	  
	//method starting up the propagation protocol from inject after 1st hop.
	def sendTupleToAmbient(tuple, hasTupleChanged, priorSenderTsId){
	  if: !(ambientTS.contains( tuple.getTupleId)) then: {
		 // OPTIMIZATION: we do not apply sending protocol to antituples, because they died at every hop.
		 if: (!tuple.getTupleId.isAntituple) then: { 
		   // adding the tuple to the ambient for next sync.
		   ambientTS.add(tuple);
		   seenTS.each: { |tsId, tsRef, tsDescriptor| 
		     def [isDead, isInScope] := sendTuple(tuple, localInterface, tsDescriptor);
		     if: (isInScope.and:{ !isDead}) then: { 
		 	   ambientTS.addTs(tuple, tsId);
		 	   if: ((tsId == priorSenderTsId).and:{ !hasTupleChanged}) then: { 
		 	   // if the tuple has not changed: do not send back a tuple to the TS which just sent it to this TS.
			   } else: {
			     moveTuple(tsRef, tuple, tupleSpaceId);
			    // tsRef<-receiveTuples([tuple], tupleSpaceId); 
			   };
		     } else: {
		       // either the tuple not isInScope or isDead.
		       if: isDead then: { removeFromTS(tuple)};
		     };
		   };
	     }; //end-if-isAntituple
	  };
	};
	
	// implements the functionality of a atomic remove but since it is used by both 
	// local and remote interface, implemented as a private method.
	def atomicRemovePrivate(tupleId, antituple := true) {
		// it should be either in the localTS or 
		// in the ambientTS (if it was injected here but not stored in the localTS)
		//localTS.removeAll: {|t| t.getTupleId == tupleId};
		def result := false;
		def localTupleId := localTS.find: { |t| t.getTupleId == tupleId };
		if: !(nil == localTupleId) then: {
			localTS.removeAll: { |t| t.getTupleId == tupleId }; 
			result := true;	
		};	
		if: (ambientTS.contains(tupleId)) then: {
			//remove the tuple for good :)
			def value := ambientTS.remove(tupleId);
			if: (nil != value) then:{
				def ambientTuple := value.tuple;
				//sends an antituple if required.
				if: antituple then:{
					def propagate := true;
					//only propagate the antituple as long as the tuple is still alive if it was leased, 
					// otherwise it would have died as well in other nodes.
					if: ((is: ambientTuple taggedAs: LeasedTuple).and:{ambientTuple.decideDie(localInterface)}) then: {propagate := false};
				  if: propagate then:{
					  value.getTs.each:{ |tsId| 
						  def value := seenTS.get(tsId);
						  def tsRef := value[1];
						  tsRef<-receiveTuples([makeAntiTuple(ambientTuple)], tupleSpaceId)
						};
				  };
			  };
		    result := true;
			};
		};
	  result;
  };

  //helper function used by when(ever):in listeners and inpWithAtomicRemove
  def removeRemoteTuple(tuple){
	  def tupleId := tuple.getTupleId(); 
	  // find first the remote far reference for the orignator ts.
	  def value := seenTS.get(tupleId.getTupleSpaceId());
    // ask the originator to remove the tuple
	  if: !(nil == value) then:{
		  def remoteTs := value[1];
		  remoteTs<-atomicRemove(tupleId)@FutureMessage;
	  } else: {
		  //this shouldn't happen, if it is a remote tuple, its ts should be in seenTS
		  def [fut,res] := makeFuture();
		  res.resolve(false); 
			fut;
	  };
  };

  def inpWithAtomicRemove(template){
	  def [futRV,resRV] := makeFuture();		  
  	def toReturn := localInterface.rdp(template);
    if: (nil != toReturn) then:{
      def tupleId := toReturn.getTupleId;
	    if: (tupleId.isRemote(tupleSpaceId)) then: {
			when: removeRemoteTuple(toReturn) becomes: { |removed|
			   if: removed then:{
				   localTS.remove(toReturn);
				   resRV.resolve(toReturn);
			   } else: { resRV.resolve(nil)};
		    } catch: /.at.lang.types.Exception using: { |e|
			    resRV.resolve(nil);
			};
      } else: { // found and not remote, end
	      localTS.remove(toReturn);
	      resRV.resolve(toReturn);
	    };
	  } else:{ //not found , end
		  resRV.resolve(toReturn);
	  };
	  futRV;
  };

  // remote interface 
  def remoteInterface := object: {
		// iterates over all ambient tuples of the other ts 
		// and triggers the propagation protocol			
	def receiveTuples(tuples, senderTsId){
	  tuples.each: { |tuple|
	    // totam propagation protocol
	    def newTuple := receiveTuple(tuple, localInterface); 
	    if: (newTuple != nil) then: { 
	      // check whether the tuple has changed to optimize tuple sending. 
	      def hasTupleChanged := (tuple.getTupleId != newTuple.getTupleId); 
	      // propagate tuple to required connected tuple spaces.   
		  sendTupleToAmbient(tuple, hasTupleChanged, senderTsId);
		};
	  };
  	};
	 
	def getDescriptor() { descriptor };
    //def atomicRemove := &atomicRemovePrivate;
	def atomicRemove(tupleId, antituple := true) {
	  atomicRemovePrivate(tupleId,antituple);
	};
	  
  } taggedAs: [ extend: TotamTupleSpaceT with: { |tupleSpaceId| }];	

	// public interface
	def localInterface := object: {
		// add a tuple to the local ts
	  def out(tuple, timeout :=  timerModule.ZERO){
	 	  if: (doesTupleHasVariables(tuple)) then:{
				error("trying to insert a template into the tuple space");
		  } else: {
	      if: (timeout > timerModule.ZERO) then: {
			    timerModule.when: time elapsed: {
				    localTS.remove(tuple);
			    };
			  };
			  //do not add a tuple which was already there
			  //otherwise it may trigger when:read/in twice for same tuple!
			  if: !(localTS.contains( tuple, {|t, t1| t.getTupleId == t1.getTupleId})) then: {
				  def tupleId := tuple.getTupleId();
				  if: (!tupleId.isInTupleSpace) then:{ 
					  //set tupleId because it was inserted by a local out.
					  tupleId.tupleSpaceId := tupleSpaceId; 
					};
			      localTS.add(tuple);
				  notifyListeners(tuple);
			  };
			};
	  };
	  // non-blocking rd operation 
		// returns a tuple matching the template in the ts or 
		// nil if non is present at the time of the request. 
		// if multiple tuples match the tample,
	  // the one returned is selected non-deterministic.
		def rdp(template) { 
			{ |return|
			  localTS.each: { |tuple|
				  //it matches the template and it is not death
				  if: ((template.match(tuple)).and: {!tuple.decideDie(localInterface)}) then: { return(tuple)};
			  };
			  nil;
			}.escape();
		};
		
		// bulk rd operation (~rdg in lighTS)
		// returns all tuple matching the template in the ts or 
		// [] if non is present at the time of the request.
		def rdg(template){
			def toReturn := [];
			localTS.each: { |tuple|
				//it matches the template and it is not death
				if: ((template.match(tuple)).and: {!tuple.decideDie(localInterface)}) then: { 
					toReturn := toReturn + [tuple];
				};
			};
			toReturn;
		};	
				
		//inserts a tuple into the ambient ( ~ inject in TOTA)
		//note that this just exports a tuple to the ambient
		//but it does not store in the local ts.
		def inject: tuple {
			if: (doesTupleHasVariables(tuple)) then:{
				error("trying to inject a template to the network");
			} else: {	
				// set the tuple id
				(tuple.getTupleId()).tupleSpaceId := tupleSpaceId; 
			  //send to local tuple space if necessary.
              // Optimization so that the tuple in scope does not need to hop to a proximate node and hop back to be received.
 			  def [isDead, isInScope] := sendTuple(tuple, self, descriptor);
			  if: (isInScope.and:{!isDead}) then: { 
			    receiveTuple(tuple, self) 
			  } else: { // either the tuple is not in scope or is dead.
			    if: isDead then: { removeFromTS(tuple) };
			  };
			  // send to the ambient.
			  sendTupleToAmbient(tuple, false, tupleSpaceId);
		    //return a publication object to be able to cancel the injection.
		    object:{
			  def retract(){ 
			    // retracting the injection makes the tuple be withdrawn. 
			    // This implies canceling the injection, and removing the tuple from the network (by means of an antituple( 
			    atomicRemovePrivate(tuple.getTupleId)
			  };
		      def cancel(){
		        //canceling an injection stops the propagation in the network from this node
 				ambientTS.remove(tuple.getTupleId);
			  };
		    };
		  };
		};
		// injects a tuple into the ambient with a lease.		
		def inject: tuple timeout: time {
			if: (time > timerModule.ZERO) then: { 
			  def leasingPropagation := leasingPropagationProtocol().new(time);
				// modify the delegation chain as follows:
				// propagation protocol <- leasingPropagation <- tuple
			  leasingPropagation.super := tuple.super;
			  tuple.super := leasingPropagation;
			};
			inject: tuple;
		};
		// functions to place a listener on the tuple space ( ~ subscribe in TOTA, reactions of LIME)
		// triggered asynchronously when a tuple matches a template
		// it returns a publication object with a cancel() object to be able to unsusbscribe 
		// 2 types of reactions:
		// duration of registration: (1) when: called once for the first matching tuple 
		//                           (2) whenever: called everytime for a matching tuple.
		// operation listening: in or rd
		def when: templateTable read: closure {
			when: templateTable matches: closure registration: false removeTuples: false;
		};
		def when: templateTable in: closure {
			when: templateTable matches: closure registration: false removeTuples: true;
		};
		def whenever: templateTable read: closure {
			when: templateTable matches: closure registration: true removeTuples: false;
		};
		def whenever: templateTable in: closure {
			when: templateTable matches: closure registration: true removeTuples: true;
		};
			
		// common behaviour of when:whenever:in/read
		def when: template matches: closure registration: installListener removeTuples: inTuple {
	    def registration; def activeRegistration := true;
		  def variableNames := varNames(template);
		  closure :=  makeNewClosure(variableNames, closure); 
			//helper funcs  
			// maps the values of the matched tuple to 
		  //the variables in the template and notify the closure
			def notifyClosure(tuple){
				 // only notify if we are still active 
				if: activeRegistration then:{
			    def mapValues := variableNames.map: { |var|  
			      def index := template.getIndexOf(var);
			      tuple.getField(index); 
			    };
			    closure(@mapValues);
			  };
			};
		  // it manages the registration of listeners for in/read operations.
			def addListener(){
				if: (registration == nil) then: { //makes sure we only install 1 listener per call.
				  def listener := object: {
					  def active := true;
	          def notifyTupleInserted(tuple){
		          if: active then: { 
	              if: ((template.match(tuple)).and:{!tuple.decideDie(localInterface)}) then: {
		              // listener for in operation should remove the tuple!
								  if: inTuple then: { // listener for an in operation
									  if: (tuple.getTupleId().isRemote(tupleSpaceId)) then:{ // the matching tuple is remote 
										  // it needs to do an atomic remove 
										  when: removeRemoteTuple(tuple) becomes: { |removed|
										    if: removed then: {
											    localTS.remove(tuple);
											    notifyClosure(tuple); 
											  };
										  };
									  } else:{  // the matching tuple is local 
 									    localTS.remove(tuple);	
									    notifyClosure(tuple); 
								    };
								  } else: { //listener for read operation
									  //it notifies closure
			              notifyClosure(tuple); 
								  };
							    // cancel the subscription for when: listeners
							    // it could be that an async. message was already scheduled for this listener
							    // but if it is a when:, it shouldn't be processed.
		              if: (!installListener) then: { active := false; registration.cancel()};
	              };
	            };
		        };
		      };
			    registration := registerListener(listener);
			  };
			};
			// code for when: template matches: closure registration: installListener removeTuples: inTuple 
			if: inTuple then: { //when:in
				when: inpWithAtomicRemove(template) becomes: { |matchingTuple|
					if: (nil == matchingTuple) then:{
						// we didn't found a matching tuple, install listener.	
				  	addListener();
					} else:{
						notifyClosure(matchingTuple);
					};
				}; 	
			} else:{ 	//when:read 
				def matchingTuple := rdp(template);	
				if: (nil != matchingTuple) then: { //we got a tuple, notify closure
					notifyClosure(matchingTuple); 
				} else: { // we didn't found a matching tuple, install listener.	
				 addListener();
				};
			};
			// install a listener if it is a whenever:
			if: installListener then: { addListener(); };
	    // return value a publication object to cancel the registration
	    object: {
		    def cancel(){
			    activeRegistration := false; // cancel this registration
			    // registration is nil if when:ip/rd and we found a tuple.
			    if: (nil != registration) then:{ registration.cancel()};
		    };
	    };
	  };
		// additional methods provided to keep service  
		// discovery decoupled from tuple space implementation
		
		// notifies the discovery of a TS	
		// and starts the propagation protocol (sender side)
		def notifyTSDiscovered(ts, descriptor := nil){ 
			// get the descriptor if it is not known.
		  if: (descriptor == nil) then: {
			  when: ts<-getDescriptor()@FutureMessage becomes: { |descriptor|
				  moveTupleInAmbientTS(self, tsidOf(ts), ts, descriptor); 
			  };
		  } else: {
			  moveTupleInAmbientTS(self, tsidOf(ts), ts, descriptor);
		  };
    	};
    // get remote interface so that it can be 
    // exported to the network
	  def getRemoteInterface(){
		  remoteInterface;
	  };
		// exports this tuple space and listens for other
		// tuples spaces which appear in the network
		// using AT service discovery
    def goOnline(){
	    def p := export: remoteInterface as: TotamTupleSpaceT;
	    def s := whenever: TotamTupleSpaceT discovered: { |remoteTs|
		    def remoteTsInfo := seenTS.getTsInfo(remoteTs); 
		    // returns [tupleSpaceId, remoteTs, descriptor]
			  if: (nil == remoteTsInfo) then:{ 
			    // seen this tuple space for first time, we need descriptor and tupleSpaceId
			    notifyTSDiscovered(remoteTs);
			  } else:{ //re-discovering a tuple space already seen.
				  notifyTSDiscovered(remoteTs, remoteTsInfo[3]);
			  };
			};
			network.online();
	    object:{
		    def cancel(){ p.cancel(); s.cancel(); };
	    };
    };
    // added for debugging/unittest purposes
    def dumpContents() {
		def lts := [];
	    localTS.each: {|tuple| lts := lts + [tuple] };
	    [tupleSpaceId, lts, seenTS.asTable()];
    };

    //TODOdef atomicRemove := &atomicRemovePrivate;
    def atomicRemove(tupleId, antituple := true) {
	   atomicRemovePrivate(tupleId,antituple);
		};	
	}; // end-of-public interface
};

// helper function to construct a tuple id which consist of.
// -tupleSpaceId uniquely identifying the originator of the tuple. 
// -tupleId uniquely identifying the tuple within a tuple space.
def TupleId := isolate: { 
	def tupleId; 
	def tupleSpaceId; // unbound until tuple inserted in a ts.
	def antituple := false;
	def init(tsId := 0, tId := nil, anti := false){
		if: (tId == nil) then:{ 
			tupleId := /.at.support.util.RandomNumberGenerator().nextInt();
		} else:{ tupleId := tId};
		antituple := anti;
		tupleSpaceId := tsId; 
	};
	def isAntituple(){antituple};
	def isInTupleSpace(){ 0 != tupleSpaceId};
	def isRemote(aTsId){ tupleSpaceId != aTsId };
    def getTupleSpaceId(){tupleSpaceId};
	def getTupleId() {tupleId};
	def ==(aTupleId){ 
		(tupleId == aTupleId.getTupleId).and: {tupleSpaceId == aTupleId.getTupleSpaceId};//.and:{ antituple == aTupleId.isAntituple()}
	};	
} printAs: { |base|
	def antitupleSign := "+";
	if: base.antituple then: { antitupleSign := "-"};
	"<" + base.tupleSpaceId + ":" + base.tupleId + ":" + antitupleSign + ">";
};

def makeTuple(tupleId, @fields) {
	isolate: { |tupleId, fields|
	  //getTupleId shouldn't be part of the public interface, kept for unit testing
	  def getTupleId() { tupleId };
	  def length(){ fields.length };
	  def getField(n) { fields[n] };
	  def getFields() {fields};
	  def getIndexOf(val){
		  { |return|
			  def index := 0;
		    fields.each:{ |field| 
			    index := index + 1;
			    if: (is: field taggedAs: /.at.lang.types.Symbol) then: {
				     field := field.symbol;
			    };
			    if: (field == val) then: {return(index)};
		    };
		    index;
	    }.escape();
	  };
	  def findAllSymbols(template, aSymbol){
			def positions := []; def i := 1;
		  while: { i <= template.length} do: {
			  def field := template.getField(i);
			  if: ((is: field taggedAs: /.at.lang.types.Symbol).and: { field.getSymbol == aSymbol}) then: {
				  positions := positions + [i];
			  }; 
			  i := i + 1;
		  };
		  positions;
	  };
	  def match(t1) {
		  def result := true;
		  if: (t1.length == self.length) then: {
		 	  def it := 1; 
			  while: { (it <= fields.length).and: { result} } do: { 
				  def e1 := t1.getField(it); 
				  def e2 := getField(it);
					def symbolField := nil; def tuple := nil; def template := nil;
					if: (is: e1 taggedAs: /.at.lang.types.Symbol) then: { symbolField := e1.getSymbol; tuple := self; template := t1 };
				  if: (is: e2 taggedAs: /.at.lang.types.Symbol) then: { symbolField := e2.getSymbol; tuple := t1; template := self };
					if: (symbolField != nil) then: {
						def positions := findAllSymbols(template, symbolField);
						if: (positions.length > 0) then: { // the field is a symbol which has several appearances in the temple,
						  //all positions in the tuple should have the same value.
						  def val := tuple.getField(positions[1]); 
						  result := { |return|
							  def sameValue := true;
						    positions.each: { |p| sameValue := sameValue.and: {(tuple.getField(p)) == val}; if: (!sameValue) then: {return(false)}};
						    true;
						  }.escape();
						} else: { // the field is symbol which is only once in the template, so it works like a wildcard.
							result := true;
						};
					} else: {  // the field is a value
						result := (e1 == e2); 
					}; 
				  it := it + 1; 
			  };
		  } else: { result := false};
		  result;
	  };
	  def each: l  { fields.each: l };
	} printAs: { |base|
		def content := base.getFields().map:{ |e| 
		  if: (is: e taggedAs: /.at.lang.types.Symbol) then:{ e.getSymbol.text}
		  else: {e};
		};
		if: (nil == base.super) then: {
		  "<"+ base.getTupleId() + ":withContent:"+ content +">";
		} else:{
		  "<"+ base.getTupleId() + ":withContent:"+ content + ":withPropagationStrategie: "+ base.super +">";
	  };
	};
};

def doesTupleHasVariables(tuple){
	{ |return|
		tuple.each: { |field|
		  if: (is: field taggedAs: /.at.lang.types.Symbol) then: { return(true) };
		};
		false;
	}.escape();
};

// default TOTAM tuple behaviour = 
// always in scope and store itself in every hop.
def defaultPropagationProtocol(){
  isolate: {
		// sender-side operations
		// called in every tuple before transmiting the tuple at the sending side !
		def inScope(senderDescriptor, receiverDescriptor){ true };
		// if true -> tuple gets unexported and deleted from local local tuple space.
		def decideDie(ts){false};
		// before transmitting the tuple, its content/protocol may be altered.
		def sendTuple(){self};
		
		// receiver-side operation (most of them inherited from TOTA)
		// called in every tuple at arrival at receiver side.
		def decideEnter(ts) { true };
		// specifies operations to perform on the local tuple space
		def doAction(ts){};
		// before receiving a tuple, its content/protocol may be altered.
		def receiveTuple(){self};
		// if true -> the tuple gets added to local TS
		def decideStore(ts) {true};
	} printAs:{ |base|
	   "<defaultPropagationProtocol>";
	};
};

// templates shouldn't propagate so, 
// they carry a dummy propagation protocol
// which basically doesn't not propagate
def noPropagationProtocol(){
	isolate: { 
		def inScope(senderDescriptor, receiverDescriptor){false};
		def decideDie(ts){true};
		def sendTuple(){self};
		def decideEnter(ts) { false };
		def doAction(ts){};
		def receiveTuple(){self};
		def decideStore(ts) {false};
	}	printAs:{ |base|
		"<noPropagationProtocol>";
	};
};
// attaches leasing protocol to a given propagation protocol.
// used implement inject:timeout:
def leasingPropagationProtocol(){
	object: {
		def timeout;
		def timerSubscription := nil;
		def expired := false;
		def ZERO := /.at.support.timer.ZERO;
		def init(time := ZERO, startTicking := true){
			 timeout := time; 
			 expired := false;
			 timerSubscription := nil; 
			 //initialize the timer.
			 if: startTicking then: {startSubscription()};
		};
		def startSubscription(){
	 	  if: ( timeout > ZERO) then: {
			  timerSubscription := /.at.support.timer.when: timeout elapsed: {
				  whenExpired();
			  };
		  };
		};				
		def whenExpired(){
		    timeout := ZERO;
			expired := true;
		};
		
	/*	def sendTuple(){
		  if: (!expired) then: {
			timeout := timerSubscription.getTimeRemaining();
			timerSubscription := nil;
		  };
		  self;
		};
		
		def receiveTuple() {
		  startSubscription();
		  self;
		};*/
		//overrides default decideDie to take into account
		def decideDie(ts){ self.expired };
		//do not enter if you are expired.
		def decideEnter(ts) {!self.expired };
	} taggedAs: [/.at.lang.types.Isolate, LeasedTuple] mirroredBy: ( 
		mirrorIsolate: {
		  def print() {"<leasing propagation protocol:" + self.base.timeout + ":"+ self.base.super +">" };		
		  def pass(){
		    // we don't use super^pass(); because it returns self!
			  def base := self.base;
			  if: (!base.expired) then: {
				  def time := base.timerSubscription.getTimeRemaining();
				  def parentPropagation := base.super; //they will pass by isolate
				  /.at.support.util.uponArrivalBecome: { | time, parentPropagation| 
					   def lpp := /.at.lang.totam.leasingPropagationProtocol().new(time);
					   lpp.super := parentPropagation;
					   lpp;
				  };
			  } else: {
				  // passing an expired tuple, which will be still transmitted but doesn't enter to the other ts.
				  super^pass();
			  };
		  };
	 });
};

def antiTuplePropagationProtocol() {
	//one hop tuple which further propagates the atomic removal of the original tuple
	isolate: {
	  def die := false;
	  //by design antituples generated by the system do follow the tuple everywhere it was sent.
	  //TODO: keeping the inScope/decideDie as the original will make it follow the tuple as well.
    def inScope(senderDescriptor, receiverDescriptor) {false};
    def decideDie(ts){ die };
    def sendTuple(){self};
    //custom protocol for antituple.
    def decideEnter(ts){!die};
    def doAction(ts){
	    ts.atomicRemove(self.getTupleId());
        die := true;
    };
    def decideStore(ts) {false};
    def receiveTuple(){self};
  
  }	printAs: { |base|
	  if: (nil == base.super ) then: {
		  "<antiTuplePropagationProtocol>"
	  } else:{
		  "<antiTuplePropagationProtocol: " + base.super + ">"
		};
	};
};
	
def makeAntiTuple(tuple){
	//antituple has the same content than its tuple but different sign!
	def tupleId := tuple.getTupleId();
	def antiTupleId := TupleId.new(tupleId.getTupleSpaceId(), tupleId.getTupleId(), true);
	def antiTuple := makeTuple(antiTupleId, tuple.getFields());
	//attach anti tuple propagation
	def defaultPropagation := antiTuplePropagationProtocol();
	antiTuple.super := defaultPropagation;
	// attach leasing propagation policy if original tuple had it
	if: (is: tuple taggedAs: LeasedTuple) then:{
		def time := tuple.timerSubscription.getTimeRemaining();
		def leasingPP := leasingPropagationProtocol().new(time);
		leasingPP.super := defaultPropagation;
		antiTuple.super := leasingPP;
	};
	antiTuple;
};
//TotamModule.TotamTest.runTest

// the module object of this file
def TotamModule := object: {
	// public stuff goes here
	def LeasedTuple := LeasedTuple;
	def makeTupleSpace := &makeTupleSpace;
	
	def tuple: fields {
		if: (doesTupleHasVariables(fields)) then: {
			tuple: fields withPropagationProtocol: noPropagationProtocol();
		} else:{
		  tuple: fields withPropagationProtocol: defaultPropagationProtocol(); 
	  };
	};
	
	def tuple: fields withPropagationProtocol: propagationProtocol {
		def tuple := makeTuple(TupleId.new(), @fields);
		tuple.super := propagationProtocol;
		tuple;
	};
  
  // creates an protocol object as follows:
  // - The object is initialized with the code of the argument closure.
  // - The object's dynamic parent is defaultPropagationProtocol.
  // - The object's types are initialized to Isolate, as it gets copied along with the tuple.
	def propagationProtocol: closure {
		extend: defaultPropagationProtocol() with: closure taggedAs: [/.at.lang.types.Isolate] mirroredBy: (
		   mirrorIsolate: { def print() {"<userDefinedPropagationProtocol>"}}	
	  );
	};
	
	def extendPropagationProtocol: protocol with: closure {
		extend: protocol with: closure taggedAs: [/.at.lang.types.Isolate] mirroredBy: (
			mirrorIsolate: { def print() {"<userDefinedPropagationProtocol>"}}	
		);
	};
	
	// returns an object with all meta-level operations for tuple propagation, 
	// implementing them using default semantics:
	// tuple which is always in scope and store itself in every hop.
	def defaultPropagationProtocol := &defaultPropagationProtocol;
	// returns an object implementing a leasing propagation protocol.
  def leasingPropagationProtocol := &leasingPropagationProtocol;
	
	// a variable is like a wildcard, "a hole" a tuple which always matches. 
	def var: symbol {
	  object: { |symbol|
		  def getSymbol(){symbol};
	  } taggedAs: [/.at.lang.types.Isolate, /.at.lang.types.Symbol];	
	};

	def TotamTest := extend: /.at.unit.test.UnitTest.new("TotamTest", false) with: {
		import /.at.lang.futures;
		enableFutures(false);
		def test := self;
		// definition of tuples and templates used in several tests.
		def aTemplate := tuple: [var: `x, 3, false];
		def makeATuple() {tuple: ["elisa", 3, false]};
		def helloTemplate := tuple: [var: `x, "hallo"];
		def blueProtocol := propagationProtocol: {
			def inScope(senderDescriptor, descriptor) { descriptor.team == "blue" };
		};
		def makeABlueTuple() { tuple: [123, "bomb"] withPropagationProtocol: blueProtocol};
		// tests functioning of pattern matching in in and rdp.
		def testLocalOutRdpInp(){
			def myTS := makeTupleSpace();
			// insert  tuple.
			myTS.out(makeATuple());
			// read a template for that tuple.
			def tuple := myTS.rdp( aTemplate );
			self.assertNotEquals(nil, tuple);
			self.assertEquals( tuple.getField(1), "elisa");
            self.assertEquals( tuple.getField(2), 3);
            self.assertEquals( tuple.getField(3), false);
            //read a template with two variables.
            def template2Vars := tuple: [var: `x, 3, var:`x];
			tuple := myTS.rdp( template2Vars );
			self.assertEquals(nil, tuple, "here");
			myTS.out( tuple:[false, 3, false]);
			tuple := myTS.rdp(template2Vars);
			self.assertNotEquals(nil, tuple);
			self.assertEquals( tuple.getField(1), false);
      self.assertEquals( tuple.getField(3), false);
      //as tuple space doesn't have a descriptor
      // an inject results in a add to the ts.
      def name := "joan";
      myTS.inject: (tuple: [name, "arnau"]);			
      tuple := myTS.rdp(tuple:[var:`name, var:`y]);
      self.assertNotEquals(nil, tuple);
			self.assertEquals( tuple.getField(1), "joan");
      self.assertEquals( tuple.getField(2), "arnau");
		};
		// tests behaviour of (when:whenever) reactions on read operation
		def testAsyncLocalOutWhenRead(){
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace();
			// insert  tuple.
			def it1 := 0;
			myTS.when: aTemplate read: {
				self.assertEquals("elisa", x);
				// read the tuple
			  self.assertNotEquals(nil, myTS.rdp( aTemplate));
			  it1 := it1 +1;
			};
			def it2 := 0;
			myTS.whenever: aTemplate read:{
				self.assertEquals("elisa", x);
				it2 := it2 +1;
			};
			myTS.out(makeATuple());
			//note makeaTuple creates a new tuple because each tuple has tupleId,
			// and passing aTuple here would try to insert twice the same tuple 
			myTS.out(makeATuple());
			timerModule.when: 1.seconds() elapsed:{
				self.assertEquals(1, it1);
				self.assertEquals(2, it2);
				res.resolve(`ok);
			};
		  fut;
		};
		// tests behaviour of (when:whenever) reactions on in operation 
		def testAsyncLocalOutWhenIn(){
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace();
			// insert  tuple.
			def it1 := 0;
			myTS.when: aTemplate in: {
				self.assertEquals("elisa", x);
			  it1 := it1 +1;
			};
			def it2 := 0;
			myTS.whenever: aTemplate in:{
				self.assertEquals("elisa", x);
				it2 := it2 +1;
			};
			myTS.out(makeATuple());
			myTS.out(makeATuple());
			timerModule.when: 1.seconds() elapsed:{
				self.assertEquals(2, it1 + it2);
				res.resolve(`ok);
			};
		  fut;
		};
		// tests that a halloTuple with defaultPropagationProtocol gets propagated one hop
		// even if descriptor is not the same.
		def testAsyncDefaultPropagationTuple() {
			def descriptor := isolate: { def team := "red"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
				
			myTS.when: helloTemplate read: { 
				self.assertEquals(123, x);	
				s.cancel();
				a<-resolve(res); 
			};
	
			def a := actor: { |TotamTupleSpaceT|
				def totamModule := /.at.lang.totam;
				def descriptor := isolate: { def team := "blue"; };	
				def aTS := totamModule.makeTupleSpace(descriptor);
			  // listen for people in the environment
				def s := whenever: TotamTupleSpaceT discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				// inject a tuple to neighbours
				aTS.inject: (totamModule.tuple: [123, "hallo"]);
				def resolve(res) {
					s.cancel();
					res<-resolve(`ok);
				};    		
		  };
			fut;
		};
		// test that a halloTuple with defaultPropagationProtocol has correct tupleIds.
		def testAsyncTupleIds() {
			def descriptor := isolate: { def team := "red"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := myTS.goOnline();
			def aTuple := makeATuple();
			self.assertFalse(aTuple.getTupleId().isInTupleSpace);	
			myTS.out(aTuple);
			self.assertTrue(aTuple.getTupleId().isInTupleSpace);

			def anotherTuple := makeATuple();
			myTS.out(anotherTuple);	
			// 2 diferent tuples!
			self.assertNotEquals(aTuple.getTupleId, anotherTuple.getTupleId);
			def myTsId := aTuple.getTupleId().getTupleSpaceId();
			// I should only receive once a hello tuple!
			def counter := 0;
			myTS.whenever: helloTemplate read: {
				counter := counter + 1; 
				self.assertEquals(123, x);	
				def tuple := myTS.rdp(helloTemplate);
				self.assertNotEquals(myTsId, tuple.getTupleId().getTupleSpaceId());
				timerModule.when: 2.seconds elapsed: {
					s.cancel();
					test.assertEquals(1, counter);
					a<-resolve(res);
				};
			};
			def a := actor: { |test|
				def totamModule := /.at.lang.totam;
				import /.at.lang.futures;
				enableFutures(false);
				def helloTemplate := totamModule.tuple: [totamModule.var: `x, "hallo"];
				def descriptor := isolate: { def team := "blue"; };	
				def aTS := totamModule.makeTupleSpace(descriptor);
			  def s := aTS.goOnline();
			  // insert a tuple locally
			  def aTuple := totamModule.tuple: [123, "hallo"];
			  aTS.out(aTuple); //insert locally
			  def aTsId := aTuple.getTupleId().getTupleSpaceId();
				// inject a tuple to neighbours
				aTS.inject: (aTuple);
				def counter := 0;
				// I should only receive once a hello tuple!
				aTS.whenever: helloTemplate read: {
					counter := counter + 1; 
					test<-assertEquals(123, x);	
					def tuple := aTS.rdp(helloTemplate);
					test<-assertEquals(aTsId, tuple.getTupleId().getTupleSpaceId());
				};
				def resolve(res) {
					s.cancel();
					when: test<-assertEquals(1, counter)@FutureMessage becomes: { |val|
						res<-resolve(`ok);
					};
				};    		
		  };
			fut;
		};
		// tests that a hallo tuple with a custom "one hop" propagation protocol works.
		def testAsyncOneHopTuple() {
			def descriptor := isolate: { def team := "blue"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
				
			myTS.when: helloTemplate read: {
				self.assertEquals(123, x);	
				s.cancel();
				a<-resolve(res);
			};
	
			def a := actor: { |TotamTupleSpaceT|
				def totamModule := /.at.lang.totam;
			  def descriptor := isolate: { def team := "blue"; };
			  def aTS := totamModule.makeTupleSpace(descriptor);
			  // listen for neighbour ts
				def s := whenever: TotamTupleSpaceT discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				def oneHopProtocol := totamModule.propagationProtocol: {
					 def hops := 0;
					 def inScope(senderD, receiverD) {hops <2};
					 def receiveTuple() { 
					   hops := hops + 1; 
					   self;
					 };
				};
				def oneHopTuple := totamModule.tuple: [123, "hallo"] withPropagationProtocol: oneHopProtocol;
				aTS.inject: oneHopTuple;
				//method trigering the end of test 
				def resolve(res) {
					s.cancel();
					// actor a should also have the hallo tuple because he is also in scope of this tuple
					def tuple := aTS.rdp(totamModule.tuple: [123, "hallo"]);
					if: (nil != tuple) then: { res<-resolve(`ok);}
				  else:{ res<-ruin(/.at.lang.exceptions.error("one-hop tuple not found in ts " + aTS))};

				};	
		  };		
			fut;
		};
		// tests that a hallo tuple with a custom propagation protocol targeting blue players.
		// As sender of the tuple is from the red team, it shouldn't get it.
		def testAsyncOnlyBluePlayersTuple() {
			def descriptor := isolate: { def team := "blue"; };
			def [fut,res] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
			myTS.when: helloTemplate read: {
				self.assertEquals(123, x);	
				s.cancel();
				a<-resolve(res);
			};
			def a := actor: { |TotamTupleSpaceT, blueProtocol|
				def totamModule := /.at.lang.totam;
				def descriptor := isolate: { def team := "red"; };
				def aTS := totamModule.makeTupleSpace(descriptor);
				def s := whenever: TotamTupleSpaceT discovered: { |ts|
						aTS.notifyTSDiscovered(ts);
				};
				def ablueTuple := totamModule.tuple: [123, "hallo"] withPropagationProtocol: blueProtocol;
				aTS.inject: ablueTuple;
				def resolve(res) {
					s.cancel();
					//check that the tuple it is indeed not in this ts.
					def tuple := aTS.rdp(totamModule.tuple: [123, "hallo"]);
					if: (nil == tuple) then: {res<-resolve(`ok);}
					else:{ res<-ruin(/.at.lang.exceptions.error("tuple received by a ts out of the tuple's scope!"))}
				};
	  	};		
			fut;
		};
    // tests that a halloTuple with defaultPropagationProtocol is injected with a timeout.
    // actor b is only online after the halloTuple is expired, so it shouldn't get it. 
		def testAsyncInjectWithLeaseFor() {
			def descriptor := isolate: { def team := "blue"; };
			def [fut,res] := makeFuture();
			def [fut2,res2] := makeFuture();
			def myTS := makeTupleSpace(descriptor);
			def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
      // install listener to read a hello tuple.
			myTS.when: helloTemplate read: {
				self.assertEquals(123, x);
			};
			when: fut2 becomes: { |v|
				s.cancel();
			  a<-resolve(res);
			};
			def b := actor: { |TotamTupleSpaceT, res2|
				def totamModule := /.at.lang.totam;
				def descriptor := isolate: { def team := "blue"; };
				def myTS := totamModule.makeTupleSpace(descriptor);
				def goOnline(){
				  def sub := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
				  /.at.support.timer.when: 2.seconds() elapsed:{
					   sub.cancel();
					   //try to read the tuple sent by a) which should have expired by now!
						 def tuple := myTS.rdp(totamModule.tuple: [123, "hallo"]);
						 if: (nil == tuple) then: { res2<-resolve(`ok);}
					   else: { res2<-ruin(/.at.lang.exceptions.error("tuple found in ts " + myTS))};
				  };
				};
			};
			def a := actor: { |TotamTupleSpaceT, b|
				def totamModule := /.at.lang.totam;			
				def descriptor := isolate: { def team := "red"; };
				def aTS := totamModule.makeTupleSpace(descriptor);
				def s := whenever: TotamTupleSpaceT discovered: { |ts|
					aTS.notifyTSDiscovered(ts);
				};
				def blueProtocol := totamModule.propagationProtocol: {
					def inScope(senderD, descriptor) { descriptor.team == "blue" };
				};
				def ablueTuple := totamModule.tuple: [123, "hallo"] withPropagationProtocol: blueProtocol;
				aTS.inject: ablueTuple timeout: 5.seconds();
				// myTs in unit test should receive this tuple.
				// myTS in actor b goes online only once the tuple is expired.
				/.at.support.timer.when: 5.seconds() elapsed:{ b<-goOnline()};
				def resolve(res) {
					s.cancel();
					res<-resolve(`ok);
				};	
			};		
      fut;
    }; //end-testAsyncInjectWithLeaseFor
				
		def testAsyncAntiTuple(){
			def [fut,res] := makeFuture();
			def [syncFut,syncRes] := makeFuture();
			def [sync2Fut,sync2Res] := makeFuture();
			def myTS := makeTupleSpace(isolate: { def team := "blue" });
			def s := myTS.goOnline();
			def template := tuple: [var: `x, "bomb"];
		  myTS.inject: makeABlueTuple;
		  when: syncFut becomes:{ |value|
				 def tuple :=  myTS.rdp(template);
         if: (tuple == nil) then:{
	         self.fail("originator should have the bomb!");
	       } else:{
			     player<-consumeBomb();
			   };
			} catch: {
				self.fail("ruined 1st synchronization future");
			};
			when: sync2Fut becomes:{ |value|
				def tuple :=  myTS.rdp(template);
				if: (tuple != nil) then:{ 
					self.fail("originator shouldn't have the bomb either!");
				} else:{ 
					res.resolve(`ok);
					s.cancel();	
				};	
			} catch: {
				self.fail("ruined 2nd synchronization future");
			};
			def anotherPlayer := actor: {  |syncRes, sync2Res|
			  deftype TotamTupleSpaceT;
				def totamModule := /.at.lang.totam;	
				def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
        //the bomb is present in the tuple space
        /.at.support.timer.when: 1.seconds() elapsed:{ 
	         def tuple :=  myTS.rdp(template);
           if: (tuple.getField(1) != 123) then:{
	 						syncRes<-ruin("anotherPlayer - read uncorrect bomb");
					 } else:{	syncRes<-resolve(`ok);};
        };
        //but now that the other player has consume it, it shouldn't be there anymore.
			  def searchForBomb(){
				  def tuple :=  myTS.rdp(template);
				  if: ( tuple != nil) then:{
					 sync2Res<-ruin("anotherPlayer shouldn't have found the bomb!");
				  } else:{
						sync2Res<-resolve(`ok);
					  s.cancel();
				  };
			  };
		  };
		  def originator := myTS;
			def player := actor: { |originator, anotherPlayer, test|
				import /.at.lang.futures;
				enableFutures(false);
				deftype TotamTupleSpaceT;
				def totamModule := /.at.lang.totam;	
			  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
        def consumeBomb(){
	        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
			 	  myTS.when: template read: {
				    def tuple := myTS.rdp(template);
					  when: test<-assertEquals(123, tuple.getField(1))@FutureMessage becomes:{ |val|
					    when: originator<-atomicRemove(tuple.getTupleId)@FutureMessage becomes:{|val|
						    anotherPlayer<-searchForBomb();
					      s.cancel();
					    };
					  };
					};
				};
		  };
		  fut;
		}; //end-testAsyncAntiTuple	
		
		def testAsyncAntiTupleLeased(){
			def [fut,res] := makeFuture();
			import /.at.lang.multifutures;
			def [syncFut,syncRes] := makeMultiFuture(3);
			def [sync2Fut,sync2Res] := makeMultiFuture(2);
			def myTS := makeTupleSpace(isolate: { def team := "blue" });
			def s := whenever: TotamTupleSpaceT discovered: { |ts|
				myTS.notifyTSDiscovered(ts);
			};
			def se := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
		  myTS.inject: makeABlueTuple timeout: 8.seconds();
			def originator := myTS;
			whenEach: syncFut becomes:{ |val|
			  if: (val ==1) then: { s.cancel()};	
			};
			def template := tuple: [var: `x, "bomb"];
		  whenAll: syncFut resolved:{ |value|
    	   //at this point this is the network configuration:
			   //originator: seenTS contains anotherPlayer, player
				 //player: seenTS contains originator, anotherPlayer, yetAnotherPlayer
				 //anotherPlayer: seenTS contains 0.
				 def tuple :=  myTS.rdp(template);
		     if: ( tuple == nil) then: { 
		       self.fail("originator should have the bomb!");
		     } else:{
			     self.assertEquals(123, tuple.getField(1));
			     player<-consumeBomb();
			   };
			} ruined: {
				self.fail("ruined 1st synchronization future");
			};
			whenAll: sync2Fut resolved:{ |value|
				// at this time 5 antituples are sent but yetAnotherPlayer would not propagate 
				//the antituple because it is already death
				def tuple :=  myTS.rdp(template);
				if: ( tuple != nil) then:{ 
					self.fail("originator shouldn't have the bomb either!");
				} else:{ 
					res.resolve(`ok);
					se.cancel();
				};	
			} ruined: { self.fail("ruined 2nd synchronization future") };
			
			def anotherPlayer := actor: {  |syncRes, sync2Res, TotamTupleSpaceT|
				def totamModule := /.at.lang.totam;
				def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
	      def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
	      //the bomb is present in the tuple space
	      def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
	      /.at.support.timer.when: 1.seconds() elapsed:{ 
	         def tuple :=  myTS.rdp(template);
					 if: (( tuple != nil).and:{ tuple.getField(1) != 123}) then:{ 
							syncRes<-ruin("anotherPlayer - read uncorrect bomb");
					 } else:{	syncRes<-resolve(`ok) };
	      };
	      //but now that the other player has consume it, it shouldn't be there anymore.
			  def searchForBomb(){
				  def tuple :=  myTS.rdp(template);
				  if: ( tuple != nil) then:{
					 sync2Res<-ruin("anotherPlayer shouldn't have found the bomb!");
				  } else:{
						sync2Res<-resolve(`ok);
					  s.cancel();
				  };
			  };		
		  }; //end-anotherPlayer	  
			def player := actor: { |originator, anotherPlayer, test, syncRes, sync2Res, TotamTupleSpaceT|
				import /.at.lang.futures;
				enableFutures(false);
				def totamModule :=/.at.lang.totam;
			  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
	      def s := export: myTS.getRemoteInterface() as: TotamTupleSpaceT;
	      def se := whenever: TotamTupleSpaceT discovered: { |ts|
					myTS.notifyTSDiscovered(ts);
				};
				def yetAnotherPlayer(){ 
					actor: {
					  deftype TotamTupleSpaceT;
						def totamModule :=/.at.lang.totam;
					  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
		        def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
						def read(res, firstRead := true) {
							def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
						  def tuple :=  myTS.rdp(template);
						  if: (tuple == nil) then: {
							  // no tuple found
							 	if: (firstRead) then: { res<-ruin("yetAnotherPlayer should have the bomb!")} else:{ res<-resolve(`ok); };
							} else: {
								if: (tuple.getField(1) == 123) then:{
					        if: (firstRead) then: { res<-resolve(`ok) }else:{ res<-ruin("yetAnotherPlayer 2 should have the bomb!") };
					      } else:{
					  	    // if you are here is because it was not firstRead (otherwise lenght ==)
									res<-ruin("yetAnotherPlayer got uncorrect bomb!");
							  };
							};     
						 myTS;
				    };
				  }; //end-actor
			  }; //end-yetAnotherPlayer
			/.at.support.timer.when: 1.seconds() elapsed:{
			  when: syncRes<-resolve(1)@FutureMessage becomes:{ |val|
					def player := yetAnotherPlayer();
					/.at.support.timer.when: 2.seconds() elapsed:{
				    when: player<-read(syncRes, true)@FutureMessage becomes:{|playerTs|
					    se.cancel();
					    //disconnect the far reference so that the antituple cannot be sent to yetAnotherPlayer;
					    def sub := disconnect: playerTs;
						  /.at.support.timer.when: 4.seconds() elapsed:{ 
				        sub.reconnect(); 
				        /.at.support.timer.when: 1.seconds() elapsed:{player<-read(sync2Res,false)};
				      };
				    };
				  };
				}};
		    def consumeBomb(){
			   def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
				  myTS.when: template read: { 
					  def tuple :=  myTS.rdp(template);
				    when: test<-assertEquals(123, x)@FutureMessage becomes:{ |val|
					    when: originator<-atomicRemove(tuple.getTupleId)@FutureMessage becomes:{|val|
					      anotherPlayer<-searchForBomb();
					      s.cancel();
					    };
					  };
					};
			  };
			};
		  fut;
		}; //end-testAsyncAntiTupleLeased 
		
		// test that a when:in over a remote tuple works.
		// uses the same scenario that the testAsyncAntiTuple 
		def testAsyncWhenInRemote(){
			def [fut,res] := makeFuture();
			def [syncFut,syncRes] := makeFuture();
			def [sync2Fut,sync2Res] := makeFuture();
			def myTS := makeTupleSpace(isolate: { def team := "blue" });
			def s := myTS.goOnline();
			def template := tuple: [var: `x, "bomb"];
		  myTS.inject: makeABlueTuple;
		  when: syncFut becomes:{ |value|
				 def tuple :=  myTS.rdp(template);
         if: (tuple == nil) then:{
	         self.fail("originator should have the bomb!");
	       } else:{
			     player<-consumeBomb();
			   };
			} catch: {
				self.fail("ruined 1st synchronization future");
			};
			when: sync2Fut becomes:{ |value|
				def tuple :=  myTS.rdp(template);
				if: (tuple != nil) then:{ 
					self.fail("originator shouldn't have the bomb either!");
				} else:{ 
					res.resolve(`ok);
					s.cancel();	
				};	
			} catch: {
				self.fail("ruined 2nd synchronization future");
			};
			def anotherPlayer := actor: {  |syncRes, sync2Res|
			  deftype TotamTupleSpaceT;
				def totamModule := /.at.lang.totam;	
				def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := export: myTS.getRemoteInterface as: TotamTupleSpaceT;
        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
        //the bomb is present in the tuple space
        /.at.support.timer.when: 1.seconds() elapsed:{ 
	         def tuple :=  myTS.rdp(template);
           if: (tuple.getField(1) != 123) then:{
	 						syncRes<-ruin("anotherPlayer - read uncorrect bomb");
					 } else:{	syncRes<-resolve(`ok);};
        };
        //but now that the other player has consume it, it shouldn't be there anymore.
			  def searchForBomb(){
				  def tuple :=  myTS.rdp(template);
				  if: ( tuple != nil) then:{
					 sync2Res<-ruin("anotherPlayer shouldn't have found the bomb!");
				  } else:{
						sync2Res<-resolve(`ok);
					  s.cancel();
				  };
			  };
		  };
		  def originator := myTS;
			def player := actor: { |originator, anotherPlayer, test|
				import /.at.lang.futures;
				enableFutures(false);
				deftype TotamTupleSpaceT;
				def totamModule := /.at.lang.totam;	
			  def myTS := totamModule.makeTupleSpace(isolate: { def team := "blue"});
        def s := myTS.goOnline;
        def consumeBomb(){
	        def template := totamModule.tuple: [totamModule.var: `x, "bomb"];
			 	  myTS.when: template in: {
					  when: test<-assertEquals(123, x)@FutureMessage becomes:{ |val|
						  anotherPlayer<-searchForBomb();
					    s.cancel();
					  };
					};
				};
		  };
		  fut;
		}; //end-testAsyncWhenInRemote 
		
		def testAsyncDiscovery(){
			def [fut,res] := makeFuture();
		  def [fut2,res2] := makeFuture();
			def myTS := makeTupleSpace();
			def sub := myTS.goOnline();	
			def a := actor: { |res2|
				import /.at.lang.totam;
				deftype TotamTupleSpaceT;
				def myTS := makeTupleSpace();
				def sub; def disc;  
				def goOnlineHard() {sub := export: myTS.getRemoteInterface as: TotamTupleSpaceT;}; 
				def goOnlineSoft(){ disc.reconnect() }; 
				def goOfflineSoft(){ disc :=  disconnect: myTS.getRemoteInterface; };
				def goOfflineHard(){
					sub.cancel();
					def tuple := myTS.rdp(tuple: [var: `x, 3, false]);
					if: (nil != tuple) then: { 
						res2<-ruin(/.at.lang.exceptions.error("unexpected received tuple"));
					} else: { res2<-resolve(`ok) };
				};
			};
			//start test
			def discoveredId;
			when: a<-goOnlineHard()@FutureMessage becomes:{ |val|
			  timerModule.when: 2.seconds() elapsed:{
				  def seenTs := (myTS.dumpContents())[3]; 
			  	discoveredId := (seenTs[1])[1]; 
				  self.assertEquals(1, seenTs.length);  
			    when: a<-goOfflineSoft()@FutureMessage becomes:{ |val|
				    myTS.inject: makeATuple() timeout: 1.seconds();
				    //wait until it is expired
				    timerModule.when: 2.seconds() elapsed:{
				      when: a<-goOnlineSoft()@FutureMessage becomes:{ |val|
							  // give sometime for the reconnect event.
					      timerModule.when: 2.seconds() elapsed: {
					        when: a<-goOfflineHard()@FutureMessage becomes:{ |val|
						         //test ok
						        nil;
						      };
						    };
						  };
						};
					};
				};
			};
			when: fut2 becomes: { |val|
			  def seenTs := (myTS.dumpContents())[3]; 
				self.assertEquals(1, seenTs.length);
				self.assertEquals(discoveredId,(seenTs[1])[1]);
				sub.cancel();
				res.resolve(`ok);
			} catch: /.at.lang.types.Exception using: { |e| 
				res.ruin(e);
			};
			fut;
		}; //end-testAsyncDiscovery
	};
};