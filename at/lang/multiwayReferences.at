import /.at.collections.java.hashset;
import /.at.collections.java.hashmap;

import /.at.lang.futures;
enableFutures(false);
import /.at.exceptions;

import /.at.lang.firstclassrefs;

deftype Unimplemented <: /.at.types.Exception;
def XUnimplemented := /.at.exceptions.createException(Unimplemented);
def abstractMethod(name) {
	raise: XUnimplemented.new("Invoked abstract method: "+name);
};


deftype MultiWayReference;

// utilities

def DEBUG_MW := true;

def debug(@args) {
	if: DEBUG_MW then: {
		system.println("[multiwayrefs.at] ", args);
	};
};

// filter and accessor for remoteRefs with attached serial

// the default content filter
def defaultFilter := { |props| true };

deftype NotIdentifiedBySerial <: lobby.at.types.Exception;
def XNotIdentifiedBySerial := lobby.at.exceptions.createException(NotIdentifiedBySerial);

def identifiedBySerialFilter(props) {
	//!(nil == props);
	if: (nil == props) then: {
		false;
	} else: {
		try: {
			def serial := props.serial;
			true;
		} catch: Types.SelectorNotFound using: {|e| 
			// do nothing
			debug("props selector not found: " + e.message); 
			false;
		};
		
	};
};

def identifiedBySerial(remoteRef) {
	def props := isolate: { nil };
	if: (is: remoteRef taggedAs: /.at.types.Table) then: {
		props := remoteRef[1];
		remoteRef := remoteRef[2];
	};
	identifiedBySerialFilter(props);
};

def getSerial(remoteRef) {
	def props := isolate: { nil };
	if: (is: remoteRef taggedAs: /.at.types.Table) then: {
		props := remoteRef[1];
		remoteRef := remoteRef[2];
	};
	if: identifiedBySerialFilter(props) then: {
		props.serial;
	} else: {
		debug("Remote reference has no associated serial: " + remoteRef + " (this should not happen!)");
		raise: XNotIdentifiedBySerial.new("Remote reference has no associated serial: " + remoteRef);
	};
};


// the mirror to construct multiWayReferences


def multiWayReferenceMirror :=  mirror: {
	import TEventualRef exclude pass, invoke;//, retractUnsentMessages;
	import TObservable alias init := initObservable;
	
	def connected := false;
	def inbox := [];
	def currentReference := nil;
	def connectedReferences := HashSet.new;
	def disconnectedReferences := HashSet.new;

	def init(base, reference){
		super^init(base);
		
		// initialize the observable trait, this will provide
		// the 'observerCatalog' object with two fields storing this
		// object's observers
		self.initObservable(`disconnection, `reconnection, `takenOffline); //, `replacement);
		
		addReference(reference);		
	};

	def addReference(reference, isConnected := true) {
		// add the reference to the correct set
		if: isConnected then: {
			disconnectedReferences.remove(reference);
			connectedReferences.add(reference);
		} else: {
			connectedReferences.remove(reference);
			disconnectedReferences.add(reference);
		};
		
		// adjust connected state and current reference
		if: (!connected).and: { connectedReferences.notEmpty() } then: {
			connected := true;
			currentReference := connectedReferences.first();
		};
		inbox.each: { |msg| reference <+ msg };
		inbox := [];
		
		// disconnected listener
		whenever: reference disconnected:{
			connectedReferences.remove(reference);
			disconnectedReferences.add(reference);
			if: (connected).and: { connectedReferences.isEmpty() } then: {
				connected := false;
			} else: {
				if: (reference == currentReference) then: {
					currentReference := connectedReferences.first();
				};
			};
			def outbox := retract: reference;
			inbox := inbox + outbox;
		};
		
		// reconnecter listener
		whenever: reference reconnected: {
			disconnectedReferences.remove(reference);
			connectedReferences.add(reference);
			if: (!connected).and: { connectedReferences.notEmpty() } then: {
				connected := true;
				currentReference := connectedReferences.first();
			};
			inbox.each: { |msg| reference <+ msg };
			inbox := [];
		};
	};

	def asFarRef(){ currentReference };
	
	def intercept(msg) { 
		if: self.connected then: { 
			currentReference <+ msg;
		} else: { 
			inbox := inbox + [msg];
		};
	};
	
	def toString() { "MultiWayReference: " + currentReference };		
	
	// def transportStrategy; // not needed: proxy is pass-by-far-reference
	
	def retractUnsentMessages() { 
		def return := inbox; 
		inbox := [];
		return;
	};
	
	//override equality
	// disallow synchronous access to the object
	def invoke(slf, inv) {
		// the only legal operation on references is '=='
		if: (`(==) == inv.selector) then: {
			// two delayed serialization refs are equal iff the far ref encapsulate are equal.
			currentReference == (reflect: (inv.arguments)[1]).asFarRef();
		} else: {
			raise: XIllegalOperation.new("Cannot synchronously invoke " + inv.selector + " on " + self.dumpContent());
		};
		/*	def name := /.at.support.util.makeMutator(`==);
		def mutMethod := createMethod(name, [ `aRef ], `{ reference == (reflect: aRef).getFarRef() }, []);
		self.removeSlot(name);
		self.addSlot(createClosureMethod(self.base, mutMethod));*/
	};
	
	def pass() {
		super^pass();
	};
	
	// a multiway reference has four kinds of observers: disconnection,
	// reconnection, takenOffline and replaced observers
	//import TObservable alias init := initObservable;
	
		
	def addConnectionObserver(obs) {
		self.addObserver: obs to: self.observerCatalog.connection;
	};

	def addDisconnectionObserver(obs) {
		self.addObserver: obs to: self.observerCatalog.disconnection;
	};
	
	//def addReplacementObserver(obs) {
	//	self.addObserver: obs to: self.observerCatalog.replacement;
	//};
	
	def addTakenOfflineObserver(obs) {
		self.addObserver: obs to: self.observerCatalog.takenOffline;
	};
	
};

def createMultiWayReference: reference {
	object: { } taggedAs: [MultiWayReference] mirroredBy: { |base| multiWayReferenceMirror.new(base, reference)};
};

// copies of native functions

def nativeWhenever: serviceType discovered: code {
	whenever: serviceType discovered: code
};

def nativeWhenever: farref disconnected: code {
	whenever: farref disconnected: code
};

def nativeWhenever: farref reconnected: code {
	whenever: farref reconnected: code
};

def nativeWhenever: farref replaced: code {
	whenever: farref replaced: code
};

def nativeExport: obj as: type {
	export: obj as: type;
};

def nativeLet: newObject become: obj {
	let: newObject become: obj;
};

// the multiWayReferenceModule

def MultiWayReferenceModule := object: {
	
	def multiWayReferences := HashMap.new;
	
	def referenceTypes := "multiWayReferences";
	
	def whenever: serviceType discovered: code {
		nativeWhenever: serviceType discovered: { |farReference|
			if: identifiedBySerial(farReference) then: {
				def serial := getSerial(farReference);
				def multiWayRef := multiWayReferences.get(serial);
				if: (multiWayRef == nil) then: {
					(reflect: multiWayRef).addReference(farReference);
				} else: {
					multiWayRef := createMultiWayReference(farReference);
				};
				code(multiWayRef);
			} else: {
				code(farReference);
			};
		};
	};
	
	// if multiWayReference is indeed a multiway reference, add an observer,
	// otherwise perform the default behaviour
	def whenever: multiWayReference disconnected: code {
		if: (is: multiWayReference taggedAs: MultiWayReference) then: {
			(reflect: multiWayReference).addDisconnectionObserver(code);
		} else: {
			nativeWhenever: multiWayReference disconnected: code
		};
	};
	
	// if multiWayReference is indeed a multiway reference, add an observer,
	// otherwise perform the default behaviour
	def whenever: multiWayReference reconnected: code {
		if: (is: multiWayReference taggedAs: MultiWayReference) then: {
			(reflect: multiWayReference).addConnectionObserver(code);
		} else: {
			nativeWhenever: multiWayReference reconnected: code
		};
	};
	
	// if multiWayReference is indeed a multiway reference, add an observer,
	// otherwise perform the default behaviour
	//def whenever: multiWayReference replaced: code {
	//	if: (is: multiWayReference taggedAs: MultiWayReference) then: {
	//		(reflect: multiWayReference).addReplacementObserver(code);
	//	} else: {
	//		nativeWhenever: multiWayReference replaced: code
	//	};
	//};
	
		// if multiWayReference is indeed a multiway reference, add an observer,
	// otherwise perform the default behaviour
	def whenever: multiWayReference takenOffline: code {
		if: (is: multiWayReference taggedAs: MultiWayReference) then: {
			(reflect: multiWayReference).addTakenOfflineObserver(code);
		} else: {
			nativeWhenever: multiWayReference takenOffline: code
		};
	};
	
	// allow exporting an object together with a set of properties
	def export: serviceObject as: type with: clo {
		def props := isolate: clo;
		nativeExport: [props, serviceObject] as: type;
	};

  // override export:as: to include a property object
	def export: serviceObject as: type {
		export: serviceObject as: type with: { nil };
	};
	
	def export: serviceObject as: type identifiedBy: identifier {
		export: serviceObject as: type with: { def serial := identifier };
	};
	
	def let: newObject become: obj {
		if: (is: obj taggedAs: /.at.types.Table) then: {
			if: (is: newObject taggedAs: /.at.types.Table) then: {
				// if both are tables
				// do nothing
				// XXX we might merge the tables
				nativeLet: newObject become: obj;
			} else: {
				// reuse props of original
				nativeLet: [obj[1], newObjectobj] become: obj;
			};
		} else: {
			nativeLet: newObjectobj become: obj;
		};
	};

};

