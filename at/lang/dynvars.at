/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * Dynamic Variables. Usage:
 * - defining a dynamic variable:
 *   <tt>defdynamic: `name init: value</tt>
 *  If the variable already exists, a DuplicateDynamicVariable exception is raised.
 * - reading the value of a dynamic variable:
 *   <tt>? `name</tt>
 *  If the variable does not exist, an UndefinedDynamicVariable exception is raised.
 * - setting the value of a dynamic variable within a limited scope:
 *   <tt>with: `name is: newval do: { code }</tt>
 *  When the code terminates (normally or via an exception), the dynamic variable is
 *  automatically reset to its previous value.
 *  If the variable does not exist, an UndefinedDynamicVariable exception is raised.
 * @author tvcutsem
 */

// The store of dynamic variables. Note that this is an actor-local map,
// so race conditions will never occur. Because of our actor paradigm,
// dynamic variables are automatically 'thread-local'.
def DynVars := jlobby.java.util.HashMap.new();

def DynamicVariable := object: {
	def values := nil;
	def init(initVal) {
		values := [initVal]
	};
	def get() { values[1] };
	def set(newVal) {
		def oldValues := values;
		values := [newVal, oldValues];
		object: {
			def unset() { values := oldValues }
		};
	};
};

deftype UndefinedDynamicVariable <: /.at.types.Exception;
def XUndefinedDynamicVariable := extend: /.at.exceptions.createException(UndefinedDynamicVariable) with: {
	def variableName := `none;
  def init(var) {
	  variableName := var;
	  super^init("Undefined dynamic variable: " + var);
  };
};

deftype DuplicateDynamicVariable <: /.at.types.Exception;
def XDuplicateDynamicVariable := extend: /.at.exceptions.createException(DuplicateDynamicVariable) with: {
	def variableName := `none;
  def init(var) {
	  variableName := var;
	  super^init("Duplicate dynamic variable: " + var);
  };
};

def getDynamicVar(nam) {
	def dynVar := DynVars.get(nam);
	if: (nil != dynVar) then: {
		dynVar
	} else: {
		raise: XUndefinedDynamicVariable.new(nam)
	}
};

def setDynamicVar(nam, dynvar) {
	def dynVar := DynVars.get(nam);
	if: (nil == dynVar) then: {
		DynVars.put(nam, dynvar);
	} else: {
		raise: XDuplicateDynamicVariable.new(nam)
	}
};

def DynVarModule := object: {

  def UndefinedDynamicVariable := UndefinedDynamicVariable;
  def DuplicateDynamicVariable := DuplicateDynamicVariable;

  def defdynamic: nameSymbol init: value {
	  setDynamicVar(nameSymbol, DynamicVariable.new(value));
  };

  def ?(name) {
	  getDynamicVar(name).get()
  };

  def with: name is: newval do: closure {
	  def unsetter := getDynamicVar(name).set(newval);
	  try: closure finally: unsetter.&unset;
  };

  def DynVarTest() {
	  extend: /.at.unit.test.UnitTest.new("DynamicVariablesTest") with: {
		  def testBasicAccess() {
			  defdynamic: `foo init: 5;
			  self.assertEquals(5, ?`foo);
		  };
		  def testUndefinedVar() {
			  self.assert: UndefinedDynamicVariable raisedIn: { ?`bla };
		  };
		  def testDuplicateVar() {
			  self.assert: DuplicateDynamicVariable raisedIn: {
				  defdynamic: `baz init: 1;
				  defdynamic: `baz init: 2;
			  };
		  };
		  def testScopedAssignment() {
			  defdynamic: `testVar init: 1;
			  self.assertEquals(1, ?`testVar);
			  with: `testVar is: 2 do: {
				  self.assertEquals(2, ?`testVar);
			  };
			  self.assertEquals(1, ?`testVar);
		  };
		  def testScopedAssignmentWithException() {
			  defdynamic: `testVar2 init: 1;
			  self.assertEquals(1, ?`testVar2);
			  
			  deftype EscapeException;
			  try: {
				  with: `testVar2 is: 2 do: {
				    self.assertEquals(2, ?`testVar2);
				    raise: /.at.exceptions.createException(EscapeException);
			    };
			  } catch: EscapeException using: { |e|
				  self.assertEquals(1, ?`testVar2);
				}
		  };
	  };
  };

};