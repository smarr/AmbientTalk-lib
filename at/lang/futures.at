/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* The meta-level implementation of the futures language construct */

// import Exception type, used for catching exceptions
def Exception := /.at.types.Exception;
def Isolate := /.at.types.Isolate;

// importing leasing constructs, used for automatically ruining futures after certain timeout.
def LeasingModule := /.at.lang.leasedrefs;

// a future can be in one of these three states
def UNRESOLVED := 0;
def RESOLVED := 1;
def RUINED := 2;

// all future objects are marked with this type
deftype Future;

// all future-carrying messages are marked with this type
deftype FutureMessage;

// type that signifies that no future should be attached to a message
deftype OneWayMessage;

// Addition for the integration of leasing and futures:

// type that signifies that futures objects are leased for a given timeout
deftype DueType <: FutureMessage; 

def Due(timeout) {
	extend: DueType with: { |timeout|
		nil;
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};
//create TimeoutException used for notifying the ruining of a future when its lease expires. 
deftype TimeoutException <: Exception;
def XTimeoutException := extend: /.at.exceptions.createException(TimeoutException) with: {
	 def future := nil;
	 def init(fut){ 
		super^init("Future: " + fut + " timed out");
		future := fut
	 };
	 def getFuture() { future };
};


// To register a when-observer on a future, a message needs to be sent to its mirror
// This would only be possible on far references to futures if an explicit additional
// far reference to its mirror would be passed. This restriction is avoided through the
// introduction of a MetaMessage type: messages typed with it will be handled by the
// future's mirror rather than being forwarded to the actual principal when the future is resolved.
def MetaMessage := /.at.lang.firstclassrefs.MetaMessage;
def TFarRef := /.at.lang.firstclassrefs.TFarRef;

// the mirror of a Future object
def FutureMirror := mirror: {
	// initialize the state of the prototype
	def state := UNRESOLVED;
	def resolvedValue := nil;
	def inbox := [];
	def subscribers := [];

  // a future is a special kind of far reference
  // therefore, this mirror mixes in the 'far reference' behaviour
  // Because a future is pass-by-reference, we do not inherit the
  // parameter-passing behaviour of the far ref trait
  import TFarRef exclude pass;

	// constructor: used to initialize the state of the new future
	def init(@args) {
		super^init(@args); // initialize this future's base field
		state := UNRESOLVED;
		resolvedValue := nil;
		inbox := [];
		subscribers := [];
	};

	def resolve(value) {
		// is the future resolved by another future?
		if: (is: value taggedAs: Future) then: {
			// register this future as a listener with the resolved future value
			value<-addResolutionListener(object: {
				def notifyResolved(val) {
					// re-resolve this future with the actual value
					resolve(val);
				};
				def notifyRuined(exc) {
					// ruin this future
					ruin(exc);
				}
		  // note that <-addResolutionListener is a message directed to the future's mirror
		  // and that no future return value is required
			})@[MetaMessage, OneWayMessage];
		} else: {
			if: (state == UNRESOLVED) then: {
				state := RESOLVED;
				resolvedValue := value;
				inbox.each: { |msg| value <+ msg };
				inbox := [];
				subscribers.each: { |sub| sub<-notifyResolved(value)@OneWayMessage };
				subscribers := [];
			};	
		};
		nil;
	};

	def ruin(exception) {
		if: (state == UNRESOLVED) then: {
			state := RUINED;
			resolvedValue := exception;
			inbox.each: { |msg|
				if: (is: msg taggedAs: FutureMessage) then: {
					msg.resolver<-ruin(exception)@OneWayMessage;
				};
			};
			inbox := [];
			if: (subscribers.isEmpty) then: {
				// warning to ease debugging when something goes wrong in a future that's never accessed
				system.println("[futures.at] Warning: future has no listeners to catch exception: " + exception);
			} else: {
				subscribers.each: { |sub| sub<-notifyRuined(exception)@OneWayMessage };
				subscribers := [];	
			}
		};
		nil;
	};

	// adds a resolution listener to the future
	// @param sub a resolution listener
	def addResolutionListener(sub) {
		// if future has already been resolved/ruined, notify listener immediately
		if: (state == RESOLVED) then: {
			sub<-notifyResolved(resolvedValue)@OneWayMessage;
		} else: {
			if: (state == RUINED) then: {
				sub<-notifyRuined(resolvedValue)@OneWayMessage;
			} else: {
			  subscribers := subscribers + [ sub ];	
			}
		};
		nil;
	};

	// provide the required methods for the TFarRef trait
	
	def intercept(msg) {
		// msg received by a resolved future? forward the message
		if: (state == RESOLVED) then: {
			resolvedValue <+ msg;
		} else: {
			if: (state == RUINED) then: {
				(is: msg taggedAs: FutureMessage).ifTrue: {
					msg.resolver<-ruin(exception)@OneWayMessage;
				};
			}	else: {
				// accumulate message in this future's inbox
				inbox := inbox + [msg];
				nil;
			};
		};
	};

	def toString() {
		if: (state == RESOLVED) then: {
			  "resolved future:" + resolvedValue;
		} else: {
			if: (state == RUINED) then: {
				"ruined future:" + resolvedValue;
			}	else: {
				"unresolved future";
			};
		};
	};
	
	// to satisfy the required interface of TFarRef, not really required
	def transportStrategy := { };
};

def makeFuture(timeout := nil) {
	// futures are empty objects mirrored by a future mirror
	// note that the future mirror is implicitly instantiated for each new future!
	def fut := object: { nil } taggedAs: [ Future ] mirroredBy: FutureMirror;

	//by default futures are not leased.
	def resolver := object: {
		def resolve(val) { (reflect: fut).resolve(val) };
		def ruin(exc) { (reflect: fut).ruin(exc) };
		def future := fut;
	};

	// has the future been annotated with DueType?
	if: !(nil == timeout) then: {
		// if so, wrap resolver into a single-call lease
		resolver := LeasingModule.singleCallLease: timeout for: resolver;
		LeasingModule.when: resolver expired: {
			(reflect: fut).ruin(XTimeoutException.new(fut));
		};
	};

	[ fut, resolver ];
};

// extend a regular asynchronous message with futures behaviour
def futurize(msg) {  
	// attach the resolver for a future to the message
	def type := FutureMessage;
	def [future, resolver];
	// integration of futures with leasing
	if: (is: msg taggedAs: DueType) then: {
		type := DueType;
		def ann := /.at.support.util.getAnnotationOfType(msg, DueType);
		[future, resolver] := makeFuture(ann.timeout);
	}
	else: {
		// by default, make a future without timeout
		[future, resolver] := makeFuture();
	};

	// extend default message with FutureMessage behaviour
	extend: msg with: { |resolver, OneWayMessage|

		// the process method is invoked when an async message arrives
	  def process(behaviour) {
			try: {
				// delegate to parent to actually invoke the method
				def result := super^process(behaviour);

				// if everything goes right, resolve the attached future
				// replace the placeholder symbol with the actual result
				resolver<-resolve(result)@OneWayMessage;

				result;

			// note that we need to qualify the full path to the Exception type:
			// the Exception variable defined above is out of scope since this message is an isolate!
			} catch: /.at.types.Exception using: { |e|
				resolver<-ruin(e)@OneWayMessage;

				// re-raise the caught exception
				raise: e;
			};
		};
	} taggedAs: [ type ]; 
};

// should future-type message sending be supported for default (unannotated) messages?
def enableFuturesOnDefaultMessages := false;

// this object is returned when this file is loaded, hence
// it is the public interface to code defined in this file
def FuturesModule := object: {
	// support for first-class futures: returns a pair
	// [ future, resolver]. The resolver can be used to easily resolve
	// or ruin the corresponding future
    def makeFuture := &makeFuture;

	// when-catch support, version without a catch block
	def when: future becomes: resolvedBlock {
		when: future becomes: resolvedBlock catch: Exception using: { |e|
			system.println("[futures.at] Warning: uncaught exception because no catch-clause specified: " + e);
		}
	};

  // when-catch support, version with one generic catch-all block
	def when: future becomes: resolvedBlock catch: excBlock {
		when: future becomes: resolvedBlock catch: Exception using: excBlock
	};

	// when-catch support, version with one specific catch block
	def when: future becomes: resolvedBlock catch: excType using: excBlock {
		def [whenFuture,resolver] := makeFuture();
		def notify(block, val) {
			try: {
				resolver.resolve(block(val));				
			} catch: Exception using: {|e|
				resolver.ruin(e);
			};
			nil;
		};
		future<-addResolutionListener(object: {
			def notifyResolved(val) { notify(resolvedBlock, val); };
			def notifyRuined(exc) {
				if: (is: exc taggedAs: excType) then: {
					notify(excBlock, exc);
				} else: {
					system.println("[futures.at] Warning: uncaught exception: " + exc + ". Can only cath: " + excType);
				};
			};
		// note that <-addResolutionListener is a message directed to the future's mirror
		// and that no future return value is required
		})@[MetaMessage, OneWayMessage];
		whenFuture; // when returns a future itself
	};

  // groups a table of futures into a single future which is resolved
  // with a table of values or ruined with an exception
	// when: (group: [ a<-m(), b<-n() ]) becomes: { |values| ... }
	def group: futures {
		def [futForAll, res] := makeFuture();
		def resolutions[futures.length] { nil };
		def nextUnresolved := 0;
		futures.each: { |future|
			when: future becomes: { |val|
				nextUnresolved := nextUnresolved + 1;
				resolutions[nextUnresolved] := val;
				if: (nextUnresolved == futures.length) then: {
					res.resolve(resolutions);
				};
			} catch: { |e|
				res.ruin(e); // ! only first exception is propagated
			};
		};
		futForAll;
	};
	
	/**
	 * future: { |return|
	 *   // some computation
	 *   return(val)
	 * }
	 *
	 * is equivalent to the slightly more verbose
	 * def [fut,res] := makeFuture();
	 * try: { // some computation
	 *        res.resolve(val);
	 * } catch: Exception using: { |e| res.ruin(e) }
	 * fut;
	 */
	def future: closure {
		def [fut,res] := makeFuture();
		try: {
			closure({|val| res.resolve(val)});
	  } catch: /.at.types.Exception using: { |e| res.ruin(e) };
		fut;
	};

  // make the Future type publicly visible
  def Future := Future;

  // make the OneWayMessage type publicly visible
  def OneWayMessage := OneWayMessage;

  // make the FutureMessage type publicly visible
  def FutureMessage := FutureMessage;

  //make the Due function publicly visible 
  def Due := &Due;

  //make visible the exception raised when futures are ruined by timeout.
  def TimeoutException := TimeoutException;

  // type that identifies this language module
  deftype FuturesModule;

	// install the futures protocol on the invoking actor,
	// returns the previously active protocol
	// the optional argument indicates whether futures should be enabled on unannotated messages
	// by default, futures are not enabled on unannotated messages
	def enableFutures(enabledByDefault := false) {
		
		// can only change this default from 'false' to 'true'
		// once set to 'true', the default may no longer change
		// (as it may break existing code that relies on implicit futures)
		if: ((!enableFuturesOnDefaultMessages).and: {enabledByDefault}) then: {
			system.println("[futures.at] futures are now enabled by default on " + actor);
			enableFuturesOnDefaultMessages := enabledByDefault;
		};
		
		// do not load the futures module twice!
		if: !(is: actor taggedAs: FuturesModule) then: {
			// before installing changes to the creation of messages, create messages that will be used internally
			// to resolve or ruin the futures. If these messages are not created up front they will be subject to 
			// the futures protocol themselves, resulting in an endless cycle of messages if the receiver also has
			// futures enabled.
			system.println("[futures.at] enabling futures on actor " + actor + " (default = " + enabledByDefault + ")");

			// the futures protocol by default extends the currently active protocol
			actor.install: (extend: actor with: {
				def createMessage(sel, args, types) {
					// first, create a regular message
					def msg := super^createMessage(sel, args, types);
					// do we need to support futures by default on all messages?
					if: enableFuturesOnDefaultMessages then: {
						// if the message was annotated with OneWayMessage type, override this behaviour
						// and simply return the regular message
						if: (is: msg taggedAs: OneWayMessage) then: {
							// default = FutureMessage, overridden by OneWayMessage, so return normal message
							msg;
						} else: {
							// default= FutureMessage or overriden by DueType, so attach future behaviour
							futurize(msg);
						}
					} else: {
						// if the message was explicitly annotated with FutureMessage type, activate
						// the futures behaviour
						if: (is: msg taggedAs: FutureMessage) then: {
							// default = OneWayMessage, overridden by FutureMessage or DueType, so attach future behaviour
							futurize(msg);
						} else: {
							// default = OneWayMessage, so return the normal message
							msg;
						}
					}
				};
			
			  def send(rcv, msg) {
				  def result := super^send(rcv, msg);
				  // for a future message, the return value now becomes the message's future
				  if: (is: msg taggedAs: FutureMessage) then: {
					  //for a future message tagged with a timeout, the return value has to be accessed via the leased reference  
					  if: (is: msg taggedAs: DueType) then: {
						  (reflect:  msg.resolver).getPrincipal().future;
					  } else: {
					    msg.resolver.future;
					  }
				  } else: {
					   result;
				  };
			  };	
		  } taggedAs: [ FuturesModule ]);
	  } else: {
		  actor; // return the current actor protocol
	  };
  };

 	def millisec(ms) { LeasingModule^millisec(ms) };
	def seconds(s) { LeasingModule^seconds(s) };
	def minutes(m) { LeasingModule^minutes(m) };
  
  def FuturesTest() {
   extend: /.at.unit.test.UnitTest.new("futures test") with: {
    enableFutures(false);

    def foo() { 5 };    
    
    def testFutureCreation() {
      def [fut,res] := makeFuture();
      self.assertEquals("<unresolved future>", print: fut);
      res.resolve(5);
      self.assertEquals("<resolved future:5>", print: fut);
    };
    
    def testFutureSend() {
      def fut := &foo<-apply([])@FutureMessage;
      self.assertNotNil(fut);
      self.assertTrue(is: fut taggedAs: Future);
    };
    
    def testAsyncWhen() {
      when: &foo<-apply([])@FutureMessage becomes: { |v|
        self.assertEquals(5,v);
      };
    };

    def testAsyncGroup() {
	    def o := object: {
			  def m() { 5 };
			  def n() { 6 };
			};
			def f := group: [ o<-m()@FutureMessage, o<-n()@FutureMessage ];
			when: f becomes: { |vals|
				self.assertEquals(2, vals.length);
				self.assertEquals(11, vals[1]+vals[2]);
			};
    };

		def testAsyncDue(){
			
			def a := actor: {
				deftype Test;
				def service := object: {
					def test() { 5 };
				} mirroredBy: ( mirror:{
					//intercepting the message so that it's never received and thus, 
					//the future will be eventually ruined.
					def receive(msg) {
					 	(msg.selector	== `(test)).ifFalse: {
					  	super^receive(msg);
					 	};
					};
				});
				export: service as: Test;
			};
			
			deftype Test;
      
		  def ref := /.at.lang.ambientrefs.ambient: Test;
			def future := ref<-test()@Due(LeasingModule.seconds(1));
			when: future becomes: { |v|
		  	fail("Unexpected resolved future");
		  } catch: TimeoutException using: { |e|
				self.assertEquals(e.getFuture(), future);
      };
		};
   };
  };
};


