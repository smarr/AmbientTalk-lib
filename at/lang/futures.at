/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* The meta-level implementation of the futures language construct */

// import Exception type, used for catching exceptions
def Exception := /.at.types.Exception;
def Isolate := /.at.types.Isolate;

// importing leasing constructs, used for automatically ruining futures after certain timeout.
def LeasingModule := /.at.lang.leasedrefs;
def TimerModule := /.at.support.timer;

// a future can be in one of these three states
def UNRESOLVED := 0;
def RESOLVED := 1;
def RUINED := 2;

// all future objects are marked with this type
deftype Future;

// all future-carrying messages are marked with this type
deftype FutureMessage;

// type that signifies that no future should be attached to a message
deftype OneWayMessage;

// Addition for the integration of leasing and futures:

// type that signifies that futures objects are leased for a given timeout
deftype DueType <: FutureMessage; 

def Due(timeout) {
	extend: DueType with: { |timeout|
		nil;
	} taggedAs: [/.at.types.Isolate, /.at.types.TypeTag ];
};
//create TimeoutException used for notifying the ruining of a future when its lease expires. 
deftype TimeoutException <: Exception;
def XTimeoutException := extend: /.at.exceptions.createException(TimeoutException) with: {
	 def init(future, receiver := nil, message := nil){
		 if: (receiver == nil) then: {
			 super^init("Future: " + future + " timed out");			
		 } else: {
			 super^init("Future: " + future + " timed out while sending " + message.selector + " to " + receiver);
		 }
	 };
};

// To register a when-observer on a future, a message needs to be sent to its mirror
// This would only be possible on far references to futures if an explicit additional
// far reference to its mirror would be passed. This restriction is avoided through the
// introduction of a MetaMessage type: messages typed with it will be handled by the
// future's mirror rather than being forwarded to the actual principal when the future is resolved.
def MetaMessage := /.at.lang.firstclassrefs.MetaMessage;
def TFarRef := /.at.lang.firstclassrefs.TFarRef;

// the mirror of a Future object
def FutureMirror := mirror: {
	// initialize the state of the prototype
	def state := UNRESOLVED;
	def resolvedValue := nil;
	def inbox := [];
	def subscribers := [];

  // a future is a special kind of far reference
  // therefore, this mirror mixes in the 'far reference' behaviour
  // Because a future is pass-by-reference, we do not inherit the
  // parameter-passing behaviour of the far ref trait
  import TFarRef exclude pass;
  
	// constructor: used to initialize the state of the new future
	def init(@args) {
		super^init(@args); // initialize this future's base field
		state := UNRESOLVED;
		resolvedValue := nil;
		inbox := [];
		subscribers := [];
	};

  // Using resolveWithValue(value) rather than resolve(value) as to
  // not accidentally override the resolve() MOP method of the defaultMirror
	def resolveWithValue(value) {

		// if value == myself, don't do anything (can happen when forwarding messages)
		// (check not strictly necessary: otherwise I would just register
		//  a listener on myself)
		if: !(self == value) then: {
			// is the future resolved by another future?
			if: (is: value taggedAs: Future) then: {
				// register this future as a listener with the resolved future value
				value<-addResolutionListener(object: {
					def notifyResolved(val) {
						// re-resolve this future with the actual value
						resolveWithValue(val);
					};
					def notifyRuined(exc) {
						// ruin this future
						ruinWithException(exc);
					}
			  // note that <-addResolutionListener is a message directed to the future's mirror
			  // and that no future return value is required
				})@[MetaMessage, OneWayMessage];
			} else: {
				if: (state == UNRESOLVED) then: {
					state := RESOLVED;
					resolvedValue := value;
					inbox.each: { |msg| value <+ msg };
					inbox := [];
					subscribers.each: { |sub| sub<-notifyResolved(value)@OneWayMessage };
					subscribers := [];
				};	
			};	
		};
		nil;
	};

	def ruinWithException(exception) {

		if: (state == UNRESOLVED) then: {
			state := RUINED;
			resolvedValue := exception;
			inbox.each: { |msg|
				if: (is: msg taggedAs: FutureMessage) then: {
					msg.future<-ruinWithException(exception)@[MetaMessage,OneWayMessage];
				};
			};
			inbox := [];
			if: (subscribers.isEmpty) then: {
				// warning to ease debugging when something goes wrong in a future that's never accessed
				system.println("[futures.at] Warning: future has no listeners to catch exception: " + exception);
				system.println(exception.stackTrace);
			} else: {
				subscribers.each: { |sub| sub<-notifyRuined(exception)@OneWayMessage };
				subscribers := [];	
			}
		};
		nil;
	};

	// adds a resolution listener to the future
	// @param sub a resolution listener
	def addResolutionListener(sub) {
		// if future has already been resolved/ruined, notify listener immediately
		if: (state == RESOLVED) then: {
			sub<-notifyResolved(resolvedValue)@OneWayMessage;
		} else: {
			if: (state == RUINED) then: {
				sub<-notifyRuined(resolvedValue)@OneWayMessage;
			} else: {
			  subscribers := subscribers + [ sub ];	
			}
		};
		nil;
	};
	
	// upon timeout, a future ruins itself with a timeout exception
	def timeout(receiver := nil, message := nil) {
		ruinWithException(XTimeoutException.new(self.base, receiver, message));
	};
	
	// the following methods make a future behave like a bounded multifuture
	// with upper bound equal to 1. This enables regular futures to be passed
	// anywhere a multifuture is expected in the code.
	
	def upperBound := 1;
	
	// a regular future is fully resolved if it is no longer unresolved
	def isFullyResolved() { !(state == UNRESOLVED) };
	
	// a whenEach:becomes: listener on a regular future behaves exactly the same
	// as a when:becomes: listener (it triggers at most once)
	def addWhenEachListener(sub) {
		addResolutionListener(sub);
	};
	
	// a whenAll:resolved:ruined: listener triggers when the future
	// either becomes resolved or ruined. Provide an adaptor from
	// when:becomes: listeners to whenAll:resolved:ruined: listeners
	def addWhenAllListener(sub) {
		addResolutionListener(object: {
			def notifyResolved(val) {
				sub<-notify([val], [])@OneWayMessage;
			};
			def notifyRuined(exc) {
				sub<-notify([], [exc])@OneWayMessage;
			};
		});
	};
	
	// in the case of a multifuture this forces it to become totally
	// resolved. In the case of a regular future, it is considered to
	// timeout the future
	def becomeResolved() {
		timeout();
	};

	// provide the required methods for the TFarRef trait
	
	def intercept(msg) {
		// msg received by a resolved future? forward the message
		if: (state == RESOLVED) then: {
			resolvedValue <+ msg;
		} else: {
			if: (state == RUINED) then: {
				(is: msg taggedAs: FutureMessage).ifTrue: {
					msg.future<-ruinWithException(exception)@[MetaMessage,OneWayMessage];
				};
			}	else: {
				// accumulate message in this future's inbox
				inbox := inbox + [msg];
				nil;
			};
		};
	};

	def toString() {
		if: (state == RESOLVED) then: {
			  "resolved future:" + resolvedValue;
		} else: {
			if: (state == RUINED) then: {
				"ruined future:" + resolvedValue;
			}	else: {
				"unresolved future";
			};
		};
	};
	
	// to satisfy the required interface of TFarRef, not really required
	def transportStrategy := { };
};

def makeFuture(timeout := nil) {
	// futures are empty objects mirrored by a future mirror
	// note that the future mirror is implicitly instantiated for each new future!
	def future := object: { nil } taggedAs: [ Future ] mirroredBy: FutureMirror;
  constructResolverFor(future, timeout);
};

def constructResolverFor(future, timeout := nil) {
	def resolver := isolate: { |future|
		def resolve(val) { future<-resolveWithValue(val)@[/.at.lang.firstclassrefs.MetaMessage, /.at.lang.futures.OneWayMessage]; };
		def ruin(exc) { future<-ruinWithException(exc)@[/.at.lang.firstclassrefs.MetaMessage, /.at.lang.futures.OneWayMessage]; };
	};

	// has the future been annotated with a timeout?
	if: (nil != timeout) then: {
		// if so, wrap the future into a single-call lease
		[ constructLeaseFor(future, timeout), resolver ];
	} else: {
		// by default futures are not leased.
		[ future, resolver ];
	};
};

def constructLeaseFor(future, timeout) {
	def futureLease := LeasingModule.singleCallLease: timeout for: future;
	LeasingModule.when: futureLease expired: {
		(reflect: future).timeout();
	};
	futureLease
};

// determine what type of future to attach to the message:
//
// @FutureMessage -> regular future
// @Due -> future with timeout
// @Gather -> multifuture
//
// @Due and @Gather are mutually exclusive, if both would be specified, @Due has precedence
def attachFuture(msg) {  
	// support for multifutures: messages tagged with the @Gather(n)
	// type tag receive a multifuture bounded by n
	def MFModule := /.at.lang.multifutures;
	if: (is: msg taggedAs: MFModule.GatherType) then: {
		def ann := /.at.support.util.getAnnotationOfType(msg, MFModule.GatherType);
		def [fut,res] := MFModule.makeMultiFuture(ann.upperBound, ann.timeout);
		futurize(msg, fut, MFModule.GatherType);
	} else: {
		if: (is: msg taggedAs: DueType) then: {
			// integration of futures with leasing
			def ann := /.at.support.util.getAnnotationOfType(msg, DueType);
			def [fut,res] := makeFuture(ann.timeout);
			futurize(msg, fut, DueType);
		} else: {
			// by default, make a future without timeout
			def [fut,res] := makeFuture();
			futurize(msg, fut, FutureMessage);	
		}
	}	
};

// extend a regular asynchronous message with futures behaviour
def futurize(msg, future, type) {
	// extend default message with FutureMessage behaviour
	extend: msg with: { |future|

		// the process method is invoked when an async message arrives
	  def process(behaviour) {
			try: {
				// delegate to parent to actually invoke the method
				def result := super^process(behaviour);

				// if everything goes right, resolve the attached future
				// replace the placeholder symbol with the actual result
				future<-resolveWithValue(result)@[/.at.lang.firstclassrefs.MetaMessage, /.at.lang.futures.OneWayMessage];

				result;

			// note that we need to qualify the full path to the Exception type:
			// the Exception variable defined above is out of scope since this message is an isolate!
			} catch: /.at.types.Exception using: { |e|
				future<-ruinWithException(e)@[/.at.lang.firstclassrefs.MetaMessage, /.at.lang.futures.OneWayMessage];

				// re-raise the caught exception
				raise: e;
			};
		};
	} taggedAs: [ type ];
};

// should future-type message sending be supported for default (unannotated) messages?
def enableFuturesOnDefaultMessages := false;

// this object is returned when this file is loaded, hence
// it is the public interface to code defined in this file
def FuturesModule := object: {
	// support for first-class futures: returns a pair
	// [ future, resolver]. The resolver can be used to easily resolve
	// or ruin the corresponding future
  def makeFuture := &makeFuture;

  // is actually only exported to be used by the MultiFuturesModule!
  def constructResolverFor := &constructResolverFor;
  def constructLeaseFor := &constructLeaseFor;

	// when-catch support, version without a catch block
	def when: future becomes: resolvedBlock {
		when: future becomes: resolvedBlock catch: Exception using: { |e|
			system.println("[futures.at] Warning: re-raising uncaught exception in when:becomes: because no catch-clause specified: " + e);
			raise: e; // raise the uncaught exception
		}
	};

  // when-catch support, version with one generic catch-all block
	def when: future becomes: resolvedBlock catch: excBlock {
		when: future becomes: resolvedBlock catch: Exception using: excBlock
	};

	// when-catch support, version with one specific catch block
	def when: future becomes: resolvedBlock catch: excType using: excBlock {
		if: (future == nil) then: {
			raise: /.at.exceptions.XIllegalOperation.new("when:becomes: on nil value. Probably an async message does not return a future.");
		};
		
		def [whenFuture,resolver] := makeFuture();
		def notify(block, val) {
			try: {
				resolver.resolve(block(val));				
			} catch: Exception using: {|e|
				resolver.ruin(e);
			};
			nil;
		};
		if: !(is: future taggedAs: Future) then: {
			raise: /.at.exceptions.XIllegalOperation.new("when:becomes: on non-future value: " + future + (reflect: future).listFields);
		} else: {
			future<-addResolutionListener(object: {
				def notifyResolved(val) { notify(resolvedBlock, val); };
				def notifyRuined(exc) {
					if: (is: exc taggedAs: excType) then: {
						notify(excBlock, exc);
					} else: {
						system.println("[futures.at] Warning: uncaught exception: " + exc + ". Can only cath: " + excType);
					};
				};
			// note that <-addResolutionListener is a message directed to the future's mirror
			// and that no future return value is required
			})@[MetaMessage, OneWayMessage];	
		};
		whenFuture; // when returns a future itself
	};

  // groups a table of futures into a single future which is resolved
  // with a table of values or ruined with an exception
	// when: (group: [ a<-m(), b<-n() ]) becomes: { |values| ... }
	def group: futures {
		def [futForAll, res] := makeFuture();
		def resolutions[futures.length] { nil };
		def nextUnresolved := 0;
		futures.each: { |future|
			when: future becomes: { |val|
				nextUnresolved := nextUnresolved + 1;
				resolutions[nextUnresolved] := val;
				if: (nextUnresolved == futures.length) then: {
					res.resolve(resolutions);
				};
			} catch: { |e|
				res.ruin(e); // ! only first exception is propagated
			};
		};
		futForAll;
	};
	
	/**
	 * future: { |return|
	 *   // some computation
	 *   return(val)
	 * }
	 *
	 * is equivalent to the slightly more verbose
	 * def [fut,res] := makeFuture();
	 * try: { // some computation
	 *        res.resolve(val);
	 * } catch: Exception using: { |e| res.ruin(e) }
	 * fut;
	 */
	def future: closure {
		def [fut,res] := makeFuture();
		try: {
			closure({|val| res.resolve(val)});
	  } catch: /.at.types.Exception using: { |e| res.ruin(e) };
		fut;
	};

  // make the Future type publicly visible
  def Future := Future;

  // make the OneWayMessage type publicly visible
  def OneWayMessage := OneWayMessage;

  // make the FutureMessage type publicly visible
  def FutureMessage := FutureMessage;

  //make the Due function publicly visible 
  def Due := &Due;
  def DueType := DueType;

  //make visible the exception raised when futures are ruined by timeout.
  def XTimeoutException := XTimeoutException;
  def TimeoutException := TimeoutException;

  // type that identifies this language module
  deftype FuturesModule;

  def futurize := &futurize;

	// install the futures protocol on the invoking actor,
	// returns the previously active protocol
	// the optional argument indicates whether futures should be enabled on unannotated messages
	// by default, futures are not enabled on unannotated messages
	def enableFutures(enabledByDefault := false) {
		
		// can only change this default from 'false' to 'true'
		// once set to 'true', the default may no longer change
		// (as it may break existing code that relies on implicit futures)
		if: ((!enableFuturesOnDefaultMessages).and: {enabledByDefault}) then: {
			system.println("[futures.at] futures are now enabled by default on " + actor);
			enableFuturesOnDefaultMessages := enabledByDefault;
		};
		
		// do not load the futures module twice!
		if: !(is: actor taggedAs: FuturesModule) then: {
			// before installing changes to the creation of messages, create messages that will be used internally
			// to resolve or ruin the futures. If these messages are not created up front they will be subject to 
			// the futures protocol themselves, resulting in an endless cycle of messages if the receiver also has
			// futures enabled.
			system.println("[futures.at] enabling futures on actor " + actor + " (default = " + enabledByDefault + ")");

			// the futures protocol by default extends the currently active protocol
			actor.install: (extend: actor with: {
				def createMessage(sel, args, types) {
					// first, create a regular message
					def msg := super^createMessage(sel, args, types);
					// do we need to support futures by default on all messages?
					if: enableFuturesOnDefaultMessages then: {
						// if the message was annotated with OneWayMessage type, override this behaviour
						// and simply return the regular message
						if: (is: msg taggedAs: OneWayMessage) then: {
							// default = FutureMessage, overridden by OneWayMessage, so return normal message
							msg;
						} else: {
							// default = FutureMessage or overriden by DueType, so attach future behaviour
							attachFuture(msg);
						}
					} else: {
						// if the message was explicitly annotated with FutureMessage type, activate
						// the futures behaviour
						if: (is: msg taggedAs: FutureMessage) then: {
							// default = OneWayMessage, overridden by FutureMessage or DueType, so attach future behaviour
							attachFuture(msg);
						} else: {
							// default = OneWayMessage, so return the normal message
							msg;
						}
					}
				};
			
			  def send(rcv, msg) {
				  def result := super^send(rcv, msg);
				  // for a future message, the return value now becomes the message's future
				  if: (is: msg taggedAs: FutureMessage) then: {
					  // if the future is wrapped in a leased reference,
					  // the future has to be accessed via the leased reference
					  if: (is: msg.future taggedAs: LeasingModule.LeasedRef) then: {
						  (reflect:  msg.future).getPrincipal();
					  } else: {
					    msg.future;
					  }
				  } else: {
					   result;
				  };
			  };	
		  } taggedAs: [ FuturesModule ]);
	  } else: {
		  actor; // return the current actor protocol
	  };
  };

 	def millisec(ms) { TimerModule^millisec(ms) };
	def seconds(s) { TimerModule^seconds(s) };
	def minutes(m) { TimerModule^minutes(m) };
  
  def FuturesTest() {
   extend: /.at.unit.test.UnitTest.new("futures test") with: {
    enableFutures(false);

    def foo() { 5 };    
    
    def testAsyncFutureCreation() {
      def [fut,res] := makeFuture();
      self.assertEquals("<unresolved future>", print: fut);
      res.resolve(5);
      when: fut becomes: { |val|
	      self.assertEquals("<resolved future:5>", print: fut);
	    };
    };
    
    def testFutureSend() {
      def fut := &foo<-apply([])@FutureMessage;
      self.assertNotNil(fut);
      self.assertTrue(is: fut taggedAs: Future);
    };
    
    def testAsyncWhen() {
      when: &foo<-apply([])@FutureMessage becomes: { |v|
        self.assertEquals(5,v);
      };
    };

    def testAsyncGroup() {
	    def o := object: {
			  def m() { 5 };
			  def n() { 6 };
			};
			def f := group: [ o<-m()@FutureMessage, o<-n()@FutureMessage ];
			when: f becomes: { |vals|
				self.assertEquals(2, vals.length);
				self.assertEquals(11, vals[1]+vals[2]);
			};
    };
		
		def testAsyncDueResolvingTest(){
			//TEST 1: Resolving the future within the timeout period
			//This test uses the AR future as return value of the test.
			def a := actor: {
				deftype AsyncDueResolvingTestT;
				def service := object: { def test() { 5 } };
				export: service as: AsyncDueResolvingTestT;
			};
			deftype AsyncDueResolvingTestT;
			def ref := /.at.lang.ambientrefs.ambient: AsyncDueResolvingTestT;
			def future := ref<-test()@Due(LeasingModule.seconds(10));
			when: future becomes: { |v|
			 	self.assertEquals(5,v);
			} catch: TimeoutException using: { |e|
			  self.fail("testAsyncDue1: Unexpected ruined future");
			};
   	};

		def testAsyncDueRuiningTest(){
			//TEST 2: ruining the future with a TimeoutException
			//This test uses the AR future as return value of the test.
			def a := actor: {
				deftype AsyncDueRuiningTestT;
				def service := object: {
					def test() { 5 };
				} mirroredBy: ( mirror:{
					//intercepting the message so that it's never received and thus, 
					//the future will be eventually ruined.
					def receive(msg) {
					 	if: !(msg.selector	== `(test)) then: {
						  super^receive(msg);
					  };
					};
				});
				export: service as: AsyncDueRuiningTestT;
			};
			deftype AsyncDueRuiningTestT;
      def ref := /.at.lang.ambientrefs.ambient: AsyncDueRuiningTestT;
			def future := ref<-test()@Due(LeasingModule.seconds(5));
			when: future becomes: { |v|
		  	self.fail("testAsyncDue2: Unexpected resolved future");
		  } catch: TimeoutException using: { |e|
				nil
      };
		};		
    };
  };
};


