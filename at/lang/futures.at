/**
 * AmbientTalk/2 Project
 * (c) Programming Technology Lab, 2006 - 2007
 * Authors: Tom Van Cutsem & Stijn Mostinckx
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* The meta-level implementation of the futures language construct */

// import Exception type, used for catching exceptions
def Exception := /.at.types.Exception;
def Isolate := /.at.types.Isolate;

// a future can be in one of these three states
def UNRESOLVED := 0;
def RESOLVED := 1;
def RUINED := 2;

// all future objects are marked with this type
deftype Future;

// all future-carrying messages are marked with this type
deftype FutureMessage;

// type that signifies that no future should be attached to a message
deftype OneWayMessage;

// To register a when-observer on a future, a message needs to be sent to its mirror
// This would only be possible on far references to futures if an explicit additional
// far reference to its mirror would be passed. This restriction is avoided through the
// introduction of a MetaMessage type: messages typed with it will be handled by the
// future's mirror rather than being forwarded to the actual principal when the future is resolved.
deftype MetaMessage;

// the mirror of a Future object
def FutureMirror := mirror: {
	// initialize the state of the prototype
	def state := UNRESOLVED;
	def resolvedValue := nil;
	def inbox := [];
	def subscribers := [];

	// constructor: used to initialize the state of the new future
	def init(@args) {
		super^init(@args); // initialize this future's base field
		state := UNRESOLVED;
		resolvedValue := nil;
		inbox := [];
		subscribers := [];
	};

	def resolve(value) {
		// is the future resolved by another future?
		if: (is: value taggedAs: Future) then: {
			// register this future as a listener with the resolved future value
			value<-addResolutionListener(object: {
				def notifyResolved(val) {
					// re-resolve this future with the actual value
					resolve(val);
				};
				def notifyRuined(exc) {
					// ruin this future
					ruin(exc);
				}
		  // note that <-addResolutionListener is a message directed to the future's mirror
		  // and that no future return value is required
			})@[MetaMessage, OneWayMessage];
		} else: {
			if: (state == UNRESOLVED) then: {
				state := RESOLVED;
				resolvedValue := value;
				inbox.each: { |msg| value <+ msg };
				inbox := [];
				subscribers.each: { |sub| sub<-notifyResolved(value)@OneWayMessage };
				subscribers := [];
			};	
		};
		nil;
	};

	def ruin(exception) {
		if: (state == UNRESOLVED) then: {
			state := RUINED;
			resolvedValue := exception;
			inbox.each: { |msg|
				if: (is: msg taggedAs: FutureMessage) then: {
					msg.resolver<-ruin(exception)@OneWayMessage;
				};
			};
			inbox := [];
			subscribers.each: { |sub| sub<-notifyRuined(exception)@OneWayMessage };
			subscribers := [];
		};
		nil;
	};

	// adds a resolution listener to the future
	// @param sub a resolution listener
	def addResolutionListener(sub) {
		// if future has already been resolved/ruined, notify listener immediately
		if: (state == RESOLVED) then: {
			sub<-notifyResolved(resolvedValue)@OneWayMessage;
		} else: {
			if: (state == RUINED) then: {
				sub<-notifyRuined(resolvedValue)@OneWayMessage;
			} else: {
			  subscribers := subscribers + [ sub ];	
			}
		};
		nil;
	};

	// hook into the meta-object protocol by overriding meta_receive
	def receive(msg) {
		if: (is: msg taggedAs: MetaMessage) then: {
			self <+ msg;
		} else: {
			// msg received by a resolved future? forward the message
			if: (state == RESOLVED) then: {
				resolvedValue <+ msg;
			} else: {
				if: (state == RUINED) then: {
					(is: msg taggedAs: FutureMessage).ifTrue: {
						msg.resolver<-ruin(exception)@OneWayMessage;
					};
				}	else: {
					// accumulate message in this future's inbox
					inbox := inbox + [msg];
					nil;
				};
			};
		};
	};

    def invokeField(rcv, sel) { self.invoke(rcv, sel, []) };

	// it is illegal to invoke methods synchronously on a future
	def invoke(rcv, sel, arg) {
		// the only legal operation on futures is '=='
		if: (`(==) == sel) then: {
			super^invoke(rcv, sel, arg);
		} else: {
			/.at.exceptions.createException(/.at.types.IllegalOperation).new(
			  "Cannot synchronously invoke method " + sel + " on future");
		}
	};

	def print() {
		if: (state == RESOLVED) then: {
			  "<resolved future:" + resolvedValue +">";
		} else: {
			if: (state == RUINED) then: {
				"<ruined future:" + resolvedValue +">";
			}	else: {
				"<unresolved future>";
			};
		};
	};
};

def makeFuture() {
	// futures are empty objects mirrored by a future mirror
	// note that the future mirror is implicitly instantiated for each new future!
	def fut := object: { nil } taggedAs: [ Future ] mirroredBy: FutureMirror;
	
	[ fut, object: {
		def resolve(val) { (reflect: fut).resolve(val) };
		def ruin(exc) { (reflect: fut).ruin(exc) };
		def future := fut;
	}]
};

// extend a regular asynchronous message with futures behaviour
def futurize(msg) {
	// attach the resolver for a future to the message
	def [future, resolver] := makeFuture();

	// extend default message with FutureMessage behaviour
	extend: msg with: { |resolver, OneWayMessage|

		// the process method is invoked when an async message arrives
	  def process(behaviour) {
			try: {
				// delegate to parent to actually invoke the method
				def result := super^process(behaviour);

				// if everything goes right, resolve the attached future
				// replace the placeholder symbol with the actual result
				resolver<-resolve(result)@OneWayMessage;

				result;

			// note that we need to qualify the full path to the Exception type:
			// the Exception variable defined above is out of scope since this message is an isolate!
			} catch: /.at.types.Exception using: { |e|
				resolver<-ruin(e)@OneWayMessage;

				// re-raise the caught exception
				raise: e;
			};
		};
	} taggedAs: [ FutureMessage ];
};

// should future-type message sending be supported for default (unannotated) messages?
def enableFuturesOnDefaultMessages := false;

// this object is returned when this file is loaded, hence
// it is the public interface to code defined in this file
def FuturesModule := object: {
	// support for first-class futures: returns a pair
	// [ future, resolver]. The resolver can be used to easily resolve
	// or ruin the corresponding future
    def makeFuture := &makeFuture;

	// when-catch support, version without a catch block
	def when: future becomes: resolvedBlock {
		when: future becomes: resolvedBlock catch: Exception using: { |e| nil }
	};

  // when-catch support, version with one generic catch-all block
	def when: future becomes: resolvedBlock catch: excBlock {
		when: future becomes: resolvedBlock catch: Exception using: excBlock
	};

	// when-catch support, version with one specific catch block
	def when: future becomes: resolvedBlock catch: excType using: excBlock {
		def [whenFuture,resolver] := makeFuture();
		def notify(block, val) {
			try: {
				resolver.resolve(block(val));
			} catch: Exception using: {|e|
				resolver.ruin(e);
			};
			nil;
		};
		future<-addResolutionListener(object: {
			def notifyResolved(val) { notify(resolvedBlock, val); };
			def notifyRuined(exc) {
				if: (is: exc taggedAs: excType) then: {
					notify(excBlock, exc);
				};
			};
		// note that <-addResolutionListener is a message directed to the future's mirror
		// and that no future return value is required
		})@[MetaMessage, OneWayMessage];
		whenFuture; // when returns a future itself
	};

  // groups a table of futures into a single future which is resolved
  // with a table of values or ruined with an exception
	// when: (group: [ a<-m(), b<-n() ]) becomes: { |values| ... }
	def group: futures {
		def [futForAll, res] := makeFuture();
		def resolutions[futures.length] { nil };
		def nextUnresolved := 0;
		futures.each: { |future|
			when: future becomes: { |val|
				nextUnresolved := nextUnresolved + 1;
				resolutions[nextUnresolved] := val;
				if: (nextUnresolved == futures.length) then: {
					res.resolve(resolutions);
				};
			} catch: { |e|
				res.ruin(e); // ! only first exception is propagated
			};
		};
		futForAll;
	};

  // make the Future type publicly visible
  def Future := Future;

  // make the OneWayMessage type publicly visible
  def OneWayMessage := OneWayMessage;

  // make the FutureMessage type publicly visible
  def FutureMessage := FutureMessage;

  // type that identifies this language module
  deftype FuturesModule;

	// install the futures protocol on the invoking actor,
	// returns the previously active protocol
	// the optional argument indicates whether futures should be enabled on unannotated messages
	// by default, futures are not enabled on unannotated messages
	def enableFutures(enabledByDefault := false) {
		
		// can only change this default from 'false' to 'true'
		// once set to 'true', the default may no longer change
		// (as it may break existing code that relies on implicit futures)
		if: ((!enableFuturesOnDefaultMessages).and: {enabledByDefault}) then: {
			system.println("[futures.at] futures are now enabled by default on " + actor);
			enableFuturesOnDefaultMessages := enabledByDefault;
		};
		
		// do not load the futures module twice!
		if: !(is: actor taggedAs: FuturesModule) then: {
			// before installing changes to the creation of messages, create messages that will be used internally
			// to resolve or ruin the futures. If these messages are not created up front they will be subject to 
			// the futures protocol themselves, resulting in an endless cycle of messages if the receiver also has
			// futures enabled.
			system.println("[futures.at] enabling futures on actor " + actor + " (default = " + enabledByDefault + ")");

			// the futures protocol by default extends the currently active protocol
			actor.install: (extend: actor with: {
				def createMessage(sel, args, types) {
					// first, create a regular message
					def msg := super^createMessage(sel, args, types);
					// do we need to support futures by default on all messages?
					if: enableFuturesOnDefaultMessages then: {
						// if the message was annotated with OneWayMessage type, override this behaviour
						// and simply return the regular message
						if: (is: msg taggedAs: OneWayMessage) then: {
							// default = FutureMessage, overridden by OneWayMessage, so return normal message
							msg;
						} else: {
							// default = FutureMessage, so attach future behaviour
							futurize(msg);
						}
					} else: {
						// if the message was explicitly annotated with FutureMessage type, activate
						// the futures behaviour
						if: (is: msg taggedAs: FutureMessage) then: {
							// default = OneWayMessage, overridden by FutureMessage, so attach future behaviour
							futurize(msg);
						} else: {
							// default = OneWayMessage, so return the normal message
							msg;
						}
					}
				};
			
			  def send(msg) {
				  def result := super^send(msg);
				  // for a future message, the return value now becomes the message's future
				  if: (is: msg taggedAs: FutureMessage) then: {
					  msg.resolver.future;
				  } else: {
					  result;
				  };
			  };	
		  } taggedAs: [ FuturesModule ]);
	  } else: {
		  actor; // return the current actor protocol
	  };
  };
  
  def FuturesTest() {
   extend: /.at.unit.test.UnitTest.new("futures test") with: {
    enableFutures(false);

    def foo() { 5 };    
    
    def testFutureCreation() {
      def [fut,res] := makeFuture();
      self.assertEquals("<unresolved future>", print: fut);
      res.resolve(5);
      self.assertEquals("<resolved future:5>", print: fut);
    };
    
    def testFutureSend() {
      def fut := &foo<-apply([])@FutureMessage;
      self.assertNotNil(fut);
      self.assertTrue(is: fut taggedAs: Future);
    };
    
    def testAsyncWhen() {
      when: &foo<-apply([])@FutureMessage becomes: { |v|
        self.assertEquals(5,v);
      };
    };

    def testAsyncGroup() {
	    def o := object: {
			  def m() { 5 };
			  def n() { 6 };
			};
			def f := group: [ o<-m()@FutureMessage, o<-n()@FutureMessage ];
			when: f becomes: { |vals|
				self.assertEquals(2, vals.length);
				self.assertEquals(11, vals[1]+vals[2]);
			};
      }
   };
  };
};