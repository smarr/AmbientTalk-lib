/* The following definitions represent top-level functions that are
   implemented natively in the interpreter. They can be uncommented
   to shadow their native equivalent.

def / := lobby;

def root := self;

def if: booleanCondition then: consequent {
  booleanCondition.ifTrue: consequent
};

def if: booleanCondition then: consequent else: alternative {
  booleanCondition.ifTrue: consequent ifFalse: alternative
};

def while: cond do: body {
  cond.whileTrue: body
};

def foreach: iterator in: table {
  table.each: iterator
};

def do: body if: cond {
  cond.ifTrue: body
};

def do: body unless: cond {
  cond.ifFalse: body
};

def extend: obj with: code {
  (reflect: obj).extend(code)
};

def share: obj with: code {
  (reflect: obj).share(code)
};

def clone: obj {
  (reflect: obj).clone()
};

def !(b) { b.not() };

def -(n) { 0-n };

def +(n) { 0+n };

*/

def does: obj respondTo: selector {
	(reflect: obj).respondsTo(selector)
};

// example: table: 5 fill: { |i| i } => [1,2,3,4,5]
def table: size fill: closure {
  def t[size] { nil };
  1.to: size+1 do: { |i| t[i] := closure(i) };
  t
};

/*def functor: closure {
  def obj := object: closure;
  eval: `({ // TODO: this evaluates a closure definition within obj, which does nothing...
    // base-level interface for closures
    def apply(args) { self.run(@args) };
    def whileTrue: body { self.run.whileTrue: body };
    def getMethod() { (reflect: self.run).method };
    def getContext() { (reflect: self.run).context };
  }) in: obj;
  obj;
};*/

def functor: closure {
  deftype Closure;
  def functorPrototype := object: {
    // to be overridden by children
    def run(@args) { nil };
    // base-level interface for closures
    def apply(args) { self.run(@args) };
    def whileTrue: body { self.run.whileTrue: body };
    def getMethod() { (reflect: self.run).method };
    def getContext() { (reflect: self.run).context };
    def escape() { self.run.escape() };
  } taggedAs: [ Closure ];
  extend: functorPrototype with: closure;
};

// infinite asynchronous loop
def loop: code {
	code();
	self<-loop: code;
	nil;
};

// asynchronous if-test
def whenTrue: boolFut then: cons else: alt {
	boolFut<-ifTrue: cons ifFalse: alt;
};

// asynchronous while loop over future-type conditional
// requires futures to be enabled by default!
def asLongAs: cond do: body {
	cond()<-ifTrue: {
		body();
		asLongAs: cond do: body;
	};
	nil;
};

/**
 * Defines a pass-by-copy lambda.
 * Example:
 * def x := 5;
 * def l := isolatelambda: { |x| x + 2 }
 *
 * In this example, l is a function object which can
 * be passed to remote actors and applied. All of the arguments
 * specified in the isolate lambda are lexically visible variables
 * which are copied inside the by-copy function object and which
 * will hence be serialized together with the function object.
 *
 * Implementation-wise, defining an isolate lambda is equal to
 * defining an isolate object with an apply method and tagged
 * as a Closure.
 */
def isolatelambda: clo {
  deftype Closure;
  deftype Isolate;
  def mth := clo.method;
  eval: `(object: { |#@(mth.parameters)|
    def apply(@args) {
      #@(mth.bodyExpression.statements)
    }
  } taggedAs: [#Closure,#Isolate]) in: clo.context.lexicalScope;
};

def isolatelambda: clo scoped: lexclo {
	isolatelambda: clo closeOver: (lexclo.method.parameters);
  /*deftype Closure;
  deftype Isolate;
  def mth := clo.method;
  eval: `(object: { |#@(lexclo.method.parameters)| 
    def apply(args) {
        self.run(@args);
    };
    def run(#@(mth.parameters)){        
      #@(mth.bodyExpression.statements)
    };
  } taggedAs: [#Closure,#Isolate]) in: lexclo.context.lexicalScope;*/
};

def isolatelambda: clo closeOver: variableNames {
  deftype Closure;
  deftype Isolate;
  def mth := clo.method;
  eval: `(object: { |#@(variableNames)| 
    def apply(args) {
        self.run(@args);
    };
    def run(#@(mth.parameters)){        
      #@(mth.bodyExpression.statements)
    };
  } taggedAs: [#Closure,#Isolate]) in: clo.context.lexicalScope;
};

/**
 * Defines an isolate object with a custom serialization strategy.
 * Example:
 *  def foo := 42;
 *  def i := isolate: {
 *    ...
 *  } passAs: { |foo|
 *    /.some.Object.new(foo);
 *  }
 * => defines an isolate object i which, when passed between actors,
 *    becomes a some.Object on the other side. Note that state can be
 *    transferred as usual via the parameter list of the closure.
 */
def isolate: closure passAs: transportClosure {
	object: closure taggedAs: [/.at.types.Isolate] mirroredBy: (mirror: {
		def pass() {
			/.at.support.util.uponArrivalBecome: transportClosure
		};
	})
};

def whenever: remoteRef disconnected: code {
	when: remoteRef disconnected: code
};

def whenever: remoteRef reconnected: code {
	when: remoteRef reconnected: code
};