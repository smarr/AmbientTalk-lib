/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab (2006-2010)
 * Authors: Eline Philips
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
 

def initModule := lobby.frameworks.workflow.WFinit;
def environmentModule := lobby.frameworks.workflow.environment;
def activityModule := lobby.frameworks.workflow.activity;
def workflowPatternModule := lobby.frameworks.workflow.workflowPattern;
def standardPatternsModule := lobby.frameworks.workflow.standardPatterns;
def compensatingActionsModule := lobby.frameworks.workflow.compensatingActions;
//def groupInteractionsModule := lobby.frameworks.workflow.groupInteractions;
def crimeModule := lobby.bridges.crime.CrimeConnection;
def intensionalModule := lobby.frameworks.workflow.intensional;
def CRIMEgroupInteractionsModule := lobby.frameworks.workflow.CRIMEgroupInteractions;

import initModule;
import environmentModule;
import activityModule;
import workflowPatternModule;
import standardPatternsModule;
import compensatingActionsModule;
//import groupInteractionsModule;
import crimeModule;
import intensionalModule;
import CRIMEgroupInteractionsModule;


def WFenv := Environment.new();
def ServiceDB := ServiceDatabase.new();


WFenv.insert(`gps, 99);
WFenv.insert(`timeout, nil);
WFenv.insert(`disconnection, nil);
WFenv.insert(`notFound, nil);
WFenv.insert(`groupInfo, [0,0,nil]);
WFenv.insert(`serviceDB, ServiceDB);

//=============================================================================

import /.at.lang.values;
import /.at.lang.futures;
import /.at.lang.multifutures;
enableFutures(false);
network.online();


deftype LocationService <: Service;
deftype WeatherService <: Service;
deftype GUIService <: Service;
deftype EndService <: Service;
deftype AService <: Service;
deftype BService <: Service;
deftype CService <: Service;
deftype DService <: Service;
deftype EService <: Service;
deftype FService <: Service;
deftype GService <: Service;
deftype HService <: Service;
deftype IService <: Service;
deftype DisplayService <: Service;
deftype MsgService <: Service;
deftype Teacher <: Service;
deftype Student <: Service;
deftype Stijn <: Service;
deftype Eline <: Service;

def locationServiceWrapper := makeServiceWrapper(LocationService);
def weatherServiceWrapper := makeServiceWrapper(WeatherService);
def guiServiceWrapper := makeServiceWrapper(GUIService);
def endServiceWrapper := makeServiceWrapper(EndService);
def asw := makeServiceWrapper(AService);
def bsw := makeServiceWrapper(BService);
def csw := makeServiceWrapper(CService);
def dsw := makeServiceWrapper(DService);
def esw := makeServiceWrapper(EService);
def fsw := makeServiceWrapper(FService);
def gsw := makeServiceWrapper(GService);
def hsw := makeServiceWrapper(HService);
def isw := makeServiceWrapper(IService);
def display := makeServiceWrapper(DisplayService);
def msg := makeServiceWrapper(MsgService);
def Ssw := makeServiceWrapper(Student);
def Tsw := makeServiceWrapper(Teacher);
def ElineSw := makeServiceWrapper(Eline);
def StijnSw := makeServiceWrapper(Stijn);


//def seq := Sequence( asw.a(22)@Output(Env.a), bsw.b()@Output(Env.b), csw.c()@Output(Env.c), asw.a(Env.c)@Output(Env.d) );
//seq.start(WFenv);



def myRule2 := makeRule( makeTemplate("person", var: `id, var: `name), 
                         makeTemplate("age", var: `id, var: `age) );
                         
//def myRule2 := makeRule( makeTemplate("person", var: `id, var: `name) );                         
def seq2 := Sequence(myRule2.print(), ElineSw.print());                  


def myRule3 := makeRule( makeTemplate("teacher", var: `id, var: `name),
						 makeTemplate("course", var: `id, var: `name, var: `course, var: `year),
						 makeTemplate("hours", var: `id, var: `course, 120) );
def constraintGroup := SnapshotGroup(myRule3, `p, ElineSw.print() );       

def myRule4 := makeRule( makeFindall(var: `name,
                                     [ makeTemplate("teacher", var: `id, var: `name) ],
                                     var: `names) );
def constraintGroup2 := SnapshotGroup(myRule3, `p, ElineSw.print() );       
            
            
            
//def testAsyncReadFromCrimeTable() {
//		def [fut,res] := makeFuture(); 
//		def tuple :=  makeTuple("testReadFromCrimeTable", [3, 4]);
//		def tuple2 :=  makeTuple("testReadFromCrimeTable", [99, 100]);
//		myCrime.when:  [ makeBagof(var: `x, [makeTemplate("testReadFromCrimeTable", var:`x)], var: `ids) ] activated: { |varMap|
//			system.println(varMap.get(`ids));
//			res.resolve("OK");
//		};
//		myCrime.insertTuple(tuple);
//		myCrime.insertTuple(tuple2);
//		fut;			
//};   


def sync := Synchronize(gsw.g()@Output(Env.g));
def parSplit := ParallelSplit( Sequence(asw.a(Env.gps)@Output(Env.a), Connection(sync)),
                               Sequence(bsw.b()@Output(Env.b), csw.c()@Output(Env.c), dsw.d()@Output(Env.d), esw.e()@Output(Env.e), Connection(sync)),
                               Sequence(fsw.f()@Output(Env.f), Connection(sync)) );
parSplit.start(WFenv);                   