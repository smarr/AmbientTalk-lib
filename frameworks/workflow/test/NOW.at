/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2011
 * Authors: Soft Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * @author eline.philips
 */
 

def initModule := lobby.frameworks.workflow.WFinit;
def environmentModule := lobby.frameworks.workflow.environment;
def activityModule := lobby.frameworks.workflow.activity;
def standardPatternsModule := lobby.frameworks.workflow.standardPatterns;
def compensatingActionsModule := lobby.frameworks.workflow.compensatingActions;
def groupInteractionsModule := lobby.frameworks.workflow.groupInteractions;
def crimeModule := lobby.bridges.crime.CrimeConnection;
def intensionalModule := lobby.frameworks.workflow.intensional;
//def CRIMEgroupInteractionsModule := lobby.frameworks.workflow.CRIMEgroupInteractions;

import initModule;
import environmentModule;
import activityModule;
import standardPatternsModule;
import compensatingActionsModule;
import groupInteractionsModule;
import crimeModule;
import intensionalModule;
//import CRIMEgroupInteractionsModule;


def Local(blk) {
    object: {
        def block := blk;
        def resolvers := [];

        def start(env) {
            def [result, resolver] := makeFuture();
            resolvers := resolvers + [[env.id, resolver]];   
            block(env);      
            resolver.resolve(env);
            result;
        };
        
        def cancel(env) {
        	def resolver;
        	resolvers.each: { |p| if: ( p[1] == env.id) then: { resolver := p[2]; }; };
        	if: ! (resolver == nil) then: {
        		resolver.ruin(/.at.lang.types.Exception);
        	};
        };
    } taggedAs: [Pattern];
};




def WFenv := Environment.new();
def ServiceDB := ServiceDatabase.new();


WFenv.insert(`gps, 99);
WFenv.insert(`timeout, nil);
WFenv.insert(`disconnection, nil);
WFenv.insert(`notFound, nil);
WFenv.insert(`exception, nil);
WFenv.insert(`groupInfo, nil);
WFenv.insert(`serviceDB, ServiceDB);

//=============================================================================

import /.at.lang.values;
import /.at.lang.futures;
enableFutures(false);
network.online();


deftype LocationService <: Service;
deftype WeatherService <: Service;
deftype GUIService <: Service;
deftype EndService <: Service;
deftype AService <: Service;
deftype BService <: Service;
deftype CService <: Service;
deftype DService <: Service;
deftype EService <: Service;
deftype FService <: Service;
deftype GService <: Service;
deftype HService <: Service;
deftype IService <: Service;
deftype DisplayService <: Service;
deftype MsgService <: Service;
deftype Teacher <: Service;
deftype Student <: Service;
deftype Stijn <: Service;
deftype Eline <: Service;

def locationServiceWrapper := makeServiceWrapper(LocationService);
def weatherServiceWrapper := makeServiceWrapper(WeatherService);
def guiServiceWrapper := makeServiceWrapper(GUIService);
def endServiceWrapper := makeServiceWrapper(EndService);
def asw := makeServiceWrapper(AService);
def bsw := makeServiceWrapper(BService);
def csw := makeServiceWrapper(CService);
def dsw := makeServiceWrapper(DService);
def esw := makeServiceWrapper(EService);
def fsw := makeServiceWrapper(FService);
def gsw := makeServiceWrapper(GService);
def hsw := makeServiceWrapper(HService);
def isw := makeServiceWrapper(IService);
def display := makeServiceWrapper(DisplayService);
def msg := makeServiceWrapper(MsgService);
def Ssw := makeServiceWrapper(Student);
def Tsw := makeServiceWrapper(Teacher);
def ElineSw := makeServiceWrapper(Eline);
def StijnSw := makeServiceWrapper(Stijn);


//def seq := Sequence( asw.a(22)@Output(Env.a), bsw.b()@Output(Env.b), csw.c()@Output(Env.c), asw.a(Env.c)@Output(Env.d) );
//seq.start(WFenv);



//def myRule2 := makeRule( makeTemplate("person", var: `id, var: `name), 
//                         makeTemplate("age", var: `id, var: `age) );
//def myRule2 := makeRule( makeTemplate("age", var: `id, var: `age) );                         
//def myRule2 := makeRule( makeTemplate("person", var: `id, var: `name) );                         
//def seq2 := Sequence(myRule2.print(), ElineSw.print());                  


//def myRule3 := makeRule( makeTemplate("teacher", var: `id, var: `name),
//						 makeTemplate("course", var: `id, var: `name, var: `course, var: `year),
//						 makeTemplate("hours", var: `id, var: `course, 120) );
//def constraintGroup := SnapshotGroup(myRule3, `p, ElineSw.print() );       

//def myRule4 := makeRule( makeFindall(var: `name,
//                                    [ makeTemplate("teacher", var: `id, var: `name) ],
//                                    var: `names) );
//def constraintGroup2 := SnapshotGroup(myRule3, `p, ElineSw.print() );       
            
            
            
//def testAsyncReadFromCrimeTable() {
//		def [fut,res] := makeFuture(); 
//		def tuple :=  makeTuple("testReadFromCrimeTable", [3, 4]);
//		def tuple2 :=  makeTuple("testReadFromCrimeTable", [99, 100]);
//		myCrime.when:  [ makeBagof(var: `x, [makeTemplate("testReadFromCrimeTable", var:`x)], var: `ids) ] activated: { |varMap|
//			system.println(varMap.get(`ids));
//			res.resolve("OK");
//		};
//		myCrime.insertTuple(tuple);
//		myCrime.insertTuple(tuple2);
//		fut;			
//};   


//def sync := Synchronize(gsw.g()@Output(Env.g));
//def parSplit := ParallelSplit( Sequence(asw.a(Env.gps)@Output(Env.a), Connection(sync)),
//                               Sequence(bsw.b()@Output(Env.b), csw.c()@Output(Env.c), dsw.d()@Output(Env.d), esw.e()@Output(Env.e), Connection(sync)),
//                               Sequence(fsw.f()@Output(Env.f), Connection(sync)) );
//parSplit.start(WFenv);       


//def seq := Sequence( asw.a(999)@Output(Env.a), MultipleInstancesWithoutSynchronization(bsw.b()@Output(Env.b)), csw.c()@Output(Env.c) );   

//def seq := Sequence( asw.a(Env.gps)@Output(Env.a), bsw.b()@Output(Env.b) );

//def group3 :=  SnapshotGroup(Teacher, `p, Env.p.teach(Env.a)   );

    

//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Timeout(5), Restart(2, dsw.d()@Output(Env.d)) ) ] );     
					 
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Timeout(5), Skip() ) ] );  		

//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Timeout(5), dsw.d()@Output(Env.d) ) ] );  			 					 

//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Timeout(20), Restart(3, dsw.d()@Output(Env.d)) ),    
//					   ConditionAction( Disconnection(), esw.e()@Output(Env.e) ) ] );					  
					  
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Timeout(5), Retry(3, dsw.d()@Output(Env.d)) ),
//					   ConditionAction( Disconnection(), esw.e()@Output(Env.e) ) ] );
					 
					 
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Disconnection(), Retry(1, esw.e()@Output(Env.e)) ) ] );	
					 
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Disconnection(), Skip() ) ] );	
					 
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Disconnection(), esw.e()@Output(Env.e) ) ] );	

//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( Disconnection(), Rediscover(1, esw.e()@Output(Env.e)) ) ] );	
	
//def sync := Synchronize( Sequence( fsw.f()@Output(Env.f), Local({|env| env.print()}) ) );	
//def fail := Failure( ParallelSplit( Sequence( asw.a(Env.gps)@Output(Env.a), Connection(sync) ),
//                                    Sequence( gsw.g()@Output(Env.g), Connection(sync) ),
//                                    Sequence( csw.c()@Output(Env.c), Connection(sync) ) ),
//					 [ ConditionAction( Timeout(5), Restart(3, dsw.d()@Output(Env.d)) ),    
//					   ConditionAction( Disconnection(), esw.e()@Output(Env.e) ),
//					   ConditionAction( NotFound(), hsw.h()@Output(Env.h) ) ] );	
	
	
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ ConditionAction( NotFound(), Retry(1, esw.e()@Output(Env.e)) ) ] );			
					 
					 
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ [ Disconnection(), Retry(1, esw.e()@Output(Env.e)) ],
//					 	ConditionAction(Timeout(20), dsw.d()@Output(Env.d) ) ] );			 
					 
					 
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ [ Disconnection(), Wait(20, Rediscover(1, Component(esw.e()@Output(Env.e)))) ] ] );					 		 	
					 
					 
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ [ Disconnection(), Alternative(esw.e()@Output(Env.e)) ] ] );					 		
//def seq := Sequence(fail, fsw.f()@Output(Env.f));

					 
def fail2 := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
					 [ [ Disconnection(), Component(esw.e()@Output(Env.e)) ] ] );				
def seq2 := Sequence(fail2, fsw.f()@Output(Env.f));

	
	
//def fail := Failure( Sequence( asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//					 [ [ Exception(), Component(esw.e()@Output(Env.e)) ],
//					   [ Timeout(5), Component(fsw.f()@Output(Env.f)) ] ] );		
	
//def fail := Failure( Sequence( 	asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
//                               [ [Timeout(5), Retry(2, Restart(1, Component(esw.e()@Output(Env.e))))], 
//                                  [Disconnection(), Component(fsw.f()@Output(Env.f))] ]);		 	
                                  
                                  
//def fail := Failure( Sequence( 	asw.a(Env.gps)@Output(Env.a), gsw.g()@Output(Env.g), csw.c()@Output(Env.c), Local({|env| env.print()}) ),
 //                               [ [Disconnection(), Wait(20, Restart(1, Alternative( fsw.f()@Output(Env.f) ) ) ) ] ]);	      
 //def seq := Sequence(fail, esw.e()@Output(Env.e));
                                  
                                                              		  						 