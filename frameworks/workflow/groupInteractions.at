/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab, 2006 - 2011
 * Authors: Soft Ambient Group
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * @author eline.philips
 */


def initModule := lobby.frameworks.workflow.WFinit;
def environmentModule := lobby.frameworks.workflow.environment;
import initModule;
import environmentModule;
import /.at.lang.values;
import /.at.lang.futures;

deftype Service;


//TODO: ugly implementation, use something as volatile sets (experimental.lang)
def ServiceDatabase := object: {
    def services := [];
        
    def findAll(tag) {
        def result := [];
        services.each: { |s| if: (is: s taggedAs: tag) then: {result := result + [s];}; };
        result;
    };
    
    def init() {
        whenever: Service discovered: { |service|   
            system.println("service discovered ");
            services := services + [service];
            whenever: service disconnected: {
                system.println("Service disconnected");
                //def idx := services.find: { |s| s == service; };  TODO
                //services := services.select(1, idx) + services.select(idx + 1, services.length());
            };
        };
    };
};


def ServiceDB := ServiceDatabase.new();


def SnapshotGroup(tag, var, cmp) {
    object: {
        def groupTag := tag;
        def varName := var;
        def component := cmp;
        def started := false;
    
        def start(env) {
            def [result, resolver] := makeFuture();
            execute(env, resolver);
            result;
        };
    
        def execute(env, resolver) {
            def services := ServiceDB.findAll(groupTag);
            groupId := groupId + 1;
            services.each: { |s| def clonedEnv := Environment.new(env); 
                                 clonedEnv.insert(varName, s); 
                                 def groupInfo := env.find(`groupInfo);
                                 clonedEnv.replace(`groupInfo, [groupId, services.length(), groupInfo]);
                                 when: component.start(clonedEnv) becomes: { |nEnv|
                                 	 resolver.resolve(nEnv);
                                 }; }; 
        };
    } taggedAs: [Pattern];
};



def Barrier(c, cmp) {
    object: {
        def condition := c;
        def component := cmp;
        def passedEnv := Environment.new();
    
        def start(env) { 
            def [result, resolver] := makeFuture();
            execute(env, resolver);
            result;
        };
    
        def execute(env, resolver) {
            def groupInfo := env.find(`groupInfo);
            if: (check(env)) then: {
                def passed := passedEnv.find(groupInfo[1]);
                def nrPassed := if: (passed == false) then: { 0; } else: {passed[2]};
                passedEnv.replace(groupInfo[1], nrPassed+1);
                when: component.start(env) becomes: { |nEnv|
                	resolver.resolve(nEnv); 
                };
            } else: {
                system.println("Condition of barrier no langer holds.");
            };
        };
    
        def check(env) {
            def groupInfo := env.find(`groupInfo);
            def passed := passedEnv.find(groupInfo[1]);
            def nrPassed := if: (passed == false) then: { 0; } else: {passed[2]};
            condition.check(groupInfo[2], nrPassed);
        };
    } taggedAs: [Pattern];
};



def Percentage(p) {
    object: {
        def pct := p;
    
        def check(total, nbr) {
            nbr/total <= pct;
        };
    } taggedAs: [Pattern];
};


def Amount(a) {
    object: {
        def amount := a;
    
        def check(total, nbr) {
            nbr < amount;
        };
    } taggedAs: [Pattern];
};


def GroupInteractionsModule := object: {
    deftype Service;
    def ServiceDatabase := ServiceDatabase;
    def SnapshotGroup := &SnapshotGroup;
    def Barrier := &Barrier;
    def Percentage := &Percentage;
    def Amount := &Amount;
};