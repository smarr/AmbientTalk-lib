import /.at.lang.values;
import /.at.lang.futures;
import /.at.lang.multifutures;
enableFutures(false);
network.online();

deftype Pattern;
deftype Service;
deftype Table;
deftype SyncPattern <: Pattern;
deftype MultiPattern <: Pattern;
deftype Act;
deftype Compensation;
deftype RetryType <: Compensation;
deftype RediscoverType <: Compensation;
deftype SkipType <: Compensation;
deftype RestartType <: Compensation;
deftype FailureType;
deftype DisconnectionType <: FailureType;
deftype TimeoutType <: FailureType;
deftype NotFoundType <: FailureType;

def id := 0;

def Environment := object: {
	def dict := [];
	def id;
	
	def insert(name, value) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			dict := dict + [[name, value]];
		} else: {
			def curVal := dict[idx];
			if: ! (curVal[2] == value) then: {
				if: (is: curVal[2] taggedAs: Table) then: {
					def vals := curVal[2].find: {|v| (v == value)}; 
					if: (vals == nil)  then: {
						curVal[2] := curVal[2] + [value];
					};
				} else: { curVal[2] := [curVal[2], value] };
			};
		};
	};
	
	def replace(name, value) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			dict := dict + [[name, value]];
		} else: {
			dict[idx] := [name, value];
		};
	};
	
	def delete(name) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx != nil then: {
			dict[idx] := [];
		};
	};
	
	def find(name) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			false;
		} else: {
			dict[idx];
		};
	};
	
	def bind(arguments) {
		arguments.map: { |arg| if: arg.freeVariables() != [] then: { find(arg)[2]; } else: { arg; }; };
	};
	
	def isEmpty() {
		dict.isEmpty();
	};
	
	def merge(envs) {
		envs.each: { |env| env.dict.each: { |pair| insert(pair[1], pair[2]); }; };
	};
	
	def init(@envsToCopy) {
		self.merge(envsToCopy)
	};
	
	def print() {
		system.println(dict);
	};
};



def WorkflowPattern := object: {		
	def idx := 0;
	
	def createAsyncMsg(selector, args) {
		reflectOnActor().createMessage(selector, args, [FutureMessage]);
	};
	
	def createTimeoutMsg(selector, args, timeout) {
		reflectOnActor().createMessage(selector, args, [Due(seconds(timeout))]);
	};
	
	def execute(activity, env, continue, runIdx) {
		def arguments := activity.parameters;
		def msg := createAsyncMsg(activity.selector, env.bind(arguments));
		def timeout := env.find(`timeout)[2]; 
		if: (is: timeout taggedAs: TimeoutType) then: {
			msg := createTimeoutMsg(activity.selector, env.bind(arguments), timeout.duration);
		};
		def elapsed := false;
		def compensation := false;
		when: activity.service.tag discovered: { |service|
			if: !compensation then: {
				invoke(activity, service, msg, env, continue, runIdx);
				elapsed := true;
			};
		};
		/.at.support.timer.when: /.at.support.timer.seconds(20) elapsed: {		
			if: !elapsed then: {
				compensation := true;  // in orde to deactivity the when: discovered: event handler
				env.replace("compensating" + runIdx, true);  // in order to avoid several compensations to be executed
				def notFound := env.find(`notFound)[2];
				if: (((is: disconnection taggedAs: NotFoundType).or: {is: disconnection taggedAs: Pattern}).or: {is: disconnection taggedAs: Act}) then: {
					compensate(activity, notFound.compensation, msg, env, continue, runIdx);
				} else: {
					system.println("service not found error, no compensation specified");
				};
			};
		};
	};
	
	def invoke(activity, service, msg, env, continue, runIdx) {
		def timeout := env.find(`timeout)[2]; 
		def disconnection := env.find(`disconnection)[2];
		def output := activity.output;	
		when: service <+ msg becomes: { |reply|
			def idx := 1;
			reply.each: { |val| env.insert(output[idx], val); idx := idx + 1; }; 
			continue(reply);
		} catch: TimeoutException using: { |e|
			def compensating := env.find("compensating" + runIdx)[2];
			if: ((is: compensating taggedAs: TimeoutType).or: { (! (is: compensating taggedAs: FailureType)).and: {!compensating} }) then: {
				env.replace("compensating" + runIdx, timeout);
				system.println("timeout error");
				compensate(activity, timeout.compensation, msg, env, continue, runIdx, service);
			} else: {
				system.println("timeout error, but other compensation is already executed");
			};
		};
		whenever: service disconnected: {
			if: (((is: disconnection taggedAs: DisconnectionType).or: {is: disconnection taggedAs: Pattern}).or: {is: disconnection taggedAs: Act}) then: {
				def compensating := env.find("compensating" + runIdx)[2];
				if: ((is: compensating taggedAs: DisconnectionType).or: { (! (is: compensating taggedAs: FailureType)).and: {!compensating} }) then: {
					env.replace("compensating" + runIdx, disconnection);
					system.println("disconnection error");
					compensate(activity, disconnection.compensation, msg, env, continue, runIdx, service); 
				} else: {
					system.println("disconnection error, but other compensation is already executed");
				};
			} else: {
				system.println("disconnection error, no compensation specified");
			};
		};
	};
	
	def compensate(activity, compensation, msg, env, continue, runIdx, service := nil) {
		if: (compensation == nil) then: {
			system.println("no compensation specified");
		} else: { 
			if: (is: compensation taggedAs: RediscoverType) then: {
				if: (compensation.triedTimes < compensation.maxTimes) then: {
					compensation.try();
					execute(activity, env, continue);
				} else: {
					compensate(activity, compensation.action, msg, env, continue, runIdx, service);
				};
			} else: {
				if: (is: compensation taggedAs: RetryType) then: {
					if: (compensation.triedTimes < compensation.maxTimes) then: {
						compensation.try();
						invoke(activity, service, msg, env, continue, runIdx);
					} else: {
						compensate(activity, compensation.action, msg, env, continue, runIdx, service);
					};
				} else: { 
					if: (is: compensation taggedAs: SkipType) then: {
						continue("skipped");
					} else: { 
						if: (is: compensation taggedAs: RestartType) then: {
							compensation.action.restart();
							run(compensation.action, env, { | _ | _ })  // such that execution of remainder of component is not completed
						} else: {
							// compensating action is a component
							run(compensation, env, continue, env.find("compensating" + runIdx)[2]);
						};
					};
				};
			};
		};
 	};
	
	def run(component, env, continue := { | _ | _ }, compensating := false) {
		if: (! (((is: compensating taggedAs: FailureType).or: {is: compensating taggedAs: Pattern}).or: {is: compensating taggedAs: Act})) then: {
			idx := idx + 1;
		};
		env.replace("compensating" + idx, compensating);
		if: (is: component taggedAs: Act) then: {
			// Component is an activity, wrapping a service object.
			execute(component, env, continue, idx);
    	} else: { 
			// Component is a pattern, the engine must start it and then await its completion
			when: component.start(env) becomes: { |reply|
				continue(reply);
			};
		};
	};
};



def Sequence := object: {
    def componentTable;
    def result;
	def resolver;
	def multi := 1;
	def started := 0;
	def addedFutures := 0;

	def init(cmpTable) {
    	componentTable := cmpTable;
        [result, resolver] := makeMultiFuture(multi);    
	};
	
	def restart() {
		started := started - 1;
	};
	
	def start(env) {
		if: !(started == multi) then: {
			started := started + 1;
			execute(1, env);
		};
		result;
	};
	
	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		componentTable.each: { |cmp| if: (is: cmp taggedAs: Pattern) then: { cmp.addFuture(multi); }; };
		[result, resolver] := makeMultiFuture(multi);
	};
		
	def execute(idx, env) {	
		def component := componentTable[idx];
		if: (idx < componentTable.length()) then: {
			WorkflowPattern^run(component, env, { | _ | self.execute(idx+1, env) });
		} else: {
			WorkflowPattern^run(component, env, { | _ | resolver.resolve(_) });
		};
	};
} taggedAs: [Pattern];



def ParallelSplit := object: {
	def multi := 1;
	def started := 0;
    def componentTable;
	def futureTable;
	def result;
	def resolver;
	def addedFutures := 0;
	
    def init(bTable) {
		def i := 0;
		// convert the "pairs" [service, synchronize] in the component table to sequences
		def b[bTable.length()] { i := i+1; if: (is: bTable[i] taggedAs: Table) then: { Sequence.new(bTable[i]) } else: { bTable[i] }};
    	componentTable := b;

		// make a table to hold all the unresolved futures of the different branches
		def f[bTable.length()] { makeMultiFuture(multi); };
		futureTable := f;
		[result, resolver] := makeMultiFuture(multi);
		result;  
    };

	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		componentTable.each: { |cmp| if: (is: cmp taggedAs: Pattern) then: { cmp.addFuture(multi); }; };
		def f[componentTable.length()] { makeMultiFuture(multi); };
		futureTable := f;
		[result, resolver] := makeMultiFuture(multi);
	};
  
	def start(env) {
		if: !(started == multi) then: {
			started := started + 1;
			execute(env);
			//when all components have been started, the parallelSplit is said to be "done"
			//and the result Future is resolved as usual (with the future table as value ...)
			def i := 0;
			def f[futureTable.length()] { i := i+1; futureTable[i][1]; };
			resolver.resolve(f);
		};
		result;   // TODO result teruggeven? (wat bij init)
	};	
		
	def execute(env) {
		1.to: componentTable.length+1 do: { | idx |
			def clonedEnv := Environment.new(env);
			WorkflowPattern^run(componentTable[idx], clonedEnv, { | _ | futureTable[idx][2].resolve(_) });
		}
	};
} taggedAs: [Pattern];



def Connection := object: {
	def result;
    def resolver;
    def sync := false;
   	def syncF;
    def syncResolver;
    def started := 0;
    def component;
	def multi := 1;
	def addedFutures := 0;
 
    def init(cmp) {
        component := cmp;
        // make a future for the result of the component
        [result, resolver] := makeMultiFuture(multi);
        if: (is: cmp taggedAs: SyncPattern) then: {
        	sync := true;
            [syncF, syncResolver] := makeMultiFuture(3); //TODO multi
            cmp.addSync(syncF);
        };
		if: (is: cmp taggedAs: MultiPattern) then: {
			cmp.addFuture(1);
		};
    };
 
    def start(env) {
   		// only start the component once
       	if: !(started == multi) then: {
         	started := started + 1;
        	execute(env);
       	};
     	result;
	};
	
	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: component taggedAs: Pattern) then: {
			component.addFuture(multi);
		};
	};
	
 
 	def execute(env) {
     	if: (is: component taggedAs: Pattern) then: {
       		// if we have a connection to a SyncPattern, notify it
         	if: sync then: {
            	syncResolver.resolve(env);
      		};
        	// start the component and resolve with its reply as usual
         	when: component.start(env) becomes: { |reply|
				resolver.resolve(reply);
           	};                       
     	} else: {
       		system.println("error: Connection made to non-pattern component.");
     	};
   	};     
} taggedAs: [Pattern];



// also Structured Synchronizing Merge
def Synchronize := object: {
    def syncTable := [];
    def nextComponent;
	def result := nil;
	def resolver;
	def started := false;
	def multi := 1;
	def nEnv := Environment.new();
	def addedFutures := 0;

    def init(cmp) {
    	nextComponent := cmp;
		[result, resolver] := makeMultiFuture(multi);  
    };

	def addSync(fut) {
		syncTable := syncTable + [[fut, 0, []]];
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: nextComponent taggedAs: Pattern) then: {
			nextComponent.addFuture(multi);
		};
	};

	def start(env) {
		// only start the component once (even with multifutures, is taken care of in execute method)
		if: !started then: {
			started := true;
			execute();
		};
		result;
	};
	
	def resolve(branch) {
		whenEach: branch[1] becomes: { |env| 
			branch[3] := branch[3] + [env];
			branch[2] := branch[2] + 1;
			checkSynchronization(env.id);   //TODO id too simple
		};
	};
	
	def checkSynchronization(idValue) {
		def envs := [];
		syncTable.each: { |branch| envs := envs + branch[3].filter:{ |env| env.id == idValue; }; };
		if: (envs.length() == syncTable.length()) then: {
			nEnv.merge(envs);
			WorkflowPattern^run(nextComponent, nEnv, { | _ | resolver.resolve(_) });
		};
	};
	
	def execute() {
     	syncTable.each: { |branch| resolve(branch); };
    };
} taggedAs: [SyncPattern];



def ExclusiveChoice := object: {
        def test;
		def consequence;
		def alternative;
        def result;
        def resolver;
        def started := false;
 
    def init(block, then, else) {
        test := block;
		consequence := then;
		alternative := else;
        [result, resolver] := makeFuture();  //TODO: multi?
        // if a component in the actionrules is a SyncPattern,
        // add the exclusiveChoice to its syncTable 
       // TODO: only for the one branch ?!?
        /*conditionActionRules.each: { |rule| 
			if: (is: rule[2] taggedAs: SyncPattern) then: {
        		rule[2].addSync(result);
        	};
        };*/
    };
 
  	def start(env) {
     	if: !started then: {
       		started := true;
        	execute(env);
    	};
      	result;
	};
 
  	def execute(env) {
		def method := test.method();
		def bindings := env.bind(method.parameters()); 
		if: (test.apply(bindings)) then: {
			WorkflowPattern^run(consequence, env, { | _ | resolver.resolve(_) });
		} else: { // alternative branch
			WorkflowPattern^run(alternative, env, { | _ | resolver.resolve(_) });
		};
		//TODO: meer dan 2 branches                    
  	};
} taggedAs: [Pattern];



def SimpleMerge := object: {
	def branches := 0;
    def component;
	def result := nil;
	def resolver;

    def init(cmp) {
    	component := cmp;
        [result, resolver] := makeMultiFuture(branches);    
	};

	def addFuture(nbr) {
		branches := branches + 1;
		[result, resolver] := makeMultiFuture(branches);
		if: (is: component taggedAs: Pattern) then: {
			component.addFuture(branches);
		};
	};

	def start(env) {
		id := id  + 1;
		def clonedEnv := Environment.new(env);
		clonedEnv.id := id;
		execute(clonedEnv);
		result;
	};
	
	def execute(env) {
		WorkflowPattern^run(component, env, { | _ | resolver.resolve(_) });
	};
} taggedAs: [MultiPattern];



def MultiChoice := object: {
	def multi := 1;
	def started := 0;
    def componentTable;
	def futureTable;
	def result;
	def resolver;
	def addedFutures := 0;
	def conditionActions;
	
    def init(bTable) {
		def i := 0;
		// convert the "pairs" [service, synchronize] in the component table to sequences
	//	def b[bTable.length()] { i := i+1; if: (is: bTable[i] taggedAs: Table) then: { Sequence.new(bTable[i]) } else: { bTable[i] }};
    	componentTable := bTable;

		// make a table to hold all the unresolved futures of the different branches
		[result, resolver] := makeMultiFuture(multi);
    };

	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		componentTable.each: { |cmp| if: (is: cmp[2] taggedAs: Pattern) then: { cmp[2].addFuture(multi); }; };
		[result, resolver] := makeMultiFuture(multi);
	};
  
	def start(env) {
		conditionActions := componentTable.filter: { |car| 
														def rule := car[1];
														def method := rule.method();
														def bindings := env.bind(method.parameters()); 
														rule.apply(bindings); };
		def f[conditionActions.length()] { makeMultiFuture(multi); };
		futureTable := f;
		if: (conditionActions.isEmpty()) then: {
			raise: XNoCondition.new("No matching condition found");
		} else: {
			if: !(started == multi) then: {
				started := started + 1;
				execute(env);
				//when all components have been started, the parallelSplit is said to be "done"
				//and the result Future is resolved as usual (with the future table as value ...)
				def i := 0;
				def f[futureTable.length()] { i := i+1; futureTable[i][1]; };
				resolver.resolve(f);
			};
		};
		result;
	};	
		
	def execute(env) {
		def clonedEnv := clone: env;
		1.to: conditionActions.length+1 do: { | idx |
			WorkflowPattern^run(conditionActions[idx][2], clonedEnv, { | _ | futureTable[idx][2].resolve(_) });
		};
	};
} taggedAs: [Pattern];



def StructuredDiscriminator := object: {
    def syncTable := [];
    def nextComponent;
	def result := nil;
	def resolver;
	def started := false;
	def multi := 1;
	def addedFutures := 0;

    def init(cmp) {
    	nextComponent := cmp;
		[result, resolver] := makeFuture();   // TODO: MultiFuture
    };

	def addSync(fut) {
		syncTable := syncTable + [[fut, 0, []]];
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: nextComponent taggedAs: Pattern) then: {
			nextComponent.addFuture(multi);
		};
	};

	def start(env) {
		// only start the component once (even with multifutures, is taken care of in execute method)
		if: !started then: {
			started := true;
			execute();
		};
		result;
	};
	
	def resolve(branch) {
		whenEach: branch[1] becomes: { |env| 
			branch[3] := branch[3] + [env];
			branch[2] := branch[2] + 1;
			checkSynchronization(env.id, env);   //TODO id too simple
		};
	};
	
	def checkSynchronization(idValue, env) {
		def envs := [];
		syncTable.each:{ |branch| envs := envs + branch[3].filter:{ |env| env.id == idValue; }; };
		if: (envs.length() == 1) then: {
			WorkflowPattern^run(nextComponent, env, { | _ | resolver.resolve(_) });
		};
	};
		
	def execute() {
     	syncTable.each: { |branch| resolve(branch); };
    };
} taggedAs: [SyncPattern];



def StructuredPartialJoin := object: {
    def syncTable := [];
    def nextComponent;
	def result := nil;
	def resolver;
	def started := false;
	def multi := 1;
	def addedFutures := 0;
	def n := 0;

    def init(cmp, nbr) {
		n := nbr; // TODO: verify that nbr < number of branches
    	nextComponent := cmp;
		[result, resolver] := makeFuture();   // TODO: MultiFuture
    };

	def addSync(fut) {
		syncTable := syncTable + [[fut, 0, []]];
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: nextComponent taggedAs: Pattern) then: {
			nextComponent.addFuture(multi);
		};
	};

	def start(env) {
		// only start the component once (even with multifutures, is taken care of in execute method)
		if: !started then: {
			started := true;
			execute();
		};
		result;
	};
	
	def resolve(branch) {
		whenEach: branch[1] becomes: { |env| 
			branch[3] := branch[3] + [env];
			branch[2] := branch[2] + 1;
			checkSynchronization(env.id, env);   //TODO id too simple
		};
	};
	
	def checkSynchronization(idValue, env) {
		def envs := [];
		syncTable.each:{ |branch| envs := envs + branch[3].filter:{ |env| env.id == idValue; }; };
		if: (envs.length() == n) then: {
			WorklowPattern^run(nextComponent, env, { | _ | resolver.resolve(_) });
		};
	};
		
	def execute() {
     	syncTable.each: { |branch| resolve(branch); };
    };
} taggedAs: [SyncPattern];



// not pattern of van der Aalst
def Multiplexer := object: {
	def number := 0;
    def component;
	def result := nil;
	def resolver;
	def started := 0;
	def multi := 1;
	def addedFutures := 0;

    def init(cmp, n) {
		number := n;
    	component := cmp;
        [result, resolver] := makeMultiFuture(multi);    
	};

	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: component taggedAs: Pattern) then: {
			component.addFuture(multi);
		};
	};

	def start(env) {
		if: ! (started == multi) then: {
			started := started + 1;
			id := id  + 1;
			def clonedEnv := Environment.new(env);
			clonedEnv.id := id;
			execute(clonedEnv);
		};
		result;
	};
	
	def execute(env) {
		number.doTimes: { | nr |
			if: (is: component taggedAs: Act) then: {
				WorkflowPattern^run(component, env, { | _ | resolver.resolve(_) });
			} else: {
				WorkflowPattern^run(clone: component, env, { | _ | resolver.resolve(_) });
			};
		};
  };
} taggedAs: [Pattern];



def MultipleInstancesWithoutSynchronization := object: {
	def number := 0;
    def component;
	def result := nil;
	def resolver;
	def started := 0;
	def multi := 1;
	def addedFutures := 0;
	def instances := 0;

    def init(cmp) {
    	component := cmp;
        [result, resolver] := makeMultiFuture(multi);    
	};

	def addFuture(nbr) {
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
		if: (is: component taggedAs: Pattern) then: {
			component.addFuture(multi);
		};
	};

	def start(env) {
		if: ! (started == multi) then: {
			started := started + 1;
			id := id  + 1;
			def clonedEnv := Environment.new(env);
			clonedEnv.id := id;
			execute(clonedEnv);
		};
		result;
	};
	
	def execute(env) {
		WorkflowPattern^run(component, env, { | _ | resolver.resolve(_) });
	};
} taggedAs: [MultiPattern];



def Failure := object: {
	def component;
	def failureEvents; 
	def result;
	def resolver;
	def started := false; // TODO multi
	
	def init(c, fe) {
		component := c;
		failureEvents := fe;
		[result, resolver] := makeFuture();  //TOOD multiFuture
	};
	
	def start(env) {
		if: !started then: {
			started := true;
			execute(env);
		};
		result;
	};
	
	def replaceFailure(failureEvent, env) {
		if: (is: failureEvent taggedAs: DisconnectionType) then: {
			env.replace(`disconnection, failureEvent);
		} else: {
			if: (is: failureEvent taggedAs: TimeoutType) then: {
				env.replace(`timeout, failureEvent);
			} else: {
				if: (is: failureEvent taggedAs: NotFoundType) then: {
					env.replace(`notFound, failureEvent);
				};
			};
		};
		if: (is: failureEvent.compensation taggedAs: RestartType) then: {
			failureEvent.compensation.updateAction(component);
		};
	};
	
	def execute(env) {
		def prevDisconnection := env.find(`disconnection)[2];
		def prevTimeout := env.find(`timeout)[2];
		def prevNotFound := env.find(`notFound)[2];
		failureEvents.each: { |failure| replaceFailure(failure, env); };
		WorkflowPattern^run(component, 
			env, 
			{ | _ | 
				env.replace(`disconnection, prevDisconnection);
				env.replace(`timeout, prevTimeout);
				resolver.resolve(_) });
	};
} taggedAs: [Pattern];


def Disconnection := object: {
	def compensation;
	
	def init(c) {
		compensation := c;
	};
} taggedAs: [DisconnectionType];


def Timeout := object: {
	def duration;
	def compensation;
	
	def init(d, c) {
		duration := d;
		compensation := c;
	};
} taggedAs: [TimeoutType];


def NotFound := object: {
	def compensation;
	
	def init(c) {
		compensation := c;
	};
} taggedAs: [NotFoundType];


def Retry := object: {
	def maxTimes;
	def triedTimes := 0;
	def action; 
	def result;
	def resolver;
	
	def init(t, a := nil) {
		[result, resolver] := makeFuture(); //TODO: multi
		maxTimes := t;
		action := a;
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
} taggedAs: [RetryType];


def Rediscover := object: {
	def maxTimes;
	def triedTimes := 0;
	def action; 
	def result;
	def resolver;
	
	def init(t, a := nil) {
		[result, resolver] := makeFuture(); //TODO: multi
		maxTimes := t;
		action := a;
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
} taggedAs: [RediscoverType];


def Skip := object: {
	def maxTimes := 1;
	def triedTimes := 0;
	def action := nil; 
	def result;
	def resolver;
	
	def init() {
		[result, resolver] := makeFuture(); //TODO: multi
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
} taggedAs: [SkipType];


def Restart := object: {
	def maxTimes;
	def triedTimes := 0;
	def action; 
	def result;
	def resolver;
	
	def init(t) {
		[result, resolver] := makeFuture(); //TODO: multi
		maxTimes := t;
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
	
	def updateAction(component) {
		action := component;
	};
} taggedAs: [RestartType];

def Activity := object: {
	def service;
	def selector;
	def parameters;
	def output;
	
	def init(sw, sel, pars, outputVars) {  
		service	   := sw;
		selector   := sel;
		parameters := pars;
		output     := outputVars;
	};
} taggedAs: [Act];

def createServiceMirror(baseObject) {
 	extend: defaultMirror.new(baseObject) with: {
			def invoke(rcv, inv) {
				if: (self.respondsTo(inv.selector))
					then: { super.invoke(rcv, inv) }
					else: { 
						if: (is: inv taggedAs: Trigger)
							then: { TriggerPattern.new(baseObject, inv.selector, inv.arguments) }
							else: { Activity.new(baseObject, inv.selector, inv.arguments.select(1, inv.arguments.length()), inv.arguments[inv.arguments.length()]) }
					}
			}
  	};
};

def makeServiceWrapper(aTag) {
	object: {
		def tag() { aTag };

	} mirroredBy: {|emptyBase| createServiceMirror(emptyBase)}
};

deftype Trigger;
deftype TriggerP;

def TriggerPattern := object: {
	def listenerType;
	def selector;
	def params;
	
	def init(serviceWrapper, sel, pars) {  
		listenerType	:= createTypeTag(serviceWrapper.tag.typeName.text + "Listener");
		selector			:= sel;
		params				:= pars;
	};
	
	def makeListener(env, res) {
		def listener := object: { 
			def environment := env; 
			def resolver 		:= res;
			def parameters  := params;
			def subscription;
		};
		
		(reflect: listener).addMethod(createMethod(selector, `[@values], `{
			1.to: parameters.length + 1 do: { | idx | self.environment.insert(self.parameters[idx], values[idx]) };
			self.subscription.cancel();
			self.resolver.resolve(values)
		}, []));
		
		listener
	};
	
	def start(env) {
		def [fut,res] := makeFuture();
		def listener	:= makeListener(env, res);

		listener.subscription := export: listener as: listenerType;
		
		fut
	}
} taggedAs: [TriggerP];

deftype outputT;

def output := extend: outputT with: {
	def annotateMessage(method) {
    	system.println("output");
    	method;
	};
};

def Local := object: {
	def block;
	def result;
	def resolver;
	def started := 0;
	def multi := 1;
	def addedFutures := 0;
	
	def init(blk) {
		block := blk;
		[result, resolver] := makeMultiFuture(multi);
	};
	
	def addFuture(nbr) {
		// TODO: per id (momenteel multi 4 ipv 2)
		if: (addedFutures == 0) then: {addedFutures := 1; multi := 0;};
		multi := multi + 1;
		[result, resolver] := makeMultiFuture(multi);
	};
	
	def start(env) {
		// make sure the component is ony started once
		if: ! (multi == started) then: {
			started := started + 1;
			resolver.resolve(block(env));
		};
		result;
	};
} taggedAs: [Pattern];




// Test Code
deftype LocationService;
deftype WeatherService;
deftype GUIService;
deftype EndService;
deftype AService;
deftype BService;
deftype CService;
deftype DService;
deftype EService;
deftype FService;
deftype GService;
deftype HService;
deftype IService;

def locationServiceWrapper := makeServiceWrapper(LocationService);
def weatherServiceWrapper := makeServiceWrapper(WeatherService);
def guiServiceWrapper := makeServiceWrapper(GUIService);
def endServiceWrapper := makeServiceWrapper(EndService);
def asw := makeServiceWrapper(AService);
def bsw := makeServiceWrapper(BService);
def csw := makeServiceWrapper(CService);
def dsw := makeServiceWrapper(DService);
def esw := makeServiceWrapper(EService);
def fsw := makeServiceWrapper(FService);
def gsw := makeServiceWrapper(GService);
def hsw := makeServiceWrapper(HService);
def isw := makeServiceWrapper(IService);



def env := Environment.new();
env.insert(`gps, 99);
env.insert(`timeout, nil);
env.insert(`disconnection, nil);
env.insert(`notFound, nil);



/*
// Testing simple merge
def smerge1 := SimpleMerge.new(esw.e([`e]));
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);
sequence1.start(env);
*/

/*
// Testing simple merge
def smerge1 := SimpleMerge.new(Sequence.new([ esw.e([`e]), fsw.f([`f]) ]));
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);
sequence1.start(env);
*/

/*
// Testing simple merge
def smerge := SimpleMerge.new( ParallelSplit.new([ [dsw.d([`d]), Local.new({|env| env.print()})],
                                                   [esw.e([`e]), Local.new({|env| env.print()})] ]) );
def parSplit2 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge)],
                                     [csw.c([`c]), Connection.new(smerge)] ]);
def smSeq := Sequence.new([ asw.a([`a]), parSplit2 ]);
env.id := id + 1;
id := id + 1;
smSeq.start(env);
*/

/*
// Testing simple merge
def parSplit2 := ParallelSplit.new([ [esw.e([`e])],
                                     [fsw.f([`f])] ]);
def smerge1 := SimpleMerge.new(parSplit2);
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);
sequence1.start(env);
*/

/*
// Testing simple merge
def smerge3 := SimpleMerge.new(gsw.g([`g]));
def smerge1 := SimpleMerge.new(Connection.new(smerge3));
def parSplit1 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge1)],
                                     [csw.c([`c]), Connection.new(smerge1)] ]);
def sequence1 := Sequence.new([ asw.a([`a]), parSplit1 ]);


def smerge2 := SimpleMerge.new(Connection.new(smerge3));
def parSplit2 := ParallelSplit.new([ [esw.e([`e]), Connection.new(smerge2)],
                                     [fsw.f([`f]), Connection.new(smerge2)] ]);
def sequence2 := Sequence.new([ dsw.d([`d]), parSplit2 ]);

sequence1.start(env);
sequence2.start(env);
*/

/*
// Testing simple merge, parallel split, synchronize and sequence
def sync := Synchronize.new( Sequence.new([ fsw.f([`f]), Local.new({|env| env.print()}) ]) );
def smerge := SimpleMerge.new( ParallelSplit.new([ [dsw.d([`d]), Connection.new(sync)],
                                                   [esw.e([`e]), Connection.new(sync)] ]) );
def parSplit2 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge)],
                                     [csw.c([`c]), Connection.new(smerge)] ]);
def smSeq := Sequence.new([ asw.a([`a]), parSplit2 ]);
env.id := id + 1;
id := id + 1;
smSeq.start(env);
*/

/*
// Testing simple merge, followed by parallel split and synchronize
def sync := Synchronize.new( fsw.f([`f]) );
def smerge := SimpleMerge.new( ParallelSplit.new([ [dsw.d([`d]), Connection.new(sync)],
                                                   [esw.e([`e]), Connection.new(sync)] ]) );
def parSplit2 := ParallelSplit.new([ [bsw.b([`b]), Connection.new(smerge)],
                                     [csw.c([`c]), Connection.new(smerge)] ]);
def smSeq := Sequence.new([ asw.a([`a]), parSplit2 ]);
env.id := id + 1;
id := id + 1;
smSeq.start(env);
*/

/*
// Testing simple merge, followed by a sequence
def smerge1 := SimpleMerge.new(Sequence.new([ csw.c([`c]), dsw.d([`d]), esw.e([`e]), Local.new({|env| env.print()}) ]));
def parSplit1 := ParallelSplit.new([ [asw.a([`a]), Connection.new(smerge1)],
                                     [bsw.b([`b]), Connection.new(smerge1)] ]);
parSplit1.start(env);
*/

/*
// Testing multi choice
def mc := MultiChoice.new( [ [{|a| a < 2}, bsw.b([`b])], [ {|a| a > 100}, csw.c([`c])], [{|gps| gps > 99}, dsw.d([`d])] ] );
def mcSeq := Sequence.new([ asw.a([`a]), mc, Local.new({|env| env.print()}) ]);
mcSeq.start(env);
*/

/*
// Testing structured discriminator
def structDiscr := StructuredDiscriminator.new( dsw.d([`d]) );
def parSplit := ParallelSplit.new([ [bsw.b([`b]), Connection.new(structDiscr)],
                                     [csw.c([`c]), esw.e([`e]), fsw.f([`f]), gsw.g([`g]), Connection.new(structDiscr)] ]);
def sdSeq := Sequence.new([ asw.a([`a]), parSplit ]);
sdSeq.start(env);
*/

/*
// Testing structured partial join
def spJoin := StructuredPartialJoin.new( dsw.d([`d]), 2 );
def parSplit := ParallelSplit.new([ [bsw.b([`b]), Connection.new(spJoin)],
                                     [csw.c([`c]), esw.e([`e]), fsw.f([`f]), gsw.g([`g]), Connection.new(spJoin)],
 									 [isw.i([`i]), Connection.new(spJoin)] ]);
def sdSeq := Sequence.new([ asw.a([`a]), parSplit ]);
sdSeq.start(env);
*/

/* 
// Testing merging of environments
def sync := Synchronize.new( Sequence.new([ dsw.d([`d]), Local.new({|env| env.print()}) ]) );
def parSplit := ParallelSplit.new([ [bsw.b([`a]), Connection.new(sync)],
                                     [csw.c([`c]), esw.e([`e]), fsw.f([`f]), gsw.g([`g]), Connection.new(sync)] ]);
def sSeq := Sequence.new([ asw.a([`a]), parSplit ]);
id := id + 1;
env.id := id;
sSeq.start(env);
*/

/*
// Testing multiplexer 
def seq2 := Sequence.new([ dsw.d([`d]), esw.e([`e]), fsw.f([`f]) ]);
def miws := Multiplexer.new(seq2, 3);
def seq1 := Sequence.new([ asw.a([`a]), bsw.b([`b]), csw.c([`c]), miws, Local.new({|env| env.print()}) ]);
id := id + 1;
env.id := id;
seq1.start(env);
*/

/*
// Testing multiplexer
def seq2 := Sequence.new([ dsw.d([`d]), esw.e([`e]), fsw.f([`f]) ]);
def miws := Multiplexer.new(seq2, 3);
def seq1 := Sequence.new([ asw.a([`a]), bsw.b([`b]), csw.c([`c]), miws, gsw.g([`g]), Local.new({|env| env.print()}) ]);
id := id + 1;
env.id := id;
seq1.start(env);
*/

/*
// Testing multiple instances without synchronization: number of instances created = 1, only 1 brancg (sequence)
def seq2 := Sequence.new([ dsw.d([`d]), esw.e([`e]), fsw.f([`f]) ]);
def miws := MultipleInstancesWithoutSynchronization.new(seq2, 3);
def seq1 := Sequence.new([ asw.a([`a]), bsw.b([`b]), csw.c([`c]), miws, Local.new({|env| env.print()}) ]);
id := id + 1;
env.id := id;
seq1.start(env);
*/

/*
// Testing multiple instances without synchronization, number of instances created = 2 (although 3 branches for simple merge but 2 is max nr of instances) 
def seq2 := Sequence.new([ gsw.g([`g]), Sequence.new([ isw.i([`i]), Local.new({|env| env.print()}) ]) ]);
def miws := MultipleInstancesWithoutSynchronization.new(seq2);
def parSplit := ParallelSplit.new( [ [ bsw.b([`b]), Connection.new(miws) ], [ csw.c([`c]), dsw.d([`d]), esw.e([`e]), Connection.new(miws) ], [ fsw.f([`f]), Connection.new(miws) ] ]);
def seq1 := Sequence.new([ asw.a([`a]), parSplit ]);
id := id + 1;
env.id := id;
seq1.start(env);
*/


def seq1 := Failure.new(Sequence.new([ asw.a([`a]), Failure.new(hsw.h([`h]), [Disconnection.new(Rediscover.new(1, bsw.b([`b])))]), hsw.h([`h]), Local.new({|env| env.print()}) ]),
						[NotFound.new(dsw.d([`d])), Disconnection.new(esw.e([`e]))]);
//seq1.start(env);

def seq2 := Sequence.new([ asw.a([`a]), Failure.new(hsw.h([`h]), [Disconnection.new(Skip.new()), Timeout.new(20, bsw.b([`b]))]), csw.c([`c]), Local.new({|env| env.print()}) ]);
//seq2.start(env);

def seq3 := Sequence.new([ asw.a([`a]), Failure.new(hsw.h([`h]), [Disconnection.new(Retry.new(1, Skip.new())), Timeout.new(20, bsw.b([`b]))]), csw.c([`c]), Local.new({|env| env.print()}) ]);
//seq3.start(env);

def seq4 := Failure.new(Sequence.new([ asw.a([`a]), hsw.h([`h]), csw.c([`c]), Local.new({|env| env.print()}) ]),
						[Timeout.new(2, Restart.new(1))]);
//seq4.start(env);

def par1 := ParallelSplit.new([ [asw.a([`a])], [bsw.b([`b]), csw.c([`c]), dsw.d([`d])], [esw.e([`e])] ]);
//par1.start(env);

def sync := Synchronize.new(fsw.f([`f]));
def par2 := ParallelSplit.new([ [asw.a([`a]), Connection.new(sync)], [bsw.b([`b]), csw.c([`c]), dsw.d([`d]), Connection.new(sync)], [esw.e([`e]), Connection.new(sync)] ]);
//par2.start(env);




