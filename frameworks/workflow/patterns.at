import /.at.lang.values;
import /.at.lang.futures;
import /.at.lang.multifutures;
enableFutures(false);
network.online();

deftype Pattern;
deftype Service;
deftype Table;
deftype SyncPattern <: Pattern;
deftype Activity;
deftype Compensation;
deftype RetryType <: Compensation;
deftype RediscoverType <: Compensation;
deftype SkipType <: Compensation;
deftype RestartType <: Compensation;
deftype FailureType;
deftype DisconnectionType <: FailureType;
deftype TimeoutType <: FailureType;
deftype NotFoundType <: FailureType;

deftype NoCondition <: lobby.at.types.Exception;
def XNoCondition := lobby.at.exceptions.createException(NoCondition);

def id := 0;

def Environment := object: {
	def dict := [];
	def id;
	
	def insert(name, value) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			dict := dict + [[name, value]];
		} else: {
			def curVal := dict[idx];
			if: ! (curVal[2] == value) then: {
				if: (is: curVal[2] taggedAs: Table) then: {
					def vals := curVal[2].find: {|v| (v == value)}; 
					if: (vals == nil)  then: {
						curVal[2] := curVal[2] + [value];
					};
				} else: { curVal[2] := [curVal[2], value] };
			};
		};
	};
	
	def replace(name, value) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			dict := dict + [[name, value]];
		} else: {
			dict[idx] := [name, value];
		};
	};
	
	def delete(name) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx != nil then: {
			dict[idx] := [];
		};
	};
	
	def find(name) {
		def idx := dict.find: { |keyValuePair|  (keyValuePair[1] == name) };
		if: idx == nil then: {
			false;
		} else: {
			dict[idx];
		};
	};
	
	def bind(arguments) {
		arguments.map: { |arg| if: arg.freeVariables() != [] then: { find(arg)[2]; } else: { arg; }; };
	};
	
	def isEmpty() {
		dict.isEmpty();
	};
	
	def merge(envs) {
		envs.each: { |env| env.dict.each: { |pair| insert(pair[1], pair[2]); }; };
	};
	
	def init(@envsToCopy) {
		self.merge(envsToCopy)
	};
	
	def print() {
		system.println(dict);
	};
};



def WorkflowPattern := object: {		
	def idx := 0;
	
	def createAsyncMsg(selector, args) {
		reflectOnActor().createMessage(selector, args, [FutureMessage]);
	};
	
	def createTimeoutMsg(selector, args, timeout) {
		reflectOnActor().createMessage(selector, args, [Due(seconds(timeout))]);
	};
	
	def execute(activity, env, continue, runIdx) {
		def arguments := activity.parameters;
		def msg := createAsyncMsg(activity.selector, env.bind(arguments));
		def timeout := env.find(`timeout)[2]; 
		if: (is: timeout taggedAs: TimeoutType) then: {
			msg := createTimeoutMsg(activity.selector, env.bind(arguments), timeout.duration);
		};
		def elapsed := false;
		def compensation := false;
		when: activity.service.tag discovered: { |service|
			if: !compensation then: {
				invoke(activity, service, msg, env, continue, runIdx);
				elapsed := true;
			};
		};
		/.at.support.timer.when: /.at.support.timer.seconds(20) elapsed: {		
			if: !elapsed then: {
				compensation := true;  // in orde to deactivity the when: discovered: event handler
				env.replace("compensating" + runIdx, true);  // in order to avoid several compensations to be executed
				def notFound := env.find(`notFound)[2];
				if: (((is: notFound taggedAs: NotFoundType).or: {is: notFound taggedAs: Pattern}).or: {is: notFound taggedAs: Activity}) then: {
					compensate(activity, notFound.compensation, msg, env, continue, runIdx);
				} else: {
					system.println("service not found error, no compensation specified");
				};
			};
		};
	};
	
	def invoke(activity, service, msg, env, continue, runIdx) {
		def timeout := env.find(`timeout)[2]; 
		def disconnection := env.find(`disconnection)[2];
		def output := activity.output;	
		when: service <+ msg becomes: { |reply|
			def idx := 1;
			reply.each: { |val| env.insert(output[idx], val); idx := idx + 1; }; 
			continue(reply);
		} catch: TimeoutException using: { |e|
			def compensating := env.find("compensating" + runIdx)[2];
			if: ((is: compensating taggedAs: TimeoutType).or: { (! (is: compensating taggedAs: FailureType)).and: {!compensating} }) then: {
				env.replace("compensating" + runIdx, timeout);
				system.println("timeout error");
				compensate(activity, timeout.compensation, msg, env, continue, runIdx, service);
			} else: {
				system.println("timeout error, but other compensation is already executed");
			};
		};
		whenever: service disconnected: {
			if: (((is: disconnection taggedAs: DisconnectionType).or: {is: disconnection taggedAs: Pattern}).or: {is: disconnection taggedAs: Activity}) then: {
				def compensating := env.find("compensating" + runIdx)[2];
				if: ((is: compensating taggedAs: DisconnectionType).or: { (! (is: compensating taggedAs: FailureType)).and: {!compensating} }) then: {
					env.replace("compensating" + runIdx, disconnection);
					system.println("disconnection error");
					compensate(activity, disconnection.compensation, msg, env, continue, runIdx, service); 
				} else: {
					system.println("disconnection error, but other compensation is already executed");
				};
			} else: {
				system.println("disconnection error, no compensation specified");
			};
		};
	};
	
	def compensate(activity, compensation, msg, env, continue, runIdx, service := nil) {
		if: (compensation == nil) then: {
			system.println("no compensation specified");
		} else: { 
			if: (is: compensation taggedAs: RediscoverType) then: {
				if: (compensation.triedTimes < compensation.maxTimes) then: {
					compensation.try();
					execute(activity, env, continue);
				} else: {
					compensate(activity, compensation.action, msg, env, continue, runIdx, service);
				};
			} else: {
				if: (is: compensation taggedAs: RetryType) then: {
					if: (compensation.triedTimes < compensation.maxTimes) then: {
						compensation.try();
						invoke(activity, service, msg, env, continue, runIdx);
					} else: {
						compensate(activity, compensation.action, msg, env, continue, runIdx, service);
					};
				} else: { 
					if: (is: compensation taggedAs: SkipType) then: {
						continue("skipped");
					} else: { 
						if: (is: compensation taggedAs: RestartType) then: {
							run(compensation.action, env, { | _ | _ })  // such that execution of remainder of component is not completed
						} else: {
							// compensating action is a component
							run(compensation, env, continue, env.find("compensating" + runIdx)[2]);
						};
					};
				};
			};
		};
 	};
	
	def run(component, env, continue := { | _ | _ }, compensating := false) {
		if: (! (((is: compensating taggedAs: FailureType).or: {is: compensating taggedAs: Pattern}).or: {is: compensating taggedAs: Activity})) then: {
			idx := idx + 1;
		};
		env.replace("compensating" + idx, compensating);
		if: (is: component taggedAs: Activity) then: {
			// Component is an activity, wrapping a service object.
			execute(component, env, continue, idx);
    	} else: { 
			// Component is a pattern, the engine must start it and then await its completion
			when: component.start(env) becomes: { |reply|
				continue(reply);
			};
		};
	};
};



def Sequence := object: {
    def componentTable;

	def init(cmpTable) {
    	componentTable := cmpTable;
	};
	
	def restart() {
		started := started - 1;
	};
	
	def start(env) {
		def	[result, resolver] := makeFuture();    		
		execute(1, env, resolver);
		result;
	};
		
	def execute(idx, env, resolver) {	
		def component := componentTable[idx];
		if: (idx < componentTable.length()) then: {
			WorkflowPattern^run(component, env, { | _ | self.execute(idx+1, env, resolver) });
		} else: {
			WorkflowPattern^run(component, env, { | _ | resolver.resolve(_) });
		};
	};
} taggedAs: [Pattern];



def ParallelSplit := object: {
    def componentTable;
	
    def init(bTable) {
		def i := 0;
		// convert the "pairs" [service, synchronize] in the component table to sequences
		def b[bTable.length()] { i := i+1; if: (is: bTable[i] taggedAs: Table) then: { Sequence.new(bTable[i]) } else: { bTable[i] }};
    	componentTable := b;
    };
  
	def start(env) {
		def [result, resolver] := makeFuture();
		execute(env, resolver);
		result;  
	};	
		
	def execute(env, resolver) {
		1.to: componentTable.length+1 do: { | idx |
			def clonedEnv := Environment.new(env);
			WorkflowPattern^run(componentTable[idx], clonedEnv, { | _ | resolver.resolve(_) });
		};
	};
} taggedAs: [Pattern];



def Connection := object: {
    def component;
 
    def init(cmp) {
        component := cmp;
        if: (is: cmp taggedAs: SyncPattern) then: {
            cmp.addSync();
       	};
    };
 
    def start(env) {
   		def [result, resolver] := makeFuture();
        execute(env, resolver);
     	result;
	};	
 
 	def execute(env, resolver) {
     	if: (is: component taggedAs: Pattern) then: {
        	// start the component and resolve with its reply as usual
         	when: component.start(env) becomes: { |reply|
				resolver.resolve(reply);
           	};                       
     	} else: {
       		system.println("error: Connection made to non-pattern component.");
     	};
   	};     
} taggedAs: [Pattern];



// also Structured Synchronizing Merge
def Synchronize := object: {
    def incomingBranches := 0;
    def nextComponent;
    def environments := [];    

    def init(cmp) {
    	nextComponent := cmp;
    };

	def addSync() {
		incomingBranches := incomingBranches + 1;
	};

	def start(env) {
		def [result, resolver] := makeFuture();
		environments := environments + [env];
		execute(env.id, resolver);
		result;
	};
	
	def execute(idValue, resolver) {
		def envsOfId := environments.filter: { |env| env.id == idValue; };
		if: (envsOfId.length() == incomingBranches) then: {
			def envs := environments.map: { |env| if: ! (env.id == idValue) then: { env };};
			environments := envs.filter: { |env| ! (env == nil) };
			def nEnv := Environment.new();
			nEnv.merge(envsOfId);
			WorkflowPattern^run(nextComponent, nEnv, { | _ | resolver.resolve(_) });
		};
	};
} taggedAs: [SyncPattern];



def ExclusiveChoice := object: {
        def test;
		def consequence;
		def alternative;
 
    def init(block, then, else) {
        test := block;
		consequence := then;
		alternative := else;
    };
 
  	def start(env) {
     	def [result, resolver] := makeFuture();
        execute(env, resolver);
      	result;
	};
 
  	def execute(env, resolver) {
		def method := test.method();
		def bindings := env.bind(method.parameters()); 
		if: (test.apply(bindings)) then: {
			WorkflowPattern^run(consequence, env, { | _ | resolver.resolve(_) });
		} else: {
			WorkflowPattern^run(alternative, env, { | _ | resolver.resolve(_) });
		};
  	};
} taggedAs: [Pattern];



def SimpleMerge := object: {
    def component;

    def init(cmp) {
    	component := cmp;
	};

	def start(env) {
		def [result, resolver] := makeFuture();
		execute(env, resolver);
		result;
	};
	
	def execute(env, resolver) {
		id := id  + 1;
		def clonedEnv := Environment.new(env);
		clonedEnv.id := id;
		WorkflowPattern^run(component, clonedEnv, { | _ | resolver.resolve(_) });
	};
} taggedAs: [Pattern];



def MultiChoice := object: {
    def componentTable;
	def futureTable;
	def conditionActions;
	
    def init(bTable) {
    	componentTable := bTable;
    };

  
	def start(env) {
		def [result, resolver] := makeFuture();
		conditionActions := componentTable.filter: { |car| 
													 def rule := car[1];
													 def method := rule.method();
													 def bindings := env.bind(method.parameters()); 
													 rule.apply(bindings); };
		if: (conditionActions.isEmpty()) then: {
			raise: XNoCondition.new("No matching condition found");
		} else: {
			execute(env, resolver);
		};
		result;
	};	
		
	def execute(env, resolver) {
		def clonedEnv := clone: env;
		1.to: conditionActions.length+1 do: { | idx |
			WorkflowPattern^run(conditionActions[idx][2], clonedEnv, { | _ | resolver.resolve(_) });
		};
	};
} taggedAs: [Pattern];



def StructuredDiscriminator := object: {
    def nextComponent;
    def started := false;
    def environments := [];

    def init(cmp) {
    	nextComponent := cmp;
    };

	def start(env) {
		def [result, resolver] := makeFuture();
		environments := environments + [env];
		execute(env, resolver);
		result;
	};
		
	def execute(env, resolver) {
		def envs := environments.filter: { |e| e.id == env.id };
		if: (envs.length() == 1) then: {
			WorkflowPattern^run(nextComponent, env, { | _ | resolver.resolve(_) });
		};
    };
} taggedAs: [Pattern];



def StructuredPartialJoin := object: {
    def nextComponent;
	def necessaryEnablements;
	def environments := [];
	def incomingBranches := 0;

    def init(cmp, nbr) {
		necessaryEnablements := nbr; //TODO check that nbr < incoming branches
    	nextComponent := cmp;
    };
    
    def addSync() {
		incomingBranches := incomingBranches + 1;
	};

	def start(env) {
		environments := environments + [env];
		def [result, resolver] := makeFuture();
		execute(env, resolver);
		result;
	};
		
	def execute(env, resolver) {
		def envs := [];
		environments.each: { |e| if: (env.id == e.id) then: { envs := envs + [e]; }; }; 
		if: (environments.length == necessaryEnablements) then: {
     		WorkflowPattern^run(nextComponent, env, { | _ | resolver.resolve(_) });
     	};
    };
} taggedAs: [SyncPattern];



def MultipleInstancesWithoutSynchronization := object: {
	def number := 0;
    def component;

    def init(cmp) {
    	component := cmp;
	};

	def start(env) {
		def [result, resolver] := makeFuture();
		number := number + 1;
		execute(env, resolver);
		result;
	};
	
	def execute(env, resolver) {
		0.to: number do: { |idx|
			id := id + 1;
			def clonedEnv := Environment.new(env);
			clonedEnv.id := id;
			WorkflowPattern^run(component, clonedEnv, { | _ | _ }); };
		resolver.resolve(0);
		
	};
} taggedAs: [Pattern];




def Failure := object: {
	def component;
	def failureEvents; 
	def result;
	def resolver;
	def started := false; 
	
	def init(c, fe) {
		component := c;
		failureEvents := fe;
		[result, resolver] := makeFuture(); 
	};
	
	def start(env) {
		if: !started then: {
			started := true;
			execute(env);
		};
		result;
	};
	
	def replaceFailure(failureEvent, env) {
		if: (is: failureEvent taggedAs: DisconnectionType) then: {
			env.replace(`disconnection, failureEvent);
		} else: {
			if: (is: failureEvent taggedAs: TimeoutType) then: {
				env.replace(`timeout, failureEvent);
			} else: {
				if: (is: failureEvent taggedAs: NotFoundType) then: {
					env.replace(`notFound, failureEvent);
				};
			};
		};
		if: (is: failureEvent.compensation taggedAs: RestartType) then: {
			failureEvent.compensation.updateAction(component);
		};
	};
	
	def execute(env) {
		def prevDisconnection := env.find(`disconnection)[2];
		def prevTimeout := env.find(`timeout)[2];
		def prevNotFound := env.find(`notFound)[2];
		failureEvents.each: { |failure| replaceFailure(failure, env); };
		WorkflowPattern^run(component, 
			env, 
			{ | _ | 
				env.replace(`disconnection, prevDisconnection);
				env.replace(`timeout, prevTimeout);
				resolver.resolve(_) });
	};
} taggedAs: [Pattern];



def Disconnection := object: {
	def compensation;
	
	def init(c) {
		compensation := c;
	};
} taggedAs: [DisconnectionType];



def Timeout := object: {
	def duration;
	def compensation;
	
	def init(d, c) {
		duration := d;
		compensation := c;
	};
} taggedAs: [TimeoutType];


def NotFound := object: {
	def compensation;
	
	def init(c) {
		compensation := c;
	};
} taggedAs: [NotFoundType];


def Retry := object: {
	def maxTimes;
	def triedTimes := 0;
	def action; 
	def result;
	def resolver;
	
	def init(t, a := nil) {
		[result, resolver] := makeFuture(); 
		maxTimes := t;
		action := a;
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
} taggedAs: [RetryType];



def Rediscover := object: {
	def maxTimes;
	def triedTimes := 0;
	def action; 
	def result;
	def resolver;
	
	def init(t, a := nil) {
		[result, resolver] := makeFuture(); 
		maxTimes := t;
		action := a;
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
} taggedAs: [RediscoverType];



def Skip := object: {
	def maxTimes := 1;
	def triedTimes := 0;
	def action := nil; 
	def result;
	def resolver;
	
	def init() {
		[result, resolver] := makeFuture(); 
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
} taggedAs: [SkipType];


def Restart := object: {
	def maxTimes;
	def triedTimes := 0;
	def action; 
	def result;
	def resolver;
	
	def init(t) {
		[result, resolver] := makeFuture(); 
		maxTimes := t;
	};
	
	def try() {
		triedTimes := triedTimes + 1;
	};
	
	def updateAction(component) {
		action := component;
	};
} taggedAs: [RestartType];



def ActivityPattern := object: {
	def service;
	def selector;
	def parameters;
	def output;
	
	def init(sw, sel, pars, outputVars) {  
		service	   := sw;
		selector   := sel;
		parameters := pars;
		output     := outputVars;
	};
} taggedAs: [Activity];



def createServiceMirror(baseObject) {
 	extend: defaultMirror.new(baseObject) with: {
			def invoke(rcv, inv) {
				if: (self.respondsTo(inv.selector))
					then: { super.invoke(rcv, inv) }
					else: { 
						if: (is: inv taggedAs: Trigger)
							then: { TriggerPattern.new(baseObject, inv.selector, inv.arguments) }
							else: { ActivityPattern.new(baseObject, inv.selector, inv.arguments.select(1, inv.arguments.length()), inv.arguments[inv.arguments.length()]) }
					}
			}
  	};
};

def makeServiceWrapper(aTag) {
	object: {
		def tag() { aTag };

	} mirroredBy: {|emptyBase| createServiceMirror(emptyBase)}
};



deftype Trigger;
deftype TriggerP;

def TriggerPattern := object: {
	def listenerType;
	def selector;
	def params;
	
	def init(serviceWrapper, sel, pars) {  
		listenerType	:= createTypeTag(serviceWrapper.tag.typeName.text + "Listener");
		selector			:= sel;
		params				:= pars;
	};
	
	def makeListener(env, res) {
		def listener := object: { 
			def environment := env; 
			def resolver 		:= res;
			def parameters  := params;
			def subscription;
		};
		
		(reflect: listener).addMethod(createMethod(selector, `[@values], `{
			1.to: parameters.length + 1 do: { | idx | self.environment.insert(self.parameters[idx], values[idx]) };
			self.subscription.cancel();
			self.resolver.resolve(values)
		}, []));
		
		listener
	};
	
	def start(env) {
		def [fut,res] := makeFuture();
		def listener	:= makeListener(env, res);

		listener.subscription := export: listener as: listenerType;
		
		fut
	}
} taggedAs: [TriggerP];

deftype outputT;

def output := extend: outputT with: {
	def annotateMessage(method) {
    	system.println("output");
    	method;
	};
};



def Local := object: {
	def block;
	
	def init(blk) {
		block := blk;
	};

	def start(env) {
		def [result, resolver] := makeFuture();
		resolver.resolve(block(env));
		result;
	};
} taggedAs: [Pattern];





// Test Code
deftype LocationService;
deftype WeatherService;
deftype GUIService;
deftype EndService;
deftype AService;
deftype BService;
deftype CService;
deftype DService;
deftype EService;
deftype FService;
deftype GService;
deftype HService;
deftype IService;

def locationServiceWrapper := makeServiceWrapper(LocationService);
def weatherServiceWrapper := makeServiceWrapper(WeatherService);
def guiServiceWrapper := makeServiceWrapper(GUIService);
def endServiceWrapper := makeServiceWrapper(EndService);
def asw := makeServiceWrapper(AService);
def bsw := makeServiceWrapper(BService);
def csw := makeServiceWrapper(CService);
def dsw := makeServiceWrapper(DService);
def esw := makeServiceWrapper(EService);
def fsw := makeServiceWrapper(FService);
def gsw := makeServiceWrapper(GService);
def hsw := makeServiceWrapper(HService);
def isw := makeServiceWrapper(IService);



def env := Environment.new();
env.insert(`gps, 99);
env.insert(`timeout, nil);
env.insert(`disconnection, nil);
env.insert(`notFound, nil);


