/**
 * AmbientTalk/2 Project
 * (c) Software Languages Lab (2006-2010)
 * Authors: Eline Philips
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


def initModule := lobby.frameworks.workflow.WFinit;
def activityModule := lobby.frameworks.workflow.activity;
def compensatingActionsModule := lobby.frameworks.workflow.compensatingActions;
def intensionalModule := lobby.frameworks.workflow.intensional;
import initModule;
import activityModule;
import compensatingActionsModule;
import intensionalModule;
import /.at.lang.values;
import /.at.lang.futures;
import /.at.lang.multifutures;

def WorkflowPattern := object: {        
    def idx := 0;
    
    def createAsyncMsg(selector, args) {
        reflectOnActor().createMessage(selector, args, [FutureMessage]);
    };
    
    def createTimeoutMsg(selector, args, timeout) {
        reflectOnActor().createMessage(selector, args, [Due(seconds(timeout))]);
    };
    
    def execute(activity, env, continue, runIdx) {
        if: (is: activity taggedAs: VarActivity) then: {
            // activity is a special kind of Activity, where service must be looked up in the environment
            executeVarActivity(activity, env, continue, runIdx);
        } else: {
        	if: (is: activity taggedAs: RuleActivity) then: {
        		// activity is a special kind of Activity, service must fulfill some constraints 
        		executeRuleActivity(activity, env, continue, runIdx);
        	} else: {
            	//def timeout := env.find(`timeout); 
            	def elapsed := false;
            	def compensation := false;
            	when: activity.service.tag discovered: { |service|
                	if: !compensation then: {
                    	invoke(activity, service, env, continue, runIdx);
                    	elapsed := true;
                	};
            	};
            	/.at.support.timer.when: /.at.support.timer.seconds(20) elapsed: {      
                	if: !elapsed then: {
                    	compensation := true;  // in orde to deactivity the when: discovered: event handler
                    	env.replace("compensating" + runIdx, true);  // in order to avoid several compensations to be executed
                    	def notFound := env.find(`notFound);
                    	if: (((is: notFound taggedAs: NotFoundType).or: {is: notFound taggedAs: Pattern}).or: {is: notFound taggedAs: Activity}) then: {
                      	  compensate(activity, notFound.compensation,  env, continue, runIdx);
                    	} else: {
                        	system.println("service not found error, no compensation specified");
                    	};
                    };
                };
            };
        };
    };
    
    
    def executeVarActivity(varAct, env, continue, runIdx) {
        def service := env.find(varAct.variableName);
        if: !compensation then: {
            invoke(varAct, service, env, continue, runIdx);
        };
    };
    
    
    def executeRuleActivity(ruleAct, env, continue, runIdx) {
    	def rule := ruleAct.rule;
    	def timeout := env.find(`timeout);
    	def arguments := ruleAct.parameters;
    	def output := ruleAct.output;
    	def msg := createAsyncMsg(ruleAct.selector, env.bind(arguments));
        if: (is: timeout taggedAs: TimeoutType) then: {
            msg := createTimeoutMsg(ruleAct.selector, env.bind(arguments), timeout.duration);
        };
        def ServiceDB := env.find(`serviceDB);
    	def closure := { |v| 
    		//def s := v.get(`farRef);
			def s := ServiceDB.find(v.get(`id));
    		when: s <+ msg becomes: { |reply|
            	if: (is: reply taggedAs: Table) then: {
                	def idx := 1;
                	reply.each: { |val| env.insert(output[idx].variable, val); idx := idx + 1; }; 
            	};
            	continue(reply); }; };
       rule.find(closure);
    };
    
    
    def invoke(activity, service, env, continue, runIdx) {
        def timeout := env.find(`timeout); 
        def disconnection := env.find(`disconnection);
        def output := activity.output;  
        def arguments := activity.parameters;
        def msg := createAsyncMsg(activity.selector, env.bind(arguments));
        if: (is: timeout taggedAs: TimeoutType) then: {
            msg := createTimeoutMsg(activity.selector, env.bind(arguments), timeout.duration);
        };
        when: service <+ msg becomes: { |reply|
            if: (is: reply taggedAs: Table) then: {
                def idx := 1;
                reply.each: { |val| env.insert(output[idx].variable, val); idx := idx + 1; }; 
            };
            continue(reply);
        } catch: TimeoutException using: { |e|
            def compensating := env.find("compensating" + runIdx);
            if: ((is: compensating taggedAs: TimeoutType).or: { (! (is: compensating taggedAs: FailureType)).and: {!compensating} }) then: {
                env.replace("compensating" + runIdx, timeout);
                system.println("timeout error");
                compensate(activity, timeout.compensation, env, continue, runIdx, service);
            } else: {
                system.println("timeout error, but other compensation is already executed");
            };
        };
        whenever: service disconnected: {
            if: (((is: disconnection taggedAs: DisconnectionType).or: {is: disconnection taggedAs: Pattern}).or: {is: disconnection taggedAs: Activity}) then: {
                def compensating := env.find("compensating" + runIdx);
                if: ((is: compensating taggedAs: DisconnectionType).or: { (! (is: compensating taggedAs: FailureType)).and: {!compensating} }) then: {
                    env.replace("compensating" + runIdx, disconnection);
                    system.println("disconnection error");
                    compensate(activity, disconnection.compensation, env, continue, runIdx, service); 
                } else: {
                    system.println("disconnection error, but other compensation is already executed");
                };
            } else: {
                system.println("disconnection error, no compensation specified");
            };
        };
    };
    
    def compensate(activity, compensation, env, continue, runIdx, service := nil) {
        if: (compensation == nil) then: {
            system.println("no compensation specified");
        } else: { 
            if: (is: compensation taggedAs: RediscoverType) then: {
                if: (compensation.triedTimes < compensation.maxTimes) then: {
                    compensation.try();
                    execute(activity, env, continue, runIdx);
                } else: {
                    compensate(activity, compensation.action, env, continue, runIdx, service);
                };
            } else: {
                if: (is: compensation taggedAs: RetryType) then: {
                    if: (compensation.triedTimes < compensation.maxTimes) then: {
                        compensation.try();
                        invoke(activity, service, env, continue, runIdx);
                    } else: {
                        compensate(activity, compensation.action, env, continue, runIdx, service);
                    };
                } else: { 
                    if: (is: compensation taggedAs: SkipType) then: {
                        continue("skipped");
                    } else: { 
                        if: (is: compensation taggedAs: RestartType) then: {
                            //TODO compensation.action.restart();
                            run(compensation.action, env, { | _ | _ })  // such that execution of remainder of component is not completed
                        } else: {
                            // compensating action is a component
                            run(compensation, env, continue, env.find("compensating" + runIdx));
                        };
                    };
                };
            };
        };
    };

    def run(component, env, continue := { | _ | _ }, compensating := false) {
        if: (! (((is: compensating taggedAs: FailureType).or: {is: compensating taggedAs: Pattern}).or: {is: compensating taggedAs: Activity})) then: {
            idx := idx + 1;
        };
        env.replace("compensating" + idx, compensating);
        if: (is: component taggedAs: Activity) then: {
            // Component is an activity, wrapping a service object.
            execute(component, env, continue, idx);
        } else: { 
            // Component is a pattern, the engine must start it and then await its completion
            when: component.start(env) becomes: { |reply|
                continue(reply);
            };
        };
    };
};


def WorkflowPatternModule := object: {
    def WorkflowPattern := WorkflowPattern;
};